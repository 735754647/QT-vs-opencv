/***********************************************************
 * File generated by the HALCON-Compiler hcomp version 12.0
 * Usage: Interface to C++
 *
 * Software by: MVTec Software GmbH, www.mvtec.com
 ***********************************************************/


#ifndef HCPP_HIMAGE
#define HCPP_HIMAGE

namespace HalconCpp
{

// Represents an instance of an image object(-array).
class LIntExport HImage : public HObject
{

public:

  // Create an uninitialized instance
  HImage():HObject() {}

  // Copy constructor
  HImage(const HImage& source) : HObject(source) {}

  // Copy constructor
  HImage(const HObject& object);

  // Create HImage from object id. For copy=false takes
  // over management of input key. Type of key must match!
  explicit HImage(Hkey key, bool copy=true);

  // Access of object tuple element
  const HImage operator [] (Hlong index) const;

  // Deep copy of all data represented by this object instance
  HImage Clone() const;



/*****************************************************************************
 * Operator-based class constructors
 *****************************************************************************/

  // gen_image1: Create an image from a pointer to the pixels.
  explicit HImage(const HString& Type, Hlong Width, Hlong Height, void* PixelPointer);

  // gen_image1: Create an image from a pointer to the pixels.
  explicit HImage(const char* Type, Hlong Width, Hlong Height, void* PixelPointer);

  // gen_image_const: Create an image with constant gray value.
  explicit HImage(const HString& Type, Hlong Width, Hlong Height);

  // gen_image_const: Create an image with constant gray value.
  explicit HImage(const char* Type, Hlong Width, Hlong Height);

  // read_image: Read an image with different file formats.
  explicit HImage(const HTuple& FileName);

  // read_image: Read an image with different file formats.
  explicit HImage(const HString& FileName);

  // read_image: Read an image with different file formats.
  explicit HImage(const char* FileName);


/*****************************************************************************
 * Operator overloads (non-member overloads reside in HOperatorOverloads.h)  *
 *****************************************************************************/

  // Invert image
  HImage operator - () const;

  // Convert image to domain region
  operator HRegion() const;

  
/*****************************************************************************
 * Non-generic convenience members
 *****************************************************************************/

  // The area of the region
  HTuple Width();

  // The center row of the region
  HTuple Height();
  
  


  /***************************************************************************
   * Operators                                                               *
   ***************************************************************************/

  // Image restoration by Wiener filtering.
  HImage WienerFilterNi(const HImage& Psf, const HRegion& NoiseRegion, Hlong MaskWidth, Hlong MaskHeight) const;

  // Image restoration by Wiener filtering.
  HImage WienerFilter(const HImage& Psf, const HImage& FilteredImage) const;

  // Generate an impulse response of a (linearly) motion blurring.
  void GenPsfMotion(Hlong PSFwidth, Hlong PSFheight, double Blurring, Hlong Angle, Hlong Type);

  // Simulation of (linearly) motion blur.
  HImage SimulateMotion(double Blurring, Hlong Angle, Hlong Type) const;

  // Generate an impulse response of an uniform out-of-focus blurring.
  void GenPsfDefocus(Hlong PSFwidth, Hlong PSFheight, double Blurring);

  // Simulate an uniform out-of-focus blurring of an image.
  HImage SimulateDefocus(double Blurring) const;

  // Compare an image to a variation model.
  HRegion CompareExtVariationModel(const HVariationModel& ModelID, const HString& Mode) const;

  // Compare an image to a variation model.
  HRegion CompareExtVariationModel(const HVariationModel& ModelID, const char* Mode) const;

  // Compare an image to a variation model.
  HRegion CompareVariationModel(const HVariationModel& ModelID) const;

  // Train a variation model.
  void TrainVariationModel(const HVariationModel& ModelID) const;

  // Compute a projective transformation matrix and the radial distortion coefficient between two images by finding correspondences between points based on known approximations of the projective transformation matrix and the radial distortion coefficient.
  HHomMat2D ProjMatchPointsDistortionRansacGuided(const HImage& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HString& GrayMatchMethod, Hlong MaskSize, const HHomMat2D& HomMat2DGuide, double KappaGuide, double DistanceTolerance, const HTuple& MatchThreshold, const HString& EstimationMethod, const HTuple& DistanceThreshold, Hlong RandSeed, double* Kappa, double* Error, HTuple* Points1, HTuple* Points2) const;

  // Compute a projective transformation matrix and the radial distortion coefficient between two images by finding correspondences between points based on known approximations of the projective transformation matrix and the radial distortion coefficient.
  HHomMat2D ProjMatchPointsDistortionRansacGuided(const HImage& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HString& GrayMatchMethod, Hlong MaskSize, const HHomMat2D& HomMat2DGuide, double KappaGuide, double DistanceTolerance, Hlong MatchThreshold, const HString& EstimationMethod, double DistanceThreshold, Hlong RandSeed, double* Kappa, double* Error, HTuple* Points1, HTuple* Points2) const;

  // Compute a projective transformation matrix and the radial distortion coefficient between two images by finding correspondences between points based on known approximations of the projective transformation matrix and the radial distortion coefficient.
  HHomMat2D ProjMatchPointsDistortionRansacGuided(const HImage& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const char* GrayMatchMethod, Hlong MaskSize, const HHomMat2D& HomMat2DGuide, double KappaGuide, double DistanceTolerance, Hlong MatchThreshold, const char* EstimationMethod, double DistanceThreshold, Hlong RandSeed, double* Kappa, double* Error, HTuple* Points1, HTuple* Points2) const;

  // Compute a projective transformation matrix between two images and the radial distortion coefficient by automatically finding correspondences between points.
  HHomMat2D ProjMatchPointsDistortionRansac(const HImage& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HString& GrayMatchMethod, Hlong MaskSize, Hlong RowMove, Hlong ColMove, Hlong RowTolerance, Hlong ColTolerance, const HTuple& Rotation, const HTuple& MatchThreshold, const HString& EstimationMethod, const HTuple& DistanceThreshold, Hlong RandSeed, double* Kappa, double* Error, HTuple* Points1, HTuple* Points2) const;

  // Compute a projective transformation matrix between two images and the radial distortion coefficient by automatically finding correspondences between points.
  HHomMat2D ProjMatchPointsDistortionRansac(const HImage& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HString& GrayMatchMethod, Hlong MaskSize, Hlong RowMove, Hlong ColMove, Hlong RowTolerance, Hlong ColTolerance, double Rotation, Hlong MatchThreshold, const HString& EstimationMethod, double DistanceThreshold, Hlong RandSeed, double* Kappa, double* Error, HTuple* Points1, HTuple* Points2) const;

  // Compute a projective transformation matrix between two images and the radial distortion coefficient by automatically finding correspondences between points.
  HHomMat2D ProjMatchPointsDistortionRansac(const HImage& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const char* GrayMatchMethod, Hlong MaskSize, Hlong RowMove, Hlong ColMove, Hlong RowTolerance, Hlong ColTolerance, double Rotation, Hlong MatchThreshold, const char* EstimationMethod, double DistanceThreshold, Hlong RandSeed, double* Kappa, double* Error, HTuple* Points1, HTuple* Points2) const;

  // Compute a projective transformation matrix between two images by finding correspondences between points based on a known approximation of the projective transformation matrix.
  HHomMat2D ProjMatchPointsRansacGuided(const HImage& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HString& GrayMatchMethod, Hlong MaskSize, const HHomMat2D& HomMat2DGuide, double DistanceTolerance, const HTuple& MatchThreshold, const HString& EstimationMethod, double DistanceThreshold, Hlong RandSeed, HTuple* Points1, HTuple* Points2) const;

  // Compute a projective transformation matrix between two images by finding correspondences between points based on a known approximation of the projective transformation matrix.
  HHomMat2D ProjMatchPointsRansacGuided(const HImage& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HString& GrayMatchMethod, Hlong MaskSize, const HHomMat2D& HomMat2DGuide, double DistanceTolerance, Hlong MatchThreshold, const HString& EstimationMethod, double DistanceThreshold, Hlong RandSeed, HTuple* Points1, HTuple* Points2) const;

  // Compute a projective transformation matrix between two images by finding correspondences between points based on a known approximation of the projective transformation matrix.
  HHomMat2D ProjMatchPointsRansacGuided(const HImage& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const char* GrayMatchMethod, Hlong MaskSize, const HHomMat2D& HomMat2DGuide, double DistanceTolerance, Hlong MatchThreshold, const char* EstimationMethod, double DistanceThreshold, Hlong RandSeed, HTuple* Points1, HTuple* Points2) const;

  // Compute a projective transformation matrix between two images by finding correspondences between points.
  HHomMat2D ProjMatchPointsRansac(const HImage& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HString& GrayMatchMethod, Hlong MaskSize, Hlong RowMove, Hlong ColMove, Hlong RowTolerance, Hlong ColTolerance, const HTuple& Rotation, const HTuple& MatchThreshold, const HString& EstimationMethod, double DistanceThreshold, Hlong RandSeed, HTuple* Points1, HTuple* Points2) const;

  // Compute a projective transformation matrix between two images by finding correspondences between points.
  HHomMat2D ProjMatchPointsRansac(const HImage& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HString& GrayMatchMethod, Hlong MaskSize, Hlong RowMove, Hlong ColMove, Hlong RowTolerance, Hlong ColTolerance, double Rotation, Hlong MatchThreshold, const HString& EstimationMethod, double DistanceThreshold, Hlong RandSeed, HTuple* Points1, HTuple* Points2) const;

  // Compute a projective transformation matrix between two images by finding correspondences between points.
  HHomMat2D ProjMatchPointsRansac(const HImage& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const char* GrayMatchMethod, Hlong MaskSize, Hlong RowMove, Hlong ColMove, Hlong RowTolerance, Hlong ColTolerance, double Rotation, Hlong MatchThreshold, const char* EstimationMethod, double DistanceThreshold, Hlong RandSeed, HTuple* Points1, HTuple* Points2) const;

  // Receive an image over a socket connection.
  void ReceiveImage(const HSocket& Socket);

  // Send an image over a socket connection.
  void SendImage(const HSocket& Socket) const;

  // Compute the distance values for a rectified stereo image pair using multi-scanline optimization.
  HImage BinocularDistanceMs(const HImage& ImageRect2, HImage* Score, const HTuple& CamParamRect1, const HTuple& CamParamRect2, const HPose& RelPoseRect, Hlong MinDisparity, Hlong MaxDisparity, Hlong SurfaceSmoothing, Hlong EdgeSmoothing, const HTuple& GenParamName, const HTuple& GenParamValue) const;

  // Compute the distance values for a rectified stereo image pair using multi-scanline optimization.
  HImage BinocularDistanceMs(const HImage& ImageRect2, HImage* Score, const HTuple& CamParamRect1, const HTuple& CamParamRect2, const HPose& RelPoseRect, Hlong MinDisparity, Hlong MaxDisparity, Hlong SurfaceSmoothing, Hlong EdgeSmoothing, const HString& GenParamName, const HString& GenParamValue) const;

  // Compute the distance values for a rectified stereo image pair using multi-scanline optimization.
  HImage BinocularDistanceMs(const HImage& ImageRect2, HImage* Score, const HTuple& CamParamRect1, const HTuple& CamParamRect2, const HPose& RelPoseRect, Hlong MinDisparity, Hlong MaxDisparity, Hlong SurfaceSmoothing, Hlong EdgeSmoothing, const char* GenParamName, const char* GenParamValue) const;

  // Compute the disparities of a rectified stereo image pair using multi-scanline optimization.
  HImage BinocularDisparityMs(const HImage& ImageRect2, HImage* Score, Hlong MinDisparity, Hlong MaxDisparity, Hlong SurfaceSmoothing, Hlong EdgeSmoothing, const HTuple& GenParamName, const HTuple& GenParamValue) const;

  // Compute the disparities of a rectified stereo image pair using multi-scanline optimization.
  HImage BinocularDisparityMs(const HImage& ImageRect2, HImage* Score, Hlong MinDisparity, Hlong MaxDisparity, Hlong SurfaceSmoothing, Hlong EdgeSmoothing, const HString& GenParamName, const HString& GenParamValue) const;

  // Compute the disparities of a rectified stereo image pair using multi-scanline optimization.
  HImage BinocularDisparityMs(const HImage& ImageRect2, HImage* Score, Hlong MinDisparity, Hlong MaxDisparity, Hlong SurfaceSmoothing, Hlong EdgeSmoothing, const char* GenParamName, const char* GenParamValue) const;

  // Compute the distance values for a rectified stereo image pair using multigrid methods.
  HImage BinocularDistanceMg(const HImage& ImageRect2, HImage* Score, const HTuple& CamParamRect1, const HTuple& CamParamRect2, const HPose& RelPoseRect, double GrayConstancy, double GradientConstancy, double Smoothness, double InitialGuess, const HString& CalculateScore, const HTuple& MGParamName, const HTuple& MGParamValue) const;

  // Compute the distance values for a rectified stereo image pair using multigrid methods.
  HImage BinocularDistanceMg(const HImage& ImageRect2, HImage* Score, const HTuple& CamParamRect1, const HTuple& CamParamRect2, const HPose& RelPoseRect, double GrayConstancy, double GradientConstancy, double Smoothness, double InitialGuess, const HString& CalculateScore, const HString& MGParamName, const HString& MGParamValue) const;

  // Compute the distance values for a rectified stereo image pair using multigrid methods.
  HImage BinocularDistanceMg(const HImage& ImageRect2, HImage* Score, const HTuple& CamParamRect1, const HTuple& CamParamRect2, const HPose& RelPoseRect, double GrayConstancy, double GradientConstancy, double Smoothness, double InitialGuess, const char* CalculateScore, const char* MGParamName, const char* MGParamValue) const;

  // Compute the disparities of a rectified stereo image pair using multigrid methods.
  HImage BinocularDisparityMg(const HImage& ImageRect2, HImage* Score, double GrayConstancy, double GradientConstancy, double Smoothness, double InitialGuess, const HString& CalculateScore, const HTuple& MGParamName, const HTuple& MGParamValue) const;

  // Compute the disparities of a rectified stereo image pair using multigrid methods.
  HImage BinocularDisparityMg(const HImage& ImageRect2, HImage* Score, double GrayConstancy, double GradientConstancy, double Smoothness, double InitialGuess, const HString& CalculateScore, const HString& MGParamName, const HString& MGParamValue) const;

  // Compute the disparities of a rectified stereo image pair using multigrid methods.
  HImage BinocularDisparityMg(const HImage& ImageRect2, HImage* Score, double GrayConstancy, double GradientConstancy, double Smoothness, double InitialGuess, const char* CalculateScore, const char* MGParamName, const char* MGParamValue) const;

  // Compute the projective rectification of weakly calibrated binocular stereo images.
  HImage GenBinocularProjRectification(const HHomMat2D& FMatrix, const HTuple& CovFMat, Hlong Width1, Hlong Height1, Hlong Width2, Hlong Height2, const HTuple& SubSampling, const HString& Mapping, HTuple* CovFMatRect, HHomMat2D* H1, HHomMat2D* H2);

  // Compute the projective rectification of weakly calibrated binocular stereo images.
  HImage GenBinocularProjRectification(const HHomMat2D& FMatrix, const HTuple& CovFMat, Hlong Width1, Hlong Height1, Hlong Width2, Hlong Height2, Hlong SubSampling, const HString& Mapping, HTuple* CovFMatRect, HHomMat2D* H1, HHomMat2D* H2);

  // Compute the projective rectification of weakly calibrated binocular stereo images.
  HImage GenBinocularProjRectification(const HHomMat2D& FMatrix, const HTuple& CovFMat, Hlong Width1, Hlong Height1, Hlong Width2, Hlong Height2, Hlong SubSampling, const char* Mapping, HTuple* CovFMatRect, HHomMat2D* H1, HHomMat2D* H2);

  // Compute the fundamental matrix and the radial distortion coefficient for a pair of stereo images by automatically finding correspondences between image points.
  HHomMat2D MatchFundamentalMatrixDistortionRansac(const HImage& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HString& GrayMatchMethod, Hlong MaskSize, Hlong RowMove, Hlong ColMove, Hlong RowTolerance, Hlong ColTolerance, const HTuple& Rotation, const HTuple& MatchThreshold, const HString& EstimationMethod, const HTuple& DistanceThreshold, Hlong RandSeed, double* Kappa, double* Error, HTuple* Points1, HTuple* Points2) const;

  // Compute the fundamental matrix and the radial distortion coefficient for a pair of stereo images by automatically finding correspondences between image points.
  HHomMat2D MatchFundamentalMatrixDistortionRansac(const HImage& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HString& GrayMatchMethod, Hlong MaskSize, Hlong RowMove, Hlong ColMove, Hlong RowTolerance, Hlong ColTolerance, double Rotation, Hlong MatchThreshold, const HString& EstimationMethod, double DistanceThreshold, Hlong RandSeed, double* Kappa, double* Error, HTuple* Points1, HTuple* Points2) const;

  // Compute the fundamental matrix and the radial distortion coefficient for a pair of stereo images by automatically finding correspondences between image points.
  HHomMat2D MatchFundamentalMatrixDistortionRansac(const HImage& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const char* GrayMatchMethod, Hlong MaskSize, Hlong RowMove, Hlong ColMove, Hlong RowTolerance, Hlong ColTolerance, double Rotation, Hlong MatchThreshold, const char* EstimationMethod, double DistanceThreshold, Hlong RandSeed, double* Kappa, double* Error, HTuple* Points1, HTuple* Points2) const;

  // Compute the relative orientation between two cameras by automatically finding correspondences between image points.
  HPose MatchRelPoseRansac(const HImage& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HTuple& CamPar1, const HTuple& CamPar2, const HString& GrayMatchMethod, Hlong MaskSize, Hlong RowMove, Hlong ColMove, Hlong RowTolerance, Hlong ColTolerance, const HTuple& Rotation, const HTuple& MatchThreshold, const HString& EstimationMethod, const HTuple& DistanceThreshold, Hlong RandSeed, HTuple* CovRelPose, HTuple* Error, HTuple* Points1, HTuple* Points2) const;

  // Compute the relative orientation between two cameras by automatically finding correspondences between image points.
  HPose MatchRelPoseRansac(const HImage& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HTuple& CamPar1, const HTuple& CamPar2, const HString& GrayMatchMethod, Hlong MaskSize, Hlong RowMove, Hlong ColMove, Hlong RowTolerance, Hlong ColTolerance, double Rotation, Hlong MatchThreshold, const HString& EstimationMethod, double DistanceThreshold, Hlong RandSeed, HTuple* CovRelPose, double* Error, HTuple* Points1, HTuple* Points2) const;

  // Compute the relative orientation between two cameras by automatically finding correspondences between image points.
  HPose MatchRelPoseRansac(const HImage& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HTuple& CamPar1, const HTuple& CamPar2, const char* GrayMatchMethod, Hlong MaskSize, Hlong RowMove, Hlong ColMove, Hlong RowTolerance, Hlong ColTolerance, double Rotation, Hlong MatchThreshold, const char* EstimationMethod, double DistanceThreshold, Hlong RandSeed, HTuple* CovRelPose, double* Error, HTuple* Points1, HTuple* Points2) const;

  // Compute the essential matrix for a pair of stereo images by automatically finding correspondences between image points.
  HHomMat2D MatchEssentialMatrixRansac(const HImage& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HHomMat2D& CamMat1, const HHomMat2D& CamMat2, const HString& GrayMatchMethod, Hlong MaskSize, Hlong RowMove, Hlong ColMove, Hlong RowTolerance, Hlong ColTolerance, const HTuple& Rotation, const HTuple& MatchThreshold, const HString& EstimationMethod, const HTuple& DistanceThreshold, Hlong RandSeed, HTuple* CovEMat, HTuple* Error, HTuple* Points1, HTuple* Points2) const;

  // Compute the essential matrix for a pair of stereo images by automatically finding correspondences between image points.
  HHomMat2D MatchEssentialMatrixRansac(const HImage& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HHomMat2D& CamMat1, const HHomMat2D& CamMat2, const HString& GrayMatchMethod, Hlong MaskSize, Hlong RowMove, Hlong ColMove, Hlong RowTolerance, Hlong ColTolerance, double Rotation, Hlong MatchThreshold, const HString& EstimationMethod, double DistanceThreshold, Hlong RandSeed, HTuple* CovEMat, double* Error, HTuple* Points1, HTuple* Points2) const;

  // Compute the essential matrix for a pair of stereo images by automatically finding correspondences between image points.
  HHomMat2D MatchEssentialMatrixRansac(const HImage& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HHomMat2D& CamMat1, const HHomMat2D& CamMat2, const char* GrayMatchMethod, Hlong MaskSize, Hlong RowMove, Hlong ColMove, Hlong RowTolerance, Hlong ColTolerance, double Rotation, Hlong MatchThreshold, const char* EstimationMethod, double DistanceThreshold, Hlong RandSeed, HTuple* CovEMat, double* Error, HTuple* Points1, HTuple* Points2) const;

  // Compute the fundamental matrix for a pair of stereo images by automatically finding correspondences between image points.
  HHomMat2D MatchFundamentalMatrixRansac(const HImage& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HString& GrayMatchMethod, Hlong MaskSize, Hlong RowMove, Hlong ColMove, Hlong RowTolerance, Hlong ColTolerance, const HTuple& Rotation, const HTuple& MatchThreshold, const HString& EstimationMethod, const HTuple& DistanceThreshold, Hlong RandSeed, HTuple* CovFMat, double* Error, HTuple* Points1, HTuple* Points2) const;

  // Compute the fundamental matrix for a pair of stereo images by automatically finding correspondences between image points.
  HHomMat2D MatchFundamentalMatrixRansac(const HImage& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HString& GrayMatchMethod, Hlong MaskSize, Hlong RowMove, Hlong ColMove, Hlong RowTolerance, Hlong ColTolerance, double Rotation, Hlong MatchThreshold, const HString& EstimationMethod, double DistanceThreshold, Hlong RandSeed, HTuple* CovFMat, double* Error, HTuple* Points1, HTuple* Points2) const;

  // Compute the fundamental matrix for a pair of stereo images by automatically finding correspondences between image points.
  HHomMat2D MatchFundamentalMatrixRansac(const HImage& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const char* GrayMatchMethod, Hlong MaskSize, Hlong RowMove, Hlong ColMove, Hlong RowTolerance, Hlong ColTolerance, double Rotation, Hlong MatchThreshold, const char* EstimationMethod, double DistanceThreshold, Hlong RandSeed, HTuple* CovFMat, double* Error, HTuple* Points1, HTuple* Points2) const;

  // Compute the distance values for a rectified stereo image pair using correlation techniques.
  HImage BinocularDistance(const HImage& ImageRect2, HImage* Score, const HTuple& CamParamRect1, const HTuple& CamParamRect2, const HPose& RelPoseRect, const HString& Method, Hlong MaskWidth, Hlong MaskHeight, const HTuple& TextureThresh, Hlong MinDisparity, Hlong MaxDisparity, Hlong NumLevels, const HTuple& ScoreThresh, const HTuple& Filter, const HTuple& SubDistance) const;

  // Compute the distance values for a rectified stereo image pair using correlation techniques.
  HImage BinocularDistance(const HImage& ImageRect2, HImage* Score, const HTuple& CamParamRect1, const HTuple& CamParamRect2, const HPose& RelPoseRect, const HString& Method, Hlong MaskWidth, Hlong MaskHeight, double TextureThresh, Hlong MinDisparity, Hlong MaxDisparity, Hlong NumLevels, double ScoreThresh, const HString& Filter, const HString& SubDistance) const;

  // Compute the distance values for a rectified stereo image pair using correlation techniques.
  HImage BinocularDistance(const HImage& ImageRect2, HImage* Score, const HTuple& CamParamRect1, const HTuple& CamParamRect2, const HPose& RelPoseRect, const char* Method, Hlong MaskWidth, Hlong MaskHeight, double TextureThresh, Hlong MinDisparity, Hlong MaxDisparity, Hlong NumLevels, double ScoreThresh, const char* Filter, const char* SubDistance) const;

  // Compute the disparities of a rectified image pair using correlation techniques.
  HImage BinocularDisparity(const HImage& ImageRect2, HImage* Score, const HString& Method, Hlong MaskWidth, Hlong MaskHeight, const HTuple& TextureThresh, Hlong MinDisparity, Hlong MaxDisparity, Hlong NumLevels, const HTuple& ScoreThresh, const HTuple& Filter, const HString& SubDisparity) const;

  // Compute the disparities of a rectified image pair using correlation techniques.
  HImage BinocularDisparity(const HImage& ImageRect2, HImage* Score, const HString& Method, Hlong MaskWidth, Hlong MaskHeight, double TextureThresh, Hlong MinDisparity, Hlong MaxDisparity, Hlong NumLevels, double ScoreThresh, const HString& Filter, const HString& SubDisparity) const;

  // Compute the disparities of a rectified image pair using correlation techniques.
  HImage BinocularDisparity(const HImage& ImageRect2, HImage* Score, const char* Method, Hlong MaskWidth, Hlong MaskHeight, double TextureThresh, Hlong MinDisparity, Hlong MaxDisparity, Hlong NumLevels, double ScoreThresh, const char* Filter, const char* SubDisparity) const;

  // Generate transformation maps that describe the mapping of the images of a binocular camera pair to a common rectified image plane.
  HImage GenBinocularRectificationMap(const HTuple& CamParam1, const HTuple& CamParam2, const HPose& RelPose, double SubSampling, const HString& Method, const HString& MapType, HTuple* CamParamRect1, HTuple* CamParamRect2, HPose* CamPoseRect1, HPose* CamPoseRect2, HPose* RelPoseRect);

  // Generate transformation maps that describe the mapping of the images of a binocular camera pair to a common rectified image plane.
  HImage GenBinocularRectificationMap(const HTuple& CamParam1, const HTuple& CamParam2, const HPose& RelPose, double SubSampling, const char* Method, const char* MapType, HTuple* CamParamRect1, HTuple* CamParamRect2, HPose* CamPoseRect1, HPose* CamPoseRect2, HPose* RelPoseRect);

  // Get the iconic results of a measurement performed with the sheet-of light technique.
  void GetSheetOfLightResult(const HSheetOfLightModel& SheetOfLightModelID, const HTuple& ResultName);

  // Get the iconic results of a measurement performed with the sheet-of light technique.
  void GetSheetOfLightResult(const HSheetOfLightModel& SheetOfLightModelID, const HString& ResultName);

  // Get the iconic results of a measurement performed with the sheet-of light technique.
  void GetSheetOfLightResult(const HSheetOfLightModel& SheetOfLightModelID, const char* ResultName);

  // Apply the calibration transformations to the input disparity image.
  void ApplySheetOfLightCalibration(const HSheetOfLightModel& SheetOfLightModelID) const;

  // Set sheet of light profiles by measured disparities.
  void SetProfileSheetOfLight(const HSheetOfLightModel& SheetOfLightModelID, const HTuple& MovementPoses) const;

  // Process the profile image provided as input and store the resulting disparity to the sheet-of-light model.
  void MeasureProfileSheetOfLight(const HSheetOfLightModel& SheetOfLightModelID, const HTuple& MovementPose) const;

  // Shade a height field.
  HImage ShadeHeightField(const HTuple& Slant, const HTuple& Tilt, const HTuple& Albedo, const HTuple& Ambient, const HString& Shadows) const;

  // Shade a height field.
  HImage ShadeHeightField(double Slant, double Tilt, double Albedo, double Ambient, const HString& Shadows) const;

  // Shade a height field.
  HImage ShadeHeightField(double Slant, double Tilt, double Albedo, double Ambient, const char* Shadows) const;

  // Estimate the albedo of a surface and the amount of ambient light.
  HTuple EstimateAlAm(HTuple* Ambient) const;

  // Estimate the albedo of a surface and the amount of ambient light.
  double EstimateAlAm(double* Ambient) const;

  // Estimate the slant of a light source and the albedo of a surface.
  HTuple EstimateSlAlZc(HTuple* Albedo) const;

  // Estimate the slant of a light source and the albedo of a surface.
  double EstimateSlAlZc(double* Albedo) const;

  // Estimate the slant of a light source and the albedo of a surface.
  HTuple EstimateSlAlLr(HTuple* Albedo) const;

  // Estimate the slant of a light source and the albedo of a surface.
  double EstimateSlAlLr(double* Albedo) const;

  // Estimate the tilt of a light source.
  HTuple EstimateTiltZc() const;

  // Estimate the tilt of a light source.
  HTuple EstimateTiltLr() const;

  // Reconstruct a surface from at least three gray value images.
  HImage PhotStereo(const HTuple& Slants, const HTuple& Tilts) const;

  // Reconstruct a surface from surface gradients.
  HImage ReconstructHeightFieldFromGradient(const HString& ReconstructionMethod, const HTuple& GenParamName, const HTuple& GenParamValue) const;

  // Reconstruct a surface from surface gradients.
  HImage ReconstructHeightFieldFromGradient(const char* ReconstructionMethod, const HTuple& GenParamName, const HTuple& GenParamValue) const;

  // Reconstruct a surface according to the photometric stereo technique.
  HImage PhotometricStereo(HImage* Gradient, HImage* Albedo, const HTuple& Slants, const HTuple& Tilts, const HTuple& ResultType, const HString& ReconstructionMethod, const HTuple& GenParamName, const HTuple& GenParamValue) const;

  // Reconstruct a surface according to the photometric stereo technique.
  HImage PhotometricStereo(HImage* Gradient, HImage* Albedo, const HTuple& Slants, const HTuple& Tilts, const HTuple& ResultType, const char* ReconstructionMethod, const HTuple& GenParamName, const HTuple& GenParamValue) const;

  // Reconstruct a surface from a gray value image.
  HImage SfsPentland(const HTuple& Slant, const HTuple& Tilt, const HTuple& Albedo, const HTuple& Ambient) const;

  // Reconstruct a surface from a gray value image.
  HImage SfsPentland(double Slant, double Tilt, double Albedo, double Ambient) const;

  // Reconstruct a surface from a gray value image.
  HImage SfsOrigLr(const HTuple& Slant, const HTuple& Tilt, const HTuple& Albedo, const HTuple& Ambient) const;

  // Reconstruct a surface from a gray value image.
  HImage SfsOrigLr(double Slant, double Tilt, double Albedo, double Ambient) const;

  // Reconstruct a surface from a gray value image.
  HImage SfsModLr(const HTuple& Slant, const HTuple& Tilt, const HTuple& Albedo, const HTuple& Ambient) const;

  // Reconstruct a surface from a gray value image.
  HImage SfsModLr(double Slant, double Tilt, double Albedo, double Ambient) const;

  // Find text in an image.
  HTextResult FindText(const HTextModel& TextModel) const;

  // Classify a byte image using a look-up table.
  HRegion ClassifyImageClassLut(const HClassLUT& ClassLUTHandle) const;

  // Classify an image with a k-Nearest-Neighbor classifier.
  HRegion ClassifyImageClassKnn(HImage* DistanceImage, const HClassKnn& KNNHandle, double RejectionThreshold) const;

  // Add training samples from an image to the training data of a k-Nearest-Neighbor classifier.
  void AddSamplesImageClassKnn(const HRegion& ClassRegions, const HClassKnn& KNNHandle) const;

  // Classify an image with a Gaussian Mixture Model.
  HRegion ClassifyImageClassGmm(const HClassGmm& GMMHandle, double RejectionThreshold) const;

  // Add training samples from an image to the training data of a Gaussian Mixture Model.
  void AddSamplesImageClassGmm(const HRegion& ClassRegions, const HClassGmm& GMMHandle, double Randomize) const;

  // Classify an image with a support vector machine.
  HRegion ClassifyImageClassSvm(const HClassSvm& SVMHandle) const;

  // Add training samples from an image to the training data of a support vector machine.
  void AddSamplesImageClassSvm(const HRegion& ClassRegions, const HClassSvm& SVMHandle) const;

  // Classify an image with a multilayer perceptron.
  HRegion ClassifyImageClassMlp(const HClassMlp& MLPHandle, double RejectionThreshold) const;

  // Add training samples from an image to the training data of a multilayer perceptron.
  void AddSamplesImageClassMlp(const HRegion& ClassRegions, const HClassMlp& MLPHandle) const;

  // Construct classes for class_ndim_norm.
  HTuple LearnNdimNorm(const HRegion& Foreground, const HRegion& Background, const HString& Metric, const HTuple& Distance, const HTuple& MinNumberPercent, HTuple* Center, double* Quality) const;

  // Construct classes for class_ndim_norm.
  HTuple LearnNdimNorm(const HRegion& Foreground, const HRegion& Background, const HString& Metric, double Distance, double MinNumberPercent, HTuple* Center, double* Quality) const;

  // Construct classes for class_ndim_norm.
  HTuple LearnNdimNorm(const HRegion& Foreground, const HRegion& Background, const char* Metric, double Distance, double MinNumberPercent, HTuple* Center, double* Quality) const;

  // Train a classificator using a multi-channel image.
  void LearnNdimBox(const HRegion& Foreground, const HRegion& Background, const HClassBox& ClassifHandle) const;

  // Classify pixels using hyper-cuboids.
  HRegion ClassNdimBox(const HClassBox& ClassifHandle) const;

  // Classify pixels using hyper-spheres or hyper-cubes.
  HRegion ClassNdimNorm(const HString& Metric, const HString& SingleMultiple, const HTuple& Radius, const HTuple& Center) const;

  // Classify pixels using hyper-spheres or hyper-cubes.
  HRegion ClassNdimNorm(const HString& Metric, const HString& SingleMultiple, double Radius, double Center) const;

  // Classify pixels using hyper-spheres or hyper-cubes.
  HRegion ClassNdimNorm(const char* Metric, const char* SingleMultiple, double Radius, double Center) const;

  // Segment an image using two-dimensional pixel classification.
  HRegion Class2dimSup(const HImage& ImageRow, const HRegion& FeatureSpace) const;

  // Segment two images by clustering.
  HRegion Class2dimUnsup(const HImage& Image2, Hlong Threshold, Hlong NumClasses) const;

  // Compare two images pixel by pixel.
  HRegion CheckDifference(const HImage& Pattern, const HString& Mode, Hlong DiffLowerBound, Hlong DiffUpperBound, Hlong GrayOffset, Hlong AddRow, Hlong AddCol) const;

  // Compare two images pixel by pixel.
  HRegion CheckDifference(const HImage& Pattern, const char* Mode, Hlong DiffLowerBound, Hlong DiffUpperBound, Hlong GrayOffset, Hlong AddRow, Hlong AddCol) const;

  // Perform a threshold segmentation for extracting characters.
  HRegion CharThreshold(const HRegion& HistoRegion, double Sigma, const HTuple& Percent, HTuple* Threshold) const;

  // Perform a threshold segmentation for extracting characters.
  HRegion CharThreshold(const HRegion& HistoRegion, double Sigma, double Percent, Hlong* Threshold) const;

  // Extract regions with equal gray values from an image.
  HRegion LabelToRegion() const;

  // Suppress non-maximum points on an edge.
  HImage NonmaxSuppressionAmp(const HString& Mode) const;

  // Suppress non-maximum points on an edge.
  HImage NonmaxSuppressionAmp(const char* Mode) const;

  // Suppress non-maximum points on an edge using a direction image.
  HImage NonmaxSuppressionDir(const HImage& ImgDir, const HString& Mode) const;

  // Suppress non-maximum points on an edge using a direction image.
  HImage NonmaxSuppressionDir(const HImage& ImgDir, const char* Mode) const;

  // Perform a hysteresis threshold operation on an image.
  HRegion HysteresisThreshold(const HTuple& Low, const HTuple& High, Hlong MaxLength) const;

  // Perform a hysteresis threshold operation on an image.
  HRegion HysteresisThreshold(Hlong Low, Hlong High, Hlong MaxLength) const;

  // Segment an image using binary thresholding.
  HRegion BinaryThreshold(const HString& Method, const HString& LightDark, HTuple* UsedThreshold) const;

  // Segment an image using binary thresholding.
  HRegion BinaryThreshold(const HString& Method, const HString& LightDark, Hlong* UsedThreshold) const;

  // Segment an image using binary thresholding.
  HRegion BinaryThreshold(const char* Method, const char* LightDark, Hlong* UsedThreshold) const;

  // Segment an image using local thresholding.
  HRegion LocalThreshold(const HString& Method, const HString& LightDark, const HTuple& GenParamName, const HTuple& GenParamValue) const;

  // Segment an image using local thresholding.
  HRegion LocalThreshold(const HString& Method, const HString& LightDark, const HString& GenParamName, Hlong GenParamValue) const;

  // Segment an image using local thresholding.
  HRegion LocalThreshold(const char* Method, const char* LightDark, const char* GenParamName, Hlong GenParamValue) const;

  // Threshold an image by local mean and standard deviation analysis.
  HRegion VarThreshold(Hlong MaskWidth, Hlong MaskHeight, const HTuple& StdDevScale, const HTuple& AbsThreshold, const HString& LightDark) const;

  // Threshold an image by local mean and standard deviation analysis.
  HRegion VarThreshold(Hlong MaskWidth, Hlong MaskHeight, double StdDevScale, double AbsThreshold, const HString& LightDark) const;

  // Threshold an image by local mean and standard deviation analysis.
  HRegion VarThreshold(Hlong MaskWidth, Hlong MaskHeight, double StdDevScale, double AbsThreshold, const char* LightDark) const;

  // Segment an image using a local threshold.
  HRegion DynThreshold(const HImage& ThresholdImage, const HTuple& Offset, const HString& LightDark) const;

  // Segment an image using a local threshold.
  HRegion DynThreshold(const HImage& ThresholdImage, double Offset, const HString& LightDark) const;

  // Segment an image using a local threshold.
  HRegion DynThreshold(const HImage& ThresholdImage, double Offset, const char* LightDark) const;

  // Segment an image using global threshold.
  HRegion Threshold(const HTuple& MinGray, const HTuple& MaxGray) const;

  // Segment an image using global threshold.
  HRegion Threshold(double MinGray, double MaxGray) const;

  // Extract level crossings from an image with subpixel accuracy.
  HXLDCont ThresholdSubPix(const HTuple& Threshold) const;

  // Extract level crossings from an image with subpixel accuracy.
  HXLDCont ThresholdSubPix(double Threshold) const;

  // Segment an image using regiongrowing for multi-channel images.
  HRegion RegiongrowingN(const HString& Metric, const HTuple& MinTolerance, const HTuple& MaxTolerance, Hlong MinSize) const;

  // Segment an image using regiongrowing for multi-channel images.
  HRegion RegiongrowingN(const HString& Metric, double MinTolerance, double MaxTolerance, Hlong MinSize) const;

  // Segment an image using regiongrowing for multi-channel images.
  HRegion RegiongrowingN(const char* Metric, double MinTolerance, double MaxTolerance, Hlong MinSize) const;

  // Segment an image using regiongrowing.
  HRegion Regiongrowing(Hlong Row, Hlong Column, const HTuple& Tolerance, Hlong MinSize) const;

  // Segment an image using regiongrowing.
  HRegion Regiongrowing(Hlong Row, Hlong Column, double Tolerance, Hlong MinSize) const;

  // Perform a regiongrowing using mean gray values.
  HRegion RegiongrowingMean(const HTuple& StartRows, const HTuple& StartColumns, double Tolerance, Hlong MinSize) const;

  // Perform a regiongrowing using mean gray values.
  HRegion RegiongrowingMean(Hlong StartRows, Hlong StartColumns, double Tolerance, Hlong MinSize) const;

  // Segment an image by "pouring water" over it.
  HRegion Pouring(const HString& Mode, Hlong MinGray, Hlong MaxGray) const;

  // Segment an image by "pouring water" over it.
  HRegion Pouring(const char* Mode, Hlong MinGray, Hlong MaxGray) const;

  // Extract watershed basins from an image using a threshold.
  HRegion WatershedsThreshold(const HTuple& Threshold) const;

  // Extract watershed basins from an image using a threshold.
  HRegion WatershedsThreshold(Hlong Threshold) const;

  // Extract watersheds and basins from an image.
  HRegion Watersheds(HRegion* Watersheds) const;

  // Extract zero crossings from an image.
  HRegion ZeroCrossing() const;

  // Extract zero crossings from an image with subpixel accuracy.
  HXLDCont ZeroCrossingSubPix() const;

  // Threshold operator for signed images.
  HRegion DualThreshold(Hlong MinSize, double MinGray, double Threshold) const;

  // Expand a region starting at a given line.
  HRegion ExpandLine(Hlong Coordinate, const HString& ExpandType, const HString& RowColumn, const HTuple& Threshold) const;

  // Expand a region starting at a given line.
  HRegion ExpandLine(Hlong Coordinate, const HString& ExpandType, const HString& RowColumn, double Threshold) const;

  // Expand a region starting at a given line.
  HRegion ExpandLine(Hlong Coordinate, const char* ExpandType, const char* RowColumn, double Threshold) const;

  // Detect all local minima in an image.
  HRegion LocalMin() const;

  // Detect all gray value lowlands.
  HRegion Lowlands() const;

  // Detect the centers of all gray value lowlands.
  HRegion LowlandsCenter() const;

  // Detect all local maxima in an image.
  HRegion LocalMax() const;

  // Detect all gray value plateaus.
  HRegion Plateaus() const;

  // Detect the centers of all gray value plateaus.
  HRegion PlateausCenter() const;

  // Segment an image using thresholds determined from its histogram.
  HRegion AutoThreshold(const HTuple& Sigma) const;

  // Segment an image using thresholds determined from its histogram.
  HRegion AutoThreshold(double Sigma) const;

  // Segment an image using an automatically determined threshold.
  HRegion BinThreshold() const;

  // Fast thresholding of images using global thresholds.
  HRegion FastThreshold(const HTuple& MinGray, const HTuple& MaxGray, Hlong MinSize) const;

  // Fast thresholding of images using global thresholds.
  HRegion FastThreshold(double MinGray, double MaxGray, Hlong MinSize) const;

  // Fill gaps between regions (depending on gray value or color) or split overlapping regions.
  HRegion ExpandGray(const HRegion& Regions, const HRegion& ForbiddenArea, const HTuple& Iterations, const HString& Mode, const HTuple& Threshold) const;

  // Fill gaps between regions (depending on gray value or color) or split overlapping regions.
  HRegion ExpandGray(const HRegion& Regions, const HRegion& ForbiddenArea, const HString& Iterations, const HString& Mode, Hlong Threshold) const;

  // Fill gaps between regions (depending on gray value or color) or split overlapping regions.
  HRegion ExpandGray(const HRegion& Regions, const HRegion& ForbiddenArea, const char* Iterations, const char* Mode, Hlong Threshold) const;

  // Fill gaps between regions (depending on gray value or color) or split overlapping regions.
  HRegion ExpandGrayRef(const HRegion& Regions, const HRegion& ForbiddenArea, const HTuple& Iterations, const HString& Mode, const HTuple& RefGray, const HTuple& Threshold) const;

  // Fill gaps between regions (depending on gray value or color) or split overlapping regions.
  HRegion ExpandGrayRef(const HRegion& Regions, const HRegion& ForbiddenArea, const HString& Iterations, const HString& Mode, Hlong RefGray, Hlong Threshold) const;

  // Fill gaps between regions (depending on gray value or color) or split overlapping regions.
  HRegion ExpandGrayRef(const HRegion& Regions, const HRegion& ForbiddenArea, const char* Iterations, const char* Mode, Hlong RefGray, Hlong Threshold) const;

  // Calculate the difference of two object tuples.
  HImage ObjDiff(const HImage& ObjectsSub) const;

  // Set single gray values in an image.
  void SetGrayval(const HTuple& Row, const HTuple& Column, const HTuple& Grayval) const;

  // Set single gray values in an image.
  void SetGrayval(Hlong Row, Hlong Column, double Grayval) const;

  // Paint XLD objects into an image.
  HImage PaintXld(const HXLD& XLD, const HTuple& Grayval) const;

  // Paint XLD objects into an image.
  HImage PaintXld(const HXLD& XLD, double Grayval) const;

  // Paint regions into an image.
  HImage PaintRegion(const HRegion& Region, const HTuple& Grayval, const HString& Type) const;

  // Paint regions into an image.
  HImage PaintRegion(const HRegion& Region, double Grayval, const HString& Type) const;

  // Paint regions into an image.
  HImage PaintRegion(const HRegion& Region, double Grayval, const char* Type) const;

  // Overpaint regions in an image.
  void OverpaintRegion(const HRegion& Region, const HTuple& Grayval, const HString& Type) const;

  // Overpaint regions in an image.
  void OverpaintRegion(const HRegion& Region, double Grayval, const HString& Type) const;

  // Overpaint regions in an image.
  void OverpaintRegion(const HRegion& Region, double Grayval, const char* Type) const;

  // Create an image with a specified constant gray value.
  HImage GenImageProto(const HTuple& Grayval) const;

  // Create an image with a specified constant gray value.
  HImage GenImageProto(double Grayval) const;

  // Paint the gray values of an image into another image.
  HImage PaintGray(const HImage& ImageDestination) const;

  // Overpaint the gray values of an image.
  void OverpaintGray(const HImage& ImageSource) const;

  // Copy an iconic object in the HALCON database.
  HImage CopyObj(Hlong Index, Hlong NumObj) const;

  // Concatenate two iconic object tuples.
  HImage ConcatObj(const HImage& Objects2) const;

  // Copy an image and allocate new memory for it.
  HImage CopyImage() const;

  // Select objects from an object tuple.
  HImage SelectObj(const HTuple& Index) const;

  // Select objects from an object tuple.
  HImage SelectObj(Hlong Index) const;

  // Compare iconic objects regarding equality.
  Hlong CompareObj(const HImage& Objects2, const HTuple& Epsilon) const;

  // Compare iconic objects regarding equality.
  Hlong CompareObj(const HImage& Objects2, double Epsilon) const;

  // Compare image objects regarding equality.
  Hlong TestEqualObj(const HImage& Objects2) const;

  // Create a three-channel image from a pointer to the interleaved pixels.
  void GenImageInterleaved(void* PixelPointer, const HString& ColorFormat, Hlong OriginalWidth, Hlong OriginalHeight, Hlong Alignment, const HString& Type, Hlong ImageWidth, Hlong ImageHeight, Hlong StartRow, Hlong StartColumn, Hlong BitsPerChannel, Hlong BitShift);

  // Create a three-channel image from a pointer to the interleaved pixels.
  void GenImageInterleaved(void* PixelPointer, const char* ColorFormat, Hlong OriginalWidth, Hlong OriginalHeight, Hlong Alignment, const char* Type, Hlong ImageWidth, Hlong ImageHeight, Hlong StartRow, Hlong StartColumn, Hlong BitsPerChannel, Hlong BitShift);

  // Create an image from three pointers to the pixels (red/green/blue).
  void GenImage3(const HString& Type, Hlong Width, Hlong Height, void* PixelPointerRed, void* PixelPointerGreen, void* PixelPointerBlue);

  // Create an image from three pointers to the pixels (red/green/blue).
  void GenImage3(const char* Type, Hlong Width, Hlong Height, void* PixelPointerRed, void* PixelPointerGreen, void* PixelPointerBlue);

  // Create an image from a pointer to the pixels.
  void GenImage1(const HString& Type, Hlong Width, Hlong Height, void* PixelPointer);

  // Create an image from a pointer to the pixels.
  void GenImage1(const char* Type, Hlong Width, Hlong Height, void* PixelPointer);

  // Create an image with constant gray value.
  void GenImageConst(const HString& Type, Hlong Width, Hlong Height);

  // Create an image with constant gray value.
  void GenImageConst(const char* Type, Hlong Width, Hlong Height);

  // Create a gray value ramp.
  void GenImageGrayRamp(double Alpha, double Beta, double Mean, Hlong Row, Hlong Column, Hlong Width, Hlong Height);

  // Create a three-channel image from three pointers on the pixels with storage management.
  void GenImage3Extern(const HString& Type, Hlong Width, Hlong Height, void* PointerRed, void* PointerGreen, void* PointerBlue, void* ClearProc);

  // Create a three-channel image from three pointers on the pixels with storage management.
  void GenImage3Extern(const char* Type, Hlong Width, Hlong Height, void* PointerRed, void* PointerGreen, void* PointerBlue, void* ClearProc);

  // Create an image from a pointer on the pixels with storage management.
  void GenImage1Extern(const HString& Type, Hlong Width, Hlong Height, void* PixelPointer, void* ClearProc);

  // Create an image from a pointer on the pixels with storage management.
  void GenImage1Extern(const char* Type, Hlong Width, Hlong Height, void* PixelPointer, void* ClearProc);

  // Create an image with a rectangular domain from a pointer on the pixels (with storage management).
  void GenImage1Rect(void* PixelPointer, Hlong Width, Hlong Height, Hlong VerticalPitch, Hlong HorizontalBitPitch, Hlong BitsPerPixel, const HString& DoCopy, void* ClearProc);

  // Create an image with a rectangular domain from a pointer on the pixels (with storage management).
  void GenImage1Rect(void* PixelPointer, Hlong Width, Hlong Height, Hlong VerticalPitch, Hlong HorizontalBitPitch, Hlong BitsPerPixel, const char* DoCopy, void* ClearProc);

  // Access to the image data pointer and the image data inside the smallest rectangle of the domain of the input image.
  void* GetImagePointer1Rect(Hlong* Width, Hlong* Height, Hlong* VerticalPitch, Hlong* HorizontalBitPitch, Hlong* BitsPerPixel) const;

  // Access the pointers of a colored image.
  void GetImagePointer3(HTuple* PointerRed, HTuple* PointerGreen, HTuple* PointerBlue, HTuple* Type, HTuple* Width, HTuple* Height) const;

  // Access the pointers of a colored image.
  void GetImagePointer3(void** PointerRed, void** PointerGreen, void** PointerBlue, HString* Type, Hlong* Width, Hlong* Height) const;

  // Access the pointer of a channel.
  HTuple GetImagePointer1(HTuple* Type, HTuple* Width, HTuple* Height) const;

  // Access the pointer of a channel.
  void* GetImagePointer1(HString* Type, Hlong* Width, Hlong* Height) const;

  // Return the type of an image.
  HTuple GetImageType() const;

  // Return the size of an image.
  void GetImageSize(HTuple* Width, HTuple* Height) const;

  // Return the size of an image.
  void GetImageSize(Hlong* Width, Hlong* Height) const;

  // Request time at which the image was created.
  Hlong GetImageTime(Hlong* Second, Hlong* Minute, Hlong* Hour, Hlong* Day, Hlong* YDay, Hlong* Month, Hlong* Year) const;

  // Return gray values of an image at the positions given by tuples of rows and columns.
  HTuple GetGrayvalInterpolated(const HTuple& Row, const HTuple& Column, const HString& Interpolation) const;

  // Return gray values of an image at the positions given by tuples of rows and columns.
  double GetGrayvalInterpolated(double Row, double Column, const HString& Interpolation) const;

  // Return gray values of an image at the positions given by tuples of rows and columns.
  double GetGrayvalInterpolated(double Row, double Column, const char* Interpolation) const;

  // Access the gray values of an image object.
  HTuple GetGrayval(const HTuple& Row, const HTuple& Column) const;

  // Access the gray values of an image object.
  double GetGrayval(Hlong Row, Hlong Column) const;

  // Verification of a pattern using an OCV tool.
  HTuple DoOcvSimple(const HOCV& OCVHandle, const HTuple& PatternName, const HString& AdaptPos, const HString& AdaptSize, const HString& AdaptAngle, const HString& AdaptGray, double Threshold) const;

  // Verification of a pattern using an OCV tool.
  double DoOcvSimple(const HOCV& OCVHandle, const HString& PatternName, const HString& AdaptPos, const HString& AdaptSize, const HString& AdaptAngle, const HString& AdaptGray, double Threshold) const;

  // Verification of a pattern using an OCV tool.
  double DoOcvSimple(const HOCV& OCVHandle, const char* PatternName, const char* AdaptPos, const char* AdaptSize, const char* AdaptAngle, const char* AdaptGray, double Threshold) const;

  // Training of an OCV tool.
  void TraindOcvProj(const HOCV& OCVHandle, const HTuple& Name, const HString& Mode) const;

  // Training of an OCV tool.
  void TraindOcvProj(const HOCV& OCVHandle, const HString& Name, const HString& Mode) const;

  // Training of an OCV tool.
  void TraindOcvProj(const HOCV& OCVHandle, const char* Name, const char* Mode) const;

  // Compute the features of a character.
  HTuple GetFeaturesOcrClassKnn(const HOCRKnn& OCRHandle, const HString& Transform) const;

  // Compute the features of a character.
  HTuple GetFeaturesOcrClassKnn(const HOCRKnn& OCRHandle, const char* Transform) const;

  // Compute the features of a character.
  HTuple GetFeaturesOcrClassSvm(const HOCRSvm& OCRHandle, const HString& Transform) const;

  // Compute the features of a character.
  HTuple GetFeaturesOcrClassSvm(const HOCRSvm& OCRHandle, const char* Transform) const;

  // Compute the features of a character.
  HTuple GetFeaturesOcrClassMlp(const HOCRMlp& OCRHandle, const HString& Transform) const;

  // Compute the features of a character.
  HTuple GetFeaturesOcrClassMlp(const HOCRMlp& OCRHandle, const char* Transform) const;

  // Cut out an image area relative to the domain.
  HImage CropDomainRel(Hlong Top, Hlong Left, Hlong Bottom, Hlong Right) const;

  // Access the features which correspond to a character.
  HTuple OcrGetFeatures(const HOCRBox& OcrHandle) const;

  // Write characters into a training file.
  void WriteOcrTrainfImage(const HTuple& Class, const HString& TrainingFile) const;

  // Write characters into a training file.
  void WriteOcrTrainfImage(const HString& Class, const HString& TrainingFile) const;

  // Write characters into a training file.
  void WriteOcrTrainfImage(const char* Class, const char* TrainingFile) const;

  // Read training specific characters from files and convert to images.
  HTuple ReadOcrTrainfSelect(const HTuple& TrainingFile, const HTuple& SearchNames);

  // Read training specific characters from files and convert to images.
  HString ReadOcrTrainfSelect(const HString& TrainingFile, const HString& SearchNames);

  // Read training specific characters from files and convert to images.
  HString ReadOcrTrainfSelect(const char* TrainingFile, const char* SearchNames);

  // Read training characters from files and convert to images.
  HTuple ReadOcrTrainf(const HTuple& TrainingFile);

  // Read training characters from files and convert to images.
  HTuple ReadOcrTrainf(const HString& TrainingFile);

  // Read training characters from files and convert to images.
  HTuple ReadOcrTrainf(const char* TrainingFile);

  // Perform a gray value bottom hat transformation on an image.
  HImage GrayBothat(const HImage& SE) const;

  // Perform a gray value top hat transformation on an image.
  HImage GrayTophat(const HImage& SE) const;

  // Perform a gray value closing on an image.
  HImage GrayClosing(const HImage& SE) const;

  // Perform a gray value opening on an image.
  HImage GrayOpening(const HImage& SE) const;

  // Perform a gray value dilation on an image.
  HImage GrayDilation(const HImage& SE) const;

  // Perform a gray value erosion on an image.
  HImage GrayErosion(const HImage& SE) const;

  // Load a structuring element for gray morphology.
  void ReadGraySe(const HString& FileName);

  // Load a structuring element for gray morphology.
  void ReadGraySe(const char* FileName);

  // Generate ellipsoidal structuring elements for gray morphology.
  void GenDiscSe(const HString& Type, Hlong Width, Hlong Height, const HTuple& Smax);

  // Generate ellipsoidal structuring elements for gray morphology.
  void GenDiscSe(const HString& Type, Hlong Width, Hlong Height, double Smax);

  // Generate ellipsoidal structuring elements for gray morphology.
  void GenDiscSe(const char* Type, Hlong Width, Hlong Height, double Smax);

  // Extracting points with a particular gray value along a rectangle or an annular arc.
  void MeasureThresh(const HMeasure& MeasureHandle, double Sigma, double Threshold, const HString& Select, HTuple* RowThresh, HTuple* ColumnThresh, HTuple* Distance) const;

  // Extracting points with a particular gray value along a rectangle or an annular arc.
  void MeasureThresh(const HMeasure& MeasureHandle, double Sigma, double Threshold, const char* Select, HTuple* RowThresh, HTuple* ColumnThresh, HTuple* Distance) const;

  // Extract a gray value profile perpendicular to a rectangle or annular arc.
  HTuple MeasureProjection(const HMeasure& MeasureHandle) const;

  // Extract straight edge pairs perpendicular to a rectangle or an annular arc.
  void FuzzyMeasurePairing(const HMeasure& MeasureHandle, double Sigma, double AmpThresh, double FuzzyThresh, const HString& Transition, const HString& Pairing, Hlong NumPairs, HTuple* RowEdgeFirst, HTuple* ColumnEdgeFirst, HTuple* AmplitudeFirst, HTuple* RowEdgeSecond, HTuple* ColumnEdgeSecond, HTuple* AmplitudeSecond, HTuple* RowPairCenter, HTuple* ColumnPairCenter, HTuple* FuzzyScore, HTuple* IntraDistance) const;

  // Extract straight edge pairs perpendicular to a rectangle or an annular arc.
  void FuzzyMeasurePairing(const HMeasure& MeasureHandle, double Sigma, double AmpThresh, double FuzzyThresh, const char* Transition, const char* Pairing, Hlong NumPairs, HTuple* RowEdgeFirst, HTuple* ColumnEdgeFirst, HTuple* AmplitudeFirst, HTuple* RowEdgeSecond, HTuple* ColumnEdgeSecond, HTuple* AmplitudeSecond, HTuple* RowPairCenter, HTuple* ColumnPairCenter, HTuple* FuzzyScore, HTuple* IntraDistance) const;

  // Extract straight edge pairs perpendicular to a rectangle or an annular arc.
  void FuzzyMeasurePairs(const HMeasure& MeasureHandle, double Sigma, double AmpThresh, double FuzzyThresh, const HString& Transition, HTuple* RowEdgeFirst, HTuple* ColumnEdgeFirst, HTuple* AmplitudeFirst, HTuple* RowEdgeSecond, HTuple* ColumnEdgeSecond, HTuple* AmplitudeSecond, HTuple* RowEdgeCenter, HTuple* ColumnEdgeCenter, HTuple* FuzzyScore, HTuple* IntraDistance, HTuple* InterDistance) const;

  // Extract straight edge pairs perpendicular to a rectangle or an annular arc.
  void FuzzyMeasurePairs(const HMeasure& MeasureHandle, double Sigma, double AmpThresh, double FuzzyThresh, const char* Transition, HTuple* RowEdgeFirst, HTuple* ColumnEdgeFirst, HTuple* AmplitudeFirst, HTuple* RowEdgeSecond, HTuple* ColumnEdgeSecond, HTuple* AmplitudeSecond, HTuple* RowEdgeCenter, HTuple* ColumnEdgeCenter, HTuple* FuzzyScore, HTuple* IntraDistance, HTuple* InterDistance) const;

  // Extract straight edges perpendicular to a rectangle or an annular arc.
  void FuzzyMeasurePos(const HMeasure& MeasureHandle, double Sigma, double AmpThresh, double FuzzyThresh, const HString& Transition, HTuple* RowEdge, HTuple* ColumnEdge, HTuple* Amplitude, HTuple* FuzzyScore, HTuple* Distance) const;

  // Extract straight edges perpendicular to a rectangle or an annular arc.
  void FuzzyMeasurePos(const HMeasure& MeasureHandle, double Sigma, double AmpThresh, double FuzzyThresh, const char* Transition, HTuple* RowEdge, HTuple* ColumnEdge, HTuple* Amplitude, HTuple* FuzzyScore, HTuple* Distance) const;

  // Extract straight edge pairs perpendicular to a rectangle or annular arc.
  void MeasurePairs(const HMeasure& MeasureHandle, double Sigma, double Threshold, const HString& Transition, const HString& Select, HTuple* RowEdgeFirst, HTuple* ColumnEdgeFirst, HTuple* AmplitudeFirst, HTuple* RowEdgeSecond, HTuple* ColumnEdgeSecond, HTuple* AmplitudeSecond, HTuple* IntraDistance, HTuple* InterDistance) const;

  // Extract straight edge pairs perpendicular to a rectangle or annular arc.
  void MeasurePairs(const HMeasure& MeasureHandle, double Sigma, double Threshold, const char* Transition, const char* Select, HTuple* RowEdgeFirst, HTuple* ColumnEdgeFirst, HTuple* AmplitudeFirst, HTuple* RowEdgeSecond, HTuple* ColumnEdgeSecond, HTuple* AmplitudeSecond, HTuple* IntraDistance, HTuple* InterDistance) const;

  // Extract straight edges perpendicular to a rectangle or annular arc.
  void MeasurePos(const HMeasure& MeasureHandle, double Sigma, double Threshold, const HString& Transition, const HString& Select, HTuple* RowEdge, HTuple* ColumnEdge, HTuple* Amplitude, HTuple* Distance) const;

  // Extract straight edges perpendicular to a rectangle or annular arc.
  void MeasurePos(const HMeasure& MeasureHandle, double Sigma, double Threshold, const char* Transition, const char* Select, HTuple* RowEdge, HTuple* ColumnEdge, HTuple* Amplitude, HTuple* Distance) const;

  // Identify objects with a sample identifier. 
  HTuple ApplySampleIdentifier(const HSampleIdentifier& SampleIdentifier, Hlong NumResults, double RatingThreshold, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* Rating) const;

  // Identify objects with a sample identifier. 
  Hlong ApplySampleIdentifier(const HSampleIdentifier& SampleIdentifier, Hlong NumResults, double RatingThreshold, const HTuple& GenParamName, const HTuple& GenParamValue, double* Rating) const;

  // Add training data to an existing sample identifier. 
  Hlong AddSampleIdentifierTrainingData(const HSampleIdentifier& SampleIdentifier, const HTuple& ObjectIdx, const HTuple& GenParamName, const HTuple& GenParamValue) const;

  // Add training data to an existing sample identifier. 
  Hlong AddSampleIdentifierTrainingData(const HSampleIdentifier& SampleIdentifier, Hlong ObjectIdx, const HTuple& GenParamName, const HTuple& GenParamValue) const;

  // Add preparation data to an existing sample identifier. 
  Hlong AddSampleIdentifierPreparationData(const HSampleIdentifier& SampleIdentifier, const HTuple& ObjectIdx, const HTuple& GenParamName, const HTuple& GenParamValue) const;

  // Add preparation data to an existing sample identifier. 
  Hlong AddSampleIdentifierPreparationData(const HSampleIdentifier& SampleIdentifier, Hlong ObjectIdx, const HTuple& GenParamName, const HTuple& GenParamValue) const;

  // Determine the parameters of a shape model.
  HTuple DetermineShapeModelParams(const HTuple& NumLevels, double AngleStart, double AngleExtent, const HTuple& ScaleMin, const HTuple& ScaleMax, const HString& Optimization, const HString& Metric, const HTuple& Contrast, const HTuple& MinContrast, const HTuple& Parameters, HTuple* ParameterValue) const;

  // Determine the parameters of a shape model.
  HTuple DetermineShapeModelParams(Hlong NumLevels, double AngleStart, double AngleExtent, double ScaleMin, double ScaleMax, const HString& Optimization, const HString& Metric, Hlong Contrast, Hlong MinContrast, const HString& Parameters, HTuple* ParameterValue) const;

  // Determine the parameters of a shape model.
  HTuple DetermineShapeModelParams(Hlong NumLevels, double AngleStart, double AngleExtent, double ScaleMin, double ScaleMax, const char* Optimization, const char* Metric, Hlong Contrast, Hlong MinContrast, const char* Parameters, HTuple* ParameterValue) const;

  // Find the best matches of multiple anisotropic scale invariant shape models.
  void FindAnisoShapeModels(const HShapeModelArray& ModelIDs, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& ScaleRMin, const HTuple& ScaleRMax, const HTuple& ScaleCMin, const HTuple& ScaleCMax, const HTuple& MinScore, const HTuple& NumMatches, const HTuple& MaxOverlap, const HTuple& SubPixel, const HTuple& NumLevels, const HTuple& Greediness, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* ScaleR, HTuple* ScaleC, HTuple* Score, HTuple* Model) const;

  // Find the best matches of multiple anisotropic scale invariant shape models.
  void FindAnisoShapeModels(const HShapeModel& ModelIDs, double AngleStart, double AngleExtent, double ScaleRMin, double ScaleRMax, double ScaleCMin, double ScaleCMax, double MinScore, Hlong NumMatches, double MaxOverlap, const HString& SubPixel, Hlong NumLevels, double Greediness, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* ScaleR, HTuple* ScaleC, HTuple* Score, HTuple* Model) const;

  // Find the best matches of multiple anisotropic scale invariant shape models.
  void FindAnisoShapeModels(const HShapeModel& ModelIDs, double AngleStart, double AngleExtent, double ScaleRMin, double ScaleRMax, double ScaleCMin, double ScaleCMax, double MinScore, Hlong NumMatches, double MaxOverlap, const char* SubPixel, Hlong NumLevels, double Greediness, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* ScaleR, HTuple* ScaleC, HTuple* Score, HTuple* Model) const;

  // Find the best matches of multiple scale invariant shape models.
  void FindScaledShapeModels(const HShapeModelArray& ModelIDs, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& ScaleMin, const HTuple& ScaleMax, const HTuple& MinScore, const HTuple& NumMatches, const HTuple& MaxOverlap, const HTuple& SubPixel, const HTuple& NumLevels, const HTuple& Greediness, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* Scale, HTuple* Score, HTuple* Model) const;

  // Find the best matches of multiple scale invariant shape models.
  void FindScaledShapeModels(const HShapeModel& ModelIDs, double AngleStart, double AngleExtent, double ScaleMin, double ScaleMax, double MinScore, Hlong NumMatches, double MaxOverlap, const HString& SubPixel, Hlong NumLevels, double Greediness, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* Scale, HTuple* Score, HTuple* Model) const;

  // Find the best matches of multiple scale invariant shape models.
  void FindScaledShapeModels(const HShapeModel& ModelIDs, double AngleStart, double AngleExtent, double ScaleMin, double ScaleMax, double MinScore, Hlong NumMatches, double MaxOverlap, const char* SubPixel, Hlong NumLevels, double Greediness, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* Scale, HTuple* Score, HTuple* Model) const;

  // Find the best matches of multiple shape models.
  void FindShapeModels(const HShapeModelArray& ModelIDs, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& MinScore, const HTuple& NumMatches, const HTuple& MaxOverlap, const HTuple& SubPixel, const HTuple& NumLevels, const HTuple& Greediness, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* Score, HTuple* Model) const;

  // Find the best matches of multiple shape models.
  void FindShapeModels(const HShapeModel& ModelIDs, double AngleStart, double AngleExtent, double MinScore, Hlong NumMatches, double MaxOverlap, const HString& SubPixel, Hlong NumLevels, double Greediness, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* Score, HTuple* Model) const;

  // Find the best matches of multiple shape models.
  void FindShapeModels(const HShapeModel& ModelIDs, double AngleStart, double AngleExtent, double MinScore, Hlong NumMatches, double MaxOverlap, const char* SubPixel, Hlong NumLevels, double Greediness, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* Score, HTuple* Model) const;

  // Find the best matches of an anisotropic scale invariant shape model in an image.
  void FindAnisoShapeModel(const HShapeModel& ModelID, double AngleStart, double AngleExtent, double ScaleRMin, double ScaleRMax, double ScaleCMin, double ScaleCMax, double MinScore, Hlong NumMatches, double MaxOverlap, const HTuple& SubPixel, const HTuple& NumLevels, double Greediness, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* ScaleR, HTuple* ScaleC, HTuple* Score) const;

  // Find the best matches of an anisotropic scale invariant shape model in an image.
  void FindAnisoShapeModel(const HShapeModel& ModelID, double AngleStart, double AngleExtent, double ScaleRMin, double ScaleRMax, double ScaleCMin, double ScaleCMax, double MinScore, Hlong NumMatches, double MaxOverlap, const HString& SubPixel, Hlong NumLevels, double Greediness, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* ScaleR, HTuple* ScaleC, HTuple* Score) const;

  // Find the best matches of an anisotropic scale invariant shape model in an image.
  void FindAnisoShapeModel(const HShapeModel& ModelID, double AngleStart, double AngleExtent, double ScaleRMin, double ScaleRMax, double ScaleCMin, double ScaleCMax, double MinScore, Hlong NumMatches, double MaxOverlap, const char* SubPixel, Hlong NumLevels, double Greediness, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* ScaleR, HTuple* ScaleC, HTuple* Score) const;

  // Find the best matches of a scale invariant shape model in an image.
  void FindScaledShapeModel(const HShapeModel& ModelID, double AngleStart, double AngleExtent, double ScaleMin, double ScaleMax, double MinScore, Hlong NumMatches, double MaxOverlap, const HTuple& SubPixel, const HTuple& NumLevels, double Greediness, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* Scale, HTuple* Score) const;

  // Find the best matches of a scale invariant shape model in an image.
  void FindScaledShapeModel(const HShapeModel& ModelID, double AngleStart, double AngleExtent, double ScaleMin, double ScaleMax, double MinScore, Hlong NumMatches, double MaxOverlap, const HString& SubPixel, Hlong NumLevels, double Greediness, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* Scale, HTuple* Score) const;

  // Find the best matches of a scale invariant shape model in an image.
  void FindScaledShapeModel(const HShapeModel& ModelID, double AngleStart, double AngleExtent, double ScaleMin, double ScaleMax, double MinScore, Hlong NumMatches, double MaxOverlap, const char* SubPixel, Hlong NumLevels, double Greediness, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* Scale, HTuple* Score) const;

  // Find the best matches of a shape model in an image.
  void FindShapeModel(const HShapeModel& ModelID, double AngleStart, double AngleExtent, double MinScore, Hlong NumMatches, double MaxOverlap, const HTuple& SubPixel, const HTuple& NumLevels, double Greediness, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* Score) const;

  // Find the best matches of a shape model in an image.
  void FindShapeModel(const HShapeModel& ModelID, double AngleStart, double AngleExtent, double MinScore, Hlong NumMatches, double MaxOverlap, const HString& SubPixel, Hlong NumLevels, double Greediness, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* Score) const;

  // Find the best matches of a shape model in an image.
  void FindShapeModel(const HShapeModel& ModelID, double AngleStart, double AngleExtent, double MinScore, Hlong NumMatches, double MaxOverlap, const char* SubPixel, Hlong NumLevels, double Greediness, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* Score) const;

  // Set the metric of a shape model that was created from XLD contours.
  void SetShapeModelMetric(const HShapeModel& ModelID, const HHomMat2D& HomMat2D, const HString& Metric) const;

  // Set the metric of a shape model that was created from XLD contours.
  void SetShapeModelMetric(const HShapeModel& ModelID, const HHomMat2D& HomMat2D, const char* Metric) const;

  // Set selected parameters of the shape model.
  static void SetShapeModelParam(const HShapeModel& ModelID, const HTuple& GenParamNames, const HTuple& GenParamValues);

  // Prepare a shape model for anisotropic scale invariant matching.
  HShapeModel CreateAnisoShapeModel(const HTuple& NumLevels, double AngleStart, double AngleExtent, const HTuple& AngleStep, double ScaleRMin, double ScaleRMax, const HTuple& ScaleRStep, double ScaleCMin, double ScaleCMax, const HTuple& ScaleCStep, const HTuple& Optimization, const HString& Metric, const HTuple& Contrast, const HTuple& MinContrast) const;

  // Prepare a shape model for anisotropic scale invariant matching.
  HShapeModel CreateAnisoShapeModel(Hlong NumLevels, double AngleStart, double AngleExtent, double AngleStep, double ScaleRMin, double ScaleRMax, double ScaleRStep, double ScaleCMin, double ScaleCMax, double ScaleCStep, const HString& Optimization, const HString& Metric, Hlong Contrast, Hlong MinContrast) const;

  // Prepare a shape model for anisotropic scale invariant matching.
  HShapeModel CreateAnisoShapeModel(Hlong NumLevels, double AngleStart, double AngleExtent, double AngleStep, double ScaleRMin, double ScaleRMax, double ScaleRStep, double ScaleCMin, double ScaleCMax, double ScaleCStep, const char* Optimization, const char* Metric, Hlong Contrast, Hlong MinContrast) const;

  // Prepare a shape model for scale invariant matching.
  HShapeModel CreateScaledShapeModel(const HTuple& NumLevels, double AngleStart, double AngleExtent, const HTuple& AngleStep, double ScaleMin, double ScaleMax, const HTuple& ScaleStep, const HTuple& Optimization, const HString& Metric, const HTuple& Contrast, const HTuple& MinContrast) const;

  // Prepare a shape model for scale invariant matching.
  HShapeModel CreateScaledShapeModel(Hlong NumLevels, double AngleStart, double AngleExtent, double AngleStep, double ScaleMin, double ScaleMax, double ScaleStep, const HString& Optimization, const HString& Metric, Hlong Contrast, Hlong MinContrast) const;

  // Prepare a shape model for scale invariant matching.
  HShapeModel CreateScaledShapeModel(Hlong NumLevels, double AngleStart, double AngleExtent, double AngleStep, double ScaleMin, double ScaleMax, double ScaleStep, const char* Optimization, const char* Metric, Hlong Contrast, Hlong MinContrast) const;

  // Prepare a shape model for matching.
  HShapeModel CreateShapeModel(const HTuple& NumLevels, double AngleStart, double AngleExtent, const HTuple& AngleStep, const HTuple& Optimization, const HString& Metric, const HTuple& Contrast, const HTuple& MinContrast) const;

  // Prepare a shape model for matching.
  HShapeModel CreateShapeModel(Hlong NumLevels, double AngleStart, double AngleExtent, double AngleStep, const HString& Optimization, const HString& Metric, Hlong Contrast, Hlong MinContrast) const;

  // Prepare a shape model for matching.
  HShapeModel CreateShapeModel(Hlong NumLevels, double AngleStart, double AngleExtent, double AngleStep, const char* Optimization, const char* Metric, Hlong Contrast, Hlong MinContrast) const;

  // Create the representation of a shape model.
  HImage InspectShapeModel(HRegion* ModelRegions, Hlong NumLevels, const HTuple& Contrast) const;

  // Create the representation of a shape model.
  HImage InspectShapeModel(HRegion* ModelRegions, Hlong NumLevels, Hlong Contrast) const;

  // Find the best matches of a calibrated descriptor model in an image and return their 3D pose.
  HPoseArray FindCalibDescriptorModel(const HDescriptorModel& ModelID, const HTuple& DetectorParamName, const HTuple& DetectorParamValue, const HTuple& DescriptorParamName, const HTuple& DescriptorParamValue, const HTuple& MinScore, Hlong NumMatches, const HTuple& CamParam, const HTuple& ScoreType, HTuple* Score) const;

  // Find the best matches of a calibrated descriptor model in an image and return their 3D pose.
  HPose FindCalibDescriptorModel(const HDescriptorModel& ModelID, const HTuple& DetectorParamName, const HTuple& DetectorParamValue, const HTuple& DescriptorParamName, const HTuple& DescriptorParamValue, double MinScore, Hlong NumMatches, const HTuple& CamParam, const HString& ScoreType, double* Score) const;

  // Find the best matches of a calibrated descriptor model in an image and return their 3D pose.
  HPose FindCalibDescriptorModel(const HDescriptorModel& ModelID, const HTuple& DetectorParamName, const HTuple& DetectorParamValue, const HTuple& DescriptorParamName, const HTuple& DescriptorParamValue, double MinScore, Hlong NumMatches, const HTuple& CamParam, const char* ScoreType, double* Score) const;

  // Find the best matches of a descriptor model in an image.
  HHomMat2DArray FindUncalibDescriptorModel(const HDescriptorModel& ModelID, const HTuple& DetectorParamName, const HTuple& DetectorParamValue, const HTuple& DescriptorParamName, const HTuple& DescriptorParamValue, const HTuple& MinScore, Hlong NumMatches, const HTuple& ScoreType, HTuple* Score) const;

  // Find the best matches of a descriptor model in an image.
  HHomMat2D FindUncalibDescriptorModel(const HDescriptorModel& ModelID, const HTuple& DetectorParamName, const HTuple& DetectorParamValue, const HTuple& DescriptorParamName, const HTuple& DescriptorParamValue, double MinScore, Hlong NumMatches, const HString& ScoreType, double* Score) const;

  // Find the best matches of a descriptor model in an image.
  HHomMat2D FindUncalibDescriptorModel(const HDescriptorModel& ModelID, const HTuple& DetectorParamName, const HTuple& DetectorParamValue, const HTuple& DescriptorParamName, const HTuple& DescriptorParamValue, double MinScore, Hlong NumMatches, const char* ScoreType, double* Score) const;

  // Create a descriptor model for calibrated perspective matching.
  HDescriptorModel CreateCalibDescriptorModel(const HTuple& CamParam, const HPose& ReferencePose, const HString& DetectorType, const HTuple& DetectorParamName, const HTuple& DetectorParamValue, const HTuple& DescriptorParamName, const HTuple& DescriptorParamValue, Hlong Seed) const;

  // Create a descriptor model for calibrated perspective matching.
  HDescriptorModel CreateCalibDescriptorModel(const HTuple& CamParam, const HPose& ReferencePose, const char* DetectorType, const HTuple& DetectorParamName, const HTuple& DetectorParamValue, const HTuple& DescriptorParamName, const HTuple& DescriptorParamValue, Hlong Seed) const;

  // Prepare a descriptor model for interest point matching.
  HDescriptorModel CreateUncalibDescriptorModel(const HString& DetectorType, const HTuple& DetectorParamName, const HTuple& DetectorParamValue, const HTuple& DescriptorParamName, const HTuple& DescriptorParamValue, Hlong Seed) const;

  // Prepare a descriptor model for interest point matching.
  HDescriptorModel CreateUncalibDescriptorModel(const char* DetectorType, const HTuple& DetectorParamName, const HTuple& DetectorParamValue, const HTuple& DescriptorParamName, const HTuple& DescriptorParamValue, Hlong Seed) const;

  // Determine the parameters of a deformable model.
  HTuple DetermineDeformableModelParams(const HTuple& NumLevels, double AngleStart, double AngleExtent, const HTuple& ScaleMin, const HTuple& ScaleMax, const HString& Optimization, const HString& Metric, const HTuple& Contrast, const HTuple& MinContrast, const HTuple& ParamName, const HTuple& ParamValue, const HTuple& Parameters, HTuple* ParameterValue) const;

  // Determine the parameters of a deformable model.
  HTuple DetermineDeformableModelParams(Hlong NumLevels, double AngleStart, double AngleExtent, double ScaleMin, double ScaleMax, const HString& Optimization, const HString& Metric, Hlong Contrast, Hlong MinContrast, const HTuple& ParamName, const HTuple& ParamValue, const HString& Parameters, HTuple* ParameterValue) const;

  // Determine the parameters of a deformable model.
  HTuple DetermineDeformableModelParams(Hlong NumLevels, double AngleStart, double AngleExtent, double ScaleMin, double ScaleMax, const char* Optimization, const char* Metric, Hlong Contrast, Hlong MinContrast, const HTuple& ParamName, const HTuple& ParamValue, const char* Parameters, HTuple* ParameterValue) const;

  // Find the best matches of a local deformable model in an image.
  HImage FindLocalDeformableModel(HImage* VectorField, HXLDCont* DeformedContours, const HDeformableModel& ModelID, double AngleStart, double AngleExtent, double ScaleRMin, double ScaleRMax, double ScaleCMin, double ScaleCMax, double MinScore, Hlong NumMatches, double MaxOverlap, const HTuple& NumLevels, double Greediness, const HTuple& ResultType, const HTuple& ParamName, const HTuple& ParamValue, HTuple* Score, HTuple* Row, HTuple* Column) const;

  // Find the best matches of a local deformable model in an image.
  HImage FindLocalDeformableModel(HImage* VectorField, HXLDCont* DeformedContours, const HDeformableModel& ModelID, double AngleStart, double AngleExtent, double ScaleRMin, double ScaleRMax, double ScaleCMin, double ScaleCMax, double MinScore, Hlong NumMatches, double MaxOverlap, Hlong NumLevels, double Greediness, const HTuple& ResultType, const HTuple& ParamName, const HTuple& ParamValue, HTuple* Score, HTuple* Row, HTuple* Column) const;

  // Find the best matches of a calibrated deformable model in an image and return their 3D pose.
  HPoseArray FindPlanarCalibDeformableModel(const HDeformableModel& ModelID, double AngleStart, double AngleExtent, double ScaleRMin, double ScaleRMax, double ScaleCMin, double ScaleCMax, double MinScore, Hlong NumMatches, double MaxOverlap, const HTuple& NumLevels, double Greediness, const HTuple& ParamName, const HTuple& ParamValue, HTuple* CovPose, HTuple* Score) const;

  // Find the best matches of a calibrated deformable model in an image and return their 3D pose.
  HPose FindPlanarCalibDeformableModel(const HDeformableModel& ModelID, double AngleStart, double AngleExtent, double ScaleRMin, double ScaleRMax, double ScaleCMin, double ScaleCMax, double MinScore, Hlong NumMatches, double MaxOverlap, Hlong NumLevels, double Greediness, const HTuple& ParamName, const HTuple& ParamValue, HTuple* CovPose, HTuple* Score) const;

  // Find the best matches of a planar projective invariant deformable model in an image.
  HHomMat2DArray FindPlanarUncalibDeformableModel(const HDeformableModel& ModelID, double AngleStart, double AngleExtent, double ScaleRMin, double ScaleRMax, double ScaleCMin, double ScaleCMax, double MinScore, Hlong NumMatches, double MaxOverlap, const HTuple& NumLevels, double Greediness, const HTuple& ParamName, const HTuple& ParamValue, HTuple* Score) const;

  // Find the best matches of a planar projective invariant deformable model in an image.
  HHomMat2D FindPlanarUncalibDeformableModel(const HDeformableModel& ModelID, double AngleStart, double AngleExtent, double ScaleRMin, double ScaleRMax, double ScaleCMin, double ScaleCMax, double MinScore, Hlong NumMatches, double MaxOverlap, Hlong NumLevels, double Greediness, const HTuple& ParamName, const HTuple& ParamValue, HTuple* Score) const;

  // Set the metric of a local deformable model that was created from XLD contours.
  void SetLocalDeformableModelMetric(const HImage& VectorField, const HDeformableModel& ModelID, const HString& Metric) const;

  // Set the metric of a local deformable model that was created from XLD contours.
  void SetLocalDeformableModelMetric(const HImage& VectorField, const HDeformableModel& ModelID, const char* Metric) const;

  // Set the metric of a planar calibrated deformable model that was created from XLD contours.
  void SetPlanarCalibDeformableModelMetric(const HDeformableModel& ModelID, const HPose& Pose, const HString& Metric) const;

  // Set the metric of a planar calibrated deformable model that was created from XLD contours.
  void SetPlanarCalibDeformableModelMetric(const HDeformableModel& ModelID, const HPose& Pose, const char* Metric) const;

  // Set the metric of a planar uncalibrated deformable model that was created from XLD contours.
  void SetPlanarUncalibDeformableModelMetric(const HDeformableModel& ModelID, const HHomMat2D& HomMat2D, const HString& Metric) const;

  // Set the metric of a planar uncalibrated deformable model that was created from XLD contours.
  void SetPlanarUncalibDeformableModelMetric(const HDeformableModel& ModelID, const HHomMat2D& HomMat2D, const char* Metric) const;

  // Creates a deformable model for local, deformable matching.
  HDeformableModel CreateLocalDeformableModel(const HTuple& NumLevels, double AngleStart, double AngleExtent, const HTuple& AngleStep, double ScaleRMin, double ScaleRMax, const HTuple& ScaleRStep, double ScaleCMin, double ScaleCMax, const HTuple& ScaleCStep, const HTuple& Optimization, const HString& Metric, const HTuple& Contrast, const HTuple& MinContrast, const HTuple& ParamName, const HTuple& ParamValue) const;

  // Creates a deformable model for local, deformable matching.
  HDeformableModel CreateLocalDeformableModel(Hlong NumLevels, double AngleStart, double AngleExtent, double AngleStep, double ScaleRMin, double ScaleRMax, double ScaleRStep, double ScaleCMin, double ScaleCMax, double ScaleCStep, const HString& Optimization, const HString& Metric, const HTuple& Contrast, Hlong MinContrast, const HTuple& ParamName, const HTuple& ParamValue) const;

  // Creates a deformable model for local, deformable matching.
  HDeformableModel CreateLocalDeformableModel(Hlong NumLevels, double AngleStart, double AngleExtent, double AngleStep, double ScaleRMin, double ScaleRMax, double ScaleRStep, double ScaleCMin, double ScaleCMax, double ScaleCStep, const char* Optimization, const char* Metric, const HTuple& Contrast, Hlong MinContrast, const HTuple& ParamName, const HTuple& ParamValue) const;

  // Create a deformable model for calibrated perspective matching.
  HDeformableModel CreatePlanarCalibDeformableModel(const HTuple& CamParam, const HPose& ReferencePose, const HTuple& NumLevels, double AngleStart, double AngleExtent, const HTuple& AngleStep, double ScaleRMin, double ScaleRMax, const HTuple& ScaleRStep, double ScaleCMin, double ScaleCMax, const HTuple& ScaleCStep, const HTuple& Optimization, const HString& Metric, const HTuple& Contrast, const HTuple& MinContrast, const HTuple& ParamName, const HTuple& ParamValue) const;

  // Create a deformable model for calibrated perspective matching.
  HDeformableModel CreatePlanarCalibDeformableModel(const HTuple& CamParam, const HPose& ReferencePose, Hlong NumLevels, double AngleStart, double AngleExtent, double AngleStep, double ScaleRMin, double ScaleRMax, double ScaleRStep, double ScaleCMin, double ScaleCMax, double ScaleCStep, const HString& Optimization, const HString& Metric, const HTuple& Contrast, Hlong MinContrast, const HTuple& ParamName, const HTuple& ParamValue) const;

  // Create a deformable model for calibrated perspective matching.
  HDeformableModel CreatePlanarCalibDeformableModel(const HTuple& CamParam, const HPose& ReferencePose, Hlong NumLevels, double AngleStart, double AngleExtent, double AngleStep, double ScaleRMin, double ScaleRMax, double ScaleRStep, double ScaleCMin, double ScaleCMax, double ScaleCStep, const char* Optimization, const char* Metric, const HTuple& Contrast, Hlong MinContrast, const HTuple& ParamName, const HTuple& ParamValue) const;

  // Creates a deformable model for uncalibrated, perspective matching.
  HDeformableModel CreatePlanarUncalibDeformableModel(const HTuple& NumLevels, double AngleStart, double AngleExtent, const HTuple& AngleStep, double ScaleRMin, double ScaleRMax, const HTuple& ScaleRStep, double ScaleCMin, double ScaleCMax, const HTuple& ScaleCStep, const HTuple& Optimization, const HString& Metric, const HTuple& Contrast, const HTuple& MinContrast, const HTuple& ParamName, const HTuple& ParamValue) const;

  // Creates a deformable model for uncalibrated, perspective matching.
  HDeformableModel CreatePlanarUncalibDeformableModel(Hlong NumLevels, double AngleStart, double AngleExtent, double AngleStep, double ScaleRMin, double ScaleRMax, double ScaleRStep, double ScaleCMin, double ScaleCMax, double ScaleCStep, const HString& Optimization, const HString& Metric, const HTuple& Contrast, Hlong MinContrast, const HTuple& ParamName, const HTuple& ParamValue) const;

  // Creates a deformable model for uncalibrated, perspective matching.
  HDeformableModel CreatePlanarUncalibDeformableModel(Hlong NumLevels, double AngleStart, double AngleExtent, double AngleStep, double ScaleRMin, double ScaleRMax, double ScaleRStep, double ScaleCMin, double ScaleCMax, double ScaleCStep, const char* Optimization, const char* Metric, const HTuple& Contrast, Hlong MinContrast, const HTuple& ParamName, const HTuple& ParamValue) const;

  // Find the best matches of an NCC model in an image.
  void FindNccModel(const HNCCModel& ModelID, double AngleStart, double AngleExtent, double MinScore, Hlong NumMatches, double MaxOverlap, const HString& SubPixel, const HTuple& NumLevels, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* Score) const;

  // Find the best matches of an NCC model in an image.
  void FindNccModel(const HNCCModel& ModelID, double AngleStart, double AngleExtent, double MinScore, Hlong NumMatches, double MaxOverlap, const HString& SubPixel, Hlong NumLevels, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* Score) const;

  // Find the best matches of an NCC model in an image.
  void FindNccModel(const HNCCModel& ModelID, double AngleStart, double AngleExtent, double MinScore, Hlong NumMatches, double MaxOverlap, const char* SubPixel, Hlong NumLevels, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* Score) const;

  // Set selected parameters of the NCC model.
  static void SetNccModelParam(const HNCCModel& ModelID, const HTuple& GenParamNames, const HTuple& GenParamValues);

  // Prepare an NCC model for matching.
  HNCCModel CreateNccModel(const HTuple& NumLevels, double AngleStart, double AngleExtent, const HTuple& AngleStep, const HString& Metric) const;

  // Prepare an NCC model for matching.
  HNCCModel CreateNccModel(Hlong NumLevels, double AngleStart, double AngleExtent, double AngleStep, const HString& Metric) const;

  // Prepare an NCC model for matching.
  HNCCModel CreateNccModel(Hlong NumLevels, double AngleStart, double AngleExtent, double AngleStep, const char* Metric) const;

  // Find the best matches of a component model in an image.
  HTuple FindComponentModel(const HComponentModel& ComponentModelID, const HTuple& RootComponent, const HTuple& AngleStartRoot, const HTuple& AngleExtentRoot, double MinScore, Hlong NumMatches, double MaxOverlap, const HString& IfRootNotFound, const HString& IfComponentNotFound, const HString& PosePrediction, const HTuple& MinScoreComp, const HTuple& SubPixelComp, const HTuple& NumLevelsComp, const HTuple& GreedinessComp, HTuple* ModelEnd, HTuple* Score, HTuple* RowComp, HTuple* ColumnComp, HTuple* AngleComp, HTuple* ScoreComp, HTuple* ModelComp) const;

  // Find the best matches of a component model in an image.
  Hlong FindComponentModel(const HComponentModel& ComponentModelID, Hlong RootComponent, double AngleStartRoot, double AngleExtentRoot, double MinScore, Hlong NumMatches, double MaxOverlap, const HString& IfRootNotFound, const HString& IfComponentNotFound, const HString& PosePrediction, double MinScoreComp, const HString& SubPixelComp, Hlong NumLevelsComp, double GreedinessComp, Hlong* ModelEnd, double* Score, double* RowComp, double* ColumnComp, double* AngleComp, double* ScoreComp, Hlong* ModelComp) const;

  // Find the best matches of a component model in an image.
  Hlong FindComponentModel(const HComponentModel& ComponentModelID, Hlong RootComponent, double AngleStartRoot, double AngleExtentRoot, double MinScore, Hlong NumMatches, double MaxOverlap, const char* IfRootNotFound, const char* IfComponentNotFound, const char* PosePrediction, double MinScoreComp, const char* SubPixelComp, Hlong NumLevelsComp, double GreedinessComp, Hlong* ModelEnd, double* Score, double* RowComp, double* ColumnComp, double* AngleComp, double* ScoreComp, Hlong* ModelComp) const;

  // Prepare a component model for matching based on explicitly specified components and relations.
  HComponentModel CreateComponentModel(const HRegion& ComponentRegions, const HTuple& VariationRow, const HTuple& VariationColumn, const HTuple& VariationAngle, double AngleStart, double AngleExtent, const HTuple& ContrastLowComp, const HTuple& ContrastHighComp, const HTuple& MinSizeComp, const HTuple& MinContrastComp, const HTuple& MinScoreComp, const HTuple& NumLevelsComp, const HTuple& AngleStepComp, const HString& OptimizationComp, const HTuple& MetricComp, const HTuple& PregenerationComp, HTuple* RootRanking) const;

  // Prepare a component model for matching based on explicitly specified components and relations.
  HComponentModel CreateComponentModel(const HRegion& ComponentRegions, Hlong VariationRow, Hlong VariationColumn, double VariationAngle, double AngleStart, double AngleExtent, Hlong ContrastLowComp, Hlong ContrastHighComp, Hlong MinSizeComp, Hlong MinContrastComp, double MinScoreComp, Hlong NumLevelsComp, double AngleStepComp, const HString& OptimizationComp, const HString& MetricComp, const HString& PregenerationComp, Hlong* RootRanking) const;

  // Prepare a component model for matching based on explicitly specified components and relations.
  HComponentModel CreateComponentModel(const HRegion& ComponentRegions, Hlong VariationRow, Hlong VariationColumn, double VariationAngle, double AngleStart, double AngleExtent, Hlong ContrastLowComp, Hlong ContrastHighComp, Hlong MinSizeComp, Hlong MinContrastComp, double MinScoreComp, Hlong NumLevelsComp, double AngleStepComp, const char* OptimizationComp, const char* MetricComp, const char* PregenerationComp, Hlong* RootRanking) const;

  // Adopt new parameters that are used to create the model components into the training result.
  HRegion ClusterModelComponents(const HComponentTraining& ComponentTrainingID, const HString& AmbiguityCriterion, double MaxContourOverlap, double ClusterThreshold) const;

  // Adopt new parameters that are used to create the model components into the training result.
  HRegion ClusterModelComponents(const HComponentTraining& ComponentTrainingID, const char* AmbiguityCriterion, double MaxContourOverlap, double ClusterThreshold) const;

  // Train components and relations for the component-based matching.
  HRegion TrainModelComponents(const HRegion& InitialComponents, const HImage& TrainingImages, const HTuple& ContrastLow, const HTuple& ContrastHigh, const HTuple& MinSize, const HTuple& MinScore, const HTuple& SearchRowTol, const HTuple& SearchColumnTol, const HTuple& SearchAngleTol, const HString& TrainingEmphasis, const HString& AmbiguityCriterion, double MaxContourOverlap, double ClusterThreshold, HComponentTraining* ComponentTrainingID) const;

  // Train components and relations for the component-based matching.
  HRegion TrainModelComponents(const HRegion& InitialComponents, const HImage& TrainingImages, Hlong ContrastLow, Hlong ContrastHigh, Hlong MinSize, double MinScore, Hlong SearchRowTol, Hlong SearchColumnTol, double SearchAngleTol, const HString& TrainingEmphasis, const HString& AmbiguityCriterion, double MaxContourOverlap, double ClusterThreshold, HComponentTraining* ComponentTrainingID) const;

  // Train components and relations for the component-based matching.
  HRegion TrainModelComponents(const HRegion& InitialComponents, const HImage& TrainingImages, Hlong ContrastLow, Hlong ContrastHigh, Hlong MinSize, double MinScore, Hlong SearchRowTol, Hlong SearchColumnTol, double SearchAngleTol, const char* TrainingEmphasis, const char* AmbiguityCriterion, double MaxContourOverlap, double ClusterThreshold, HComponentTraining* ComponentTrainingID) const;

  // Extract the initial components of a component model.
  HRegion GenInitialComponents(const HTuple& ContrastLow, const HTuple& ContrastHigh, const HTuple& MinSize, const HString& Mode, const HTuple& GenericName, const HTuple& GenericValue) const;

  // Extract the initial components of a component model.
  HRegion GenInitialComponents(Hlong ContrastLow, Hlong ContrastHigh, Hlong MinSize, const HString& Mode, const HString& GenericName, double GenericValue) const;

  // Extract the initial components of a component model.
  HRegion GenInitialComponents(Hlong ContrastLow, Hlong ContrastHigh, Hlong MinSize, const char* Mode, const char* GenericName, double GenericValue) const;

  // Find the best matches of a 3D shape model in an image.
  HPoseArray FindShapeModel3d(const HShapeModel3D& ShapeModel3DID, double MinScore, double Greediness, const HTuple& NumLevels, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* CovPose, HTuple* Score) const;

  // Convert one-channel images into a multichannel image
  HImage ChannelsToImage() const;

  // Convert a multichannel image into One-channel images
  HImage ImageToChannels() const;

  // Convert 7 images into a seven-channel image.
  HImage Compose7(const HImage& Image2, const HImage& Image3, const HImage& Image4, const HImage& Image5, const HImage& Image6, const HImage& Image7) const;

  // Convert 6 images into a six-channel image.
  HImage Compose6(const HImage& Image2, const HImage& Image3, const HImage& Image4, const HImage& Image5, const HImage& Image6) const;

  // Convert 5 images into a five-channel image.
  HImage Compose5(const HImage& Image2, const HImage& Image3, const HImage& Image4, const HImage& Image5) const;

  // Convert 4 images into a four-channel image.
  HImage Compose4(const HImage& Image2, const HImage& Image3, const HImage& Image4) const;

  // Convert 3 images into a three-channel image.
  HImage Compose3(const HImage& Image2, const HImage& Image3) const;

  // Convert two images into a two-channel image.
  HImage Compose2(const HImage& Image2) const;

  // Convert a seven-channel image into seven images.
  HImage Decompose7(HImage* Image2, HImage* Image3, HImage* Image4, HImage* Image5, HImage* Image6, HImage* Image7) const;

  // Convert a six-channel image into six images.
  HImage Decompose6(HImage* Image2, HImage* Image3, HImage* Image4, HImage* Image5, HImage* Image6) const;

  // Convert a five-channel image into five images.
  HImage Decompose5(HImage* Image2, HImage* Image3, HImage* Image4, HImage* Image5) const;

  // Convert a four-channel image into four images.
  HImage Decompose4(HImage* Image2, HImage* Image3, HImage* Image4) const;

  // Convert a three-channel image into three images.
  HImage Decompose3(HImage* Image2, HImage* Image3) const;

  // Convert a two-channel image into two images.
  HImage Decompose2(HImage* Image2) const;

  // Count channels of image.
  HTuple CountChannels() const;

  // Append additional matrices (channels) to the image.
  HImage AppendChannel(const HImage& Image) const;

  // Access a channel of a multichannel image.
  HImage AccessChannel(Hlong Channel) const;

  // Tile multiple image objects into a large image with explicit positioning information.
  HImage TileImagesOffset(const HTuple& OffsetRow, const HTuple& OffsetCol, const HTuple& Row1, const HTuple& Col1, const HTuple& Row2, const HTuple& Col2, Hlong Width, Hlong Height) const;

  // Tile multiple image objects into a large image with explicit positioning information.
  HImage TileImagesOffset(Hlong OffsetRow, Hlong OffsetCol, Hlong Row1, Hlong Col1, Hlong Row2, Hlong Col2, Hlong Width, Hlong Height) const;

  // Tile multiple image objects into a large image.
  HImage TileImages(Hlong NumColumns, const HString& TileOrder) const;

  // Tile multiple image objects into a large image.
  HImage TileImages(Hlong NumColumns, const char* TileOrder) const;

  // Tile multiple images into a large image.
  HImage TileChannels(Hlong NumColumns, const HString& TileOrder) const;

  // Tile multiple images into a large image.
  HImage TileChannels(Hlong NumColumns, const char* TileOrder) const;

  // Cut out of defined gray values.
  HImage CropDomain() const;

  // Cut out one or more rectangular image areas.
  HImage CropRectangle1(const HTuple& Row1, const HTuple& Column1, const HTuple& Row2, const HTuple& Column2) const;

  // Cut out one or more rectangular image areas.
  HImage CropRectangle1(Hlong Row1, Hlong Column1, Hlong Row2, Hlong Column2) const;

  // Cut out one or more rectangular image areas.
  HImage CropPart(const HTuple& Row, const HTuple& Column, const HTuple& Width, const HTuple& Height) const;

  // Cut out one or more rectangular image areas.
  HImage CropPart(Hlong Row, Hlong Column, Hlong Width, Hlong Height) const;

  // Change image size.
  HImage ChangeFormat(Hlong Width, Hlong Height) const;

  // Change definition domain of an image.
  HImage ChangeDomain(const HRegion& NewDomain) const;

  // Reduce the domain of an image to a rectangle.
  HImage Rectangle1Domain(Hlong Row1, Hlong Column1, Hlong Row2, Hlong Column2) const;

  // Reduce the domain of an image.
  HImage ReduceDomain(const HRegion& Region) const;

  // Expand the domain of an image to maximum.
  HImage FullDomain() const;

  // Get the domain of an image.
  HRegion GetDomain() const;

  // Detect lines in edge images with the help of the Hough transform using local gradient direction and return them in normal form.
  HImage HoughLinesDir(HRegion* Lines, Hlong DirectionUncertainty, Hlong AngleResolution, const HString& Smoothing, Hlong FilterSize, Hlong Threshold, Hlong AngleGap, Hlong DistGap, const HString& GenLines, HTuple* Angle, HTuple* Dist) const;

  // Detect lines in edge images with the help of the Hough transform using local gradient direction and return them in normal form.
  HImage HoughLinesDir(HRegion* Lines, Hlong DirectionUncertainty, Hlong AngleResolution, const char* Smoothing, Hlong FilterSize, Hlong Threshold, Hlong AngleGap, Hlong DistGap, const char* GenLines, HTuple* Angle, HTuple* Dist) const;

  // Compute the Hough transform for lines using local gradient direction.
  HImage HoughLineTransDir(Hlong DirectionUncertainty, Hlong AngleResolution) const;

  // Segment the rectification grid region in the image.
  HRegion FindRectificationGrid(const HTuple& MinContrast, const HTuple& Radius) const;

  // Segment the rectification grid region in the image.
  HRegion FindRectificationGrid(double MinContrast, double Radius) const;

  // Establish connections between the grid points of the rectification grid.
  HXLD ConnectGridPoints(const HTuple& Row, const HTuple& Column, const HTuple& Sigma, const HTuple& MaxDist) const;

  // Establish connections between the grid points of the rectification grid.
  HXLD ConnectGridPoints(const HTuple& Row, const HTuple& Column, Hlong Sigma, double MaxDist) const;

  // Compute the mapping between the distorted image and the rectified image based upon the points of a regular grid.
  HImage GenGridRectificationMap(const HXLD& ConnectingLines, HXLD* Meshes, Hlong GridSpacing, const HTuple& Rotation, const HTuple& Row, const HTuple& Column, const HString& MapType) const;

  // Compute the mapping between the distorted image and the rectified image based upon the points of a regular grid.
  HImage GenGridRectificationMap(const HXLD& ConnectingLines, HXLD* Meshes, Hlong GridSpacing, const HString& Rotation, const HTuple& Row, const HTuple& Column, const HString& MapType) const;

  // Compute the mapping between the distorted image and the rectified image based upon the points of a regular grid.
  HImage GenGridRectificationMap(const HXLD& ConnectingLines, HXLD* Meshes, Hlong GridSpacing, const char* Rotation, const HTuple& Row, const HTuple& Column, const char* MapType) const;

  // Calculates image coordinates for a point in a 3D plot window.
  void UnprojectCoordinates(const HWindow& WindowHandle, const HTuple& Row, const HTuple& Column, Hlong* ImageRow, Hlong* ImageColumn, HTuple* Height) const;

  // Calculates image coordinates for a point in a 3D plot window.
  void UnprojectCoordinates(const HWindow& WindowHandle, double Row, double Column, Hlong* ImageRow, Hlong* ImageColumn, Hlong* Height) const;

  // Write the window content in an image object.
  void DumpWindowImage(const HWindow& WindowHandle);

  // Displays gray value images.
  void DispImage(const HWindow& WindowHandle) const;

  // Displays images with several channels.
  void DispChannel(const HWindow& WindowHandle, const HTuple& Channel) const;

  // Displays images with several channels.
  void DispChannel(const HWindow& WindowHandle, Hlong Channel) const;

  // Displays a color (RGB) image
  void DispColor(const HWindow& WindowHandle) const;

  // Visualize images using gnuplot.
  void GnuplotPlotImage(const HGnuplot& GnuplotFileID, Hlong SamplesX, Hlong SamplesY, const HTuple& ViewRotX, const HTuple& ViewRotZ, const HString& Hidden3D) const;

  // Visualize images using gnuplot.
  void GnuplotPlotImage(const HGnuplot& GnuplotFileID, Hlong SamplesX, Hlong SamplesY, double ViewRotX, double ViewRotZ, const HString& Hidden3D) const;

  // Visualize images using gnuplot.
  void GnuplotPlotImage(const HGnuplot& GnuplotFileID, Hlong SamplesX, Hlong SamplesY, double ViewRotX, double ViewRotZ, const char* Hidden3D) const;

  // Filter an image using a Laws texture filter.
  HImage TextureLaws(const HString& FilterTypes, Hlong Shift, Hlong FilterSize) const;

  // Filter an image using a Laws texture filter.
  HImage TextureLaws(const char* FilterTypes, Hlong Shift, Hlong FilterSize) const;

  // Calculate the standard deviation of gray values within rectangular windows.
  HImage DeviationImage(Hlong Width, Hlong Height) const;

  // Calculate the entropy of gray values within a rectangular window.
  HImage EntropyImage(Hlong Width, Hlong Height) const;

  // Perform an isotropic diffusion of an image.
  HImage IsotropicDiffusion(double Sigma, Hlong Iterations) const;

  // Perform an anisotropic diffusion of an image.
  HImage AnisotropicDiffusion(const HString& Mode, double Contrast, double Theta, Hlong Iterations) const;

  // Perform an anisotropic diffusion of an image.
  HImage AnisotropicDiffusion(const char* Mode, double Contrast, double Theta, Hlong Iterations) const;

  // Smooth an image using various filters.
  HImage SmoothImage(const HString& Filter, double Alpha) const;

  // Smooth an image using various filters.
  HImage SmoothImage(const char* Filter, double Alpha) const;

  // Non-linear smoothing with the sigma filter.
  HImage SigmaImage(Hlong MaskHeight, Hlong MaskWidth, Hlong Sigma) const;

  // Calculate the average of maximum and minimum inside any mask.
  HImage MidrangeImage(const HRegion& Mask, const HTuple& Margin) const;

  // Calculate the average of maximum and minimum inside any mask.
  HImage MidrangeImage(const HRegion& Mask, const HString& Margin) const;

  // Calculate the average of maximum and minimum inside any mask.
  HImage MidrangeImage(const HRegion& Mask, const char* Margin) const;

  // Smooth an image with an arbitrary rank mask.
  HImage TrimmedMean(const HRegion& Mask, Hlong Number, const HTuple& Margin) const;

  // Smooth an image with an arbitrary rank mask.
  HImage TrimmedMean(const HRegion& Mask, Hlong Number, const HString& Margin) const;

  // Smooth an image with an arbitrary rank mask.
  HImage TrimmedMean(const HRegion& Mask, Hlong Number, const char* Margin) const;

  // Separated median filtering with rectangle masks.
  HImage MedianSeparate(Hlong MaskWidth, Hlong MaskHeight, const HTuple& Margin) const;

  // Separated median filtering with rectangle masks.
  HImage MedianSeparate(Hlong MaskWidth, Hlong MaskHeight, const HString& Margin) const;

  // Separated median filtering with rectangle masks.
  HImage MedianSeparate(Hlong MaskWidth, Hlong MaskHeight, const char* Margin) const;

  // Compute a median filter with rectangular masks.
  HImage MedianRect(Hlong MaskWidth, Hlong MaskHeight) const;

  // Compute a median filter with various masks.
  HImage MedianImage(const HString& MaskType, Hlong Radius, const HTuple& Margin) const;

  // Compute a median filter with various masks.
  HImage MedianImage(const HString& MaskType, Hlong Radius, const HString& Margin) const;

  // Compute a median filter with various masks.
  HImage MedianImage(const char* MaskType, Hlong Radius, const char* Margin) const;

  // Weighted median filtering with different rank masks.
  HImage MedianWeighted(const HString& MaskType, Hlong MaskSize) const;

  // Weighted median filtering with different rank masks.
  HImage MedianWeighted(const char* MaskType, Hlong MaskSize) const;

  // Compute a rank filter with rectangular masks.
  HImage RankRect(Hlong MaskWidth, Hlong MaskHeight, Hlong Rank) const;

  // Compute a rank filter with arbitrary masks.
  HImage RankImage(const HRegion& Mask, Hlong Rank, const HTuple& Margin) const;

  // Compute a rank filter with arbitrary masks.
  HImage RankImage(const HRegion& Mask, Hlong Rank, const HString& Margin) const;

  // Compute a rank filter with arbitrary masks.
  HImage RankImage(const HRegion& Mask, Hlong Rank, const char* Margin) const;

  // Opening, Median and Closing with circle or rectangle mask.
  HImage DualRank(const HString& MaskType, Hlong Radius, Hlong ModePercent, const HTuple& Margin) const;

  // Opening, Median and Closing with circle or rectangle mask.
  HImage DualRank(const HString& MaskType, Hlong Radius, Hlong ModePercent, const HString& Margin) const;

  // Opening, Median and Closing with circle or rectangle mask.
  HImage DualRank(const char* MaskType, Hlong Radius, Hlong ModePercent, const char* Margin) const;

  // Smooth by averaging.
  HImage MeanImage(Hlong MaskWidth, Hlong MaskHeight) const;

  // Smooth an image using the binomial filter.
  HImage BinomialFilter(Hlong MaskWidth, Hlong MaskHeight) const;

  // Smooth an image using discrete Gaussian functions.
  HImage GaussImage(Hlong Size) const;

  // Smooth using discrete gauss functions.
  HImage GaussFilter(Hlong Size) const;

  // Smooth an image in the spatial domain to suppress noise.
  HImage EliminateMinMax(Hlong MaskWidth, Hlong MaskHeight, double Gap, Hlong Mode) const;

  // Smooth an image by edge-preserving anisotropic diffusion.
  HImage AnisotropeDiff(Hlong Percent, Hlong Mode, Hlong Iteration, Hlong NeighborhoodType) const;

  // Interpolate 2 video half images.
  HImage FillInterlace(const HString& Mode) const;

  // Interpolate 2 video half images.
  HImage FillInterlace(const char* Mode) const;

  // Return gray values with given rank from multiple channels.
  HImage RankN(Hlong RankIndex) const;

  // Average gray values over several channels.
  HImage MeanN() const;

  // Replace values outside of thresholds with average value.
  HImage EliminateSp(Hlong MaskWidth, Hlong MaskHeight, Hlong MinThresh, Hlong MaxThresh) const;

  // Suppress salt and pepper noise.
  HImage MeanSp(Hlong MaskWidth, Hlong MaskHeight, Hlong MinThresh, Hlong MaxThresh) const;

  // Find corners using the Sojka operator.
  void PointsSojka(Hlong MaskSize, const HTuple& SigmaW, const HTuple& SigmaD, const HTuple& MinGrad, const HTuple& MinApparentness, double MinAngle, const HString& Subpix, HTuple* Row, HTuple* Column) const;

  // Find corners using the Sojka operator.
  void PointsSojka(Hlong MaskSize, double SigmaW, double SigmaD, double MinGrad, double MinApparentness, double MinAngle, const HString& Subpix, HTuple* Row, HTuple* Column) const;

  // Find corners using the Sojka operator.
  void PointsSojka(Hlong MaskSize, double SigmaW, double SigmaD, double MinGrad, double MinApparentness, double MinAngle, const char* Subpix, HTuple* Row, HTuple* Column) const;

  // Enhance circular dots in an image.
  HImage DotsImage(Hlong Diameter, const HString& FilterType, Hlong PixelShift) const;

  // Enhance circular dots in an image.
  HImage DotsImage(Hlong Diameter, const char* FilterType, Hlong PixelShift) const;

  // Subpixel precise detection of local minima in an image.
  void LocalMinSubPix(const HString& Filter, double Sigma, double Threshold, HTuple* Row, HTuple* Column) const;

  // Subpixel precise detection of local minima in an image.
  void LocalMinSubPix(const char* Filter, double Sigma, double Threshold, HTuple* Row, HTuple* Column) const;

  // Subpixel precise detection of local maxima in an image.
  void LocalMaxSubPix(const HString& Filter, double Sigma, double Threshold, HTuple* Row, HTuple* Column) const;

  // Subpixel precise detection of local maxima in an image.
  void LocalMaxSubPix(const char* Filter, double Sigma, double Threshold, HTuple* Row, HTuple* Column) const;

  // Subpixel precise detection of saddle points in an image.
  void SaddlePointsSubPix(const HString& Filter, double Sigma, double Threshold, HTuple* Row, HTuple* Column) const;

  // Subpixel precise detection of saddle points in an image.
  void SaddlePointsSubPix(const char* Filter, double Sigma, double Threshold, HTuple* Row, HTuple* Column) const;

  // Subpixel precise detection of critical points in an image.
  void CriticalPointsSubPix(const HString& Filter, double Sigma, double Threshold, HTuple* RowMin, HTuple* ColumnMin, HTuple* RowMax, HTuple* ColumnMax, HTuple* RowSaddle, HTuple* ColumnSaddle) const;

  // Subpixel precise detection of critical points in an image.
  void CriticalPointsSubPix(const char* Filter, double Sigma, double Threshold, HTuple* RowMin, HTuple* ColumnMin, HTuple* RowMax, HTuple* ColumnMax, HTuple* RowSaddle, HTuple* ColumnSaddle) const;

  // Detect points of interest using the Harris operator.
  void PointsHarris(double SigmaGrad, double SigmaSmooth, double Alpha, const HTuple& Threshold, HTuple* Row, HTuple* Column) const;

  // Detect points of interest using the Harris operator.
  void PointsHarris(double SigmaGrad, double SigmaSmooth, double Alpha, double Threshold, HTuple* Row, HTuple* Column) const;

  // Detect points of interest using the binomial approximation of the Harris operator.
  void PointsHarrisBinomial(Hlong MaskSizeGrad, Hlong MaskSizeSmooth, double Alpha, const HTuple& Threshold, const HString& Subpix, HTuple* Row, HTuple* Column) const;

  // Detect points of interest using the binomial approximation of the Harris operator.
  void PointsHarrisBinomial(Hlong MaskSizeGrad, Hlong MaskSizeSmooth, double Alpha, double Threshold, const HString& Subpix, HTuple* Row, HTuple* Column) const;

  // Detect points of interest using the binomial approximation of the Harris operator.
  void PointsHarrisBinomial(Hlong MaskSizeGrad, Hlong MaskSizeSmooth, double Alpha, double Threshold, const char* Subpix, HTuple* Row, HTuple* Column) const;

  // Detect points of interest using the Lepetit operator.
  void PointsLepetit(Hlong Radius, Hlong CheckNeighbor, Hlong MinCheckNeighborDiff, Hlong MinScore, const HString& Subpix, HTuple* Row, HTuple* Column) const;

  // Detect points of interest using the Lepetit operator.
  void PointsLepetit(Hlong Radius, Hlong CheckNeighbor, Hlong MinCheckNeighborDiff, Hlong MinScore, const char* Subpix, HTuple* Row, HTuple* Column) const;

  // Detect points of interest using the Foerstner operator.
  void PointsFoerstner(const HTuple& SigmaGrad, const HTuple& SigmaInt, const HTuple& SigmaPoints, const HTuple& ThreshInhom, double ThreshShape, const HString& Smoothing, const HString& EliminateDoublets, HTuple* RowJunctions, HTuple* ColumnJunctions, HTuple* CoRRJunctions, HTuple* CoRCJunctions, HTuple* CoCCJunctions, HTuple* RowArea, HTuple* ColumnArea, HTuple* CoRRArea, HTuple* CoRCArea, HTuple* CoCCArea) const;

  // Detect points of interest using the Foerstner operator.
  void PointsFoerstner(double SigmaGrad, double SigmaInt, double SigmaPoints, double ThreshInhom, double ThreshShape, const HString& Smoothing, const HString& EliminateDoublets, HTuple* RowJunctions, HTuple* ColumnJunctions, HTuple* CoRRJunctions, HTuple* CoRCJunctions, HTuple* CoCCJunctions, HTuple* RowArea, HTuple* ColumnArea, HTuple* CoRRArea, HTuple* CoRCArea, HTuple* CoCCArea) const;

  // Detect points of interest using the Foerstner operator.
  void PointsFoerstner(double SigmaGrad, double SigmaInt, double SigmaPoints, double ThreshInhom, double ThreshShape, const char* Smoothing, const char* EliminateDoublets, HTuple* RowJunctions, HTuple* ColumnJunctions, HTuple* CoRRJunctions, HTuple* CoRCJunctions, HTuple* CoCCJunctions, HTuple* RowArea, HTuple* ColumnArea, HTuple* CoRRArea, HTuple* CoRCArea, HTuple* CoCCArea) const;

  // Estimate the image noise from a single image.
  HTuple EstimateNoise(const HString& Method, const HTuple& Percent) const;

  // Estimate the image noise from a single image.
  double EstimateNoise(const HString& Method, double Percent) const;

  // Estimate the image noise from a single image.
  double EstimateNoise(const char* Method, double Percent) const;

  // Determine the noise distribution of an image.
  HTuple NoiseDistributionMean(const HRegion& ConstRegion, Hlong FilterSize) const;

  // Add noise to an image.
  HImage AddNoiseWhite(double Amp) const;

  // Add noise to an image.
  HImage AddNoiseDistribution(const HTuple& Distribution) const;

  // Calculate standard deviation over several channels.
  HImage DeviationN() const;

  // Perform an inpainting by texture propagation.
  HImage InpaintingTexture(const HRegion& Region, Hlong MaskSize, Hlong SearchSize, double Anisotropy, const HString& PostIteration, double Smoothness) const;

  // Perform an inpainting by texture propagation.
  HImage InpaintingTexture(const HRegion& Region, Hlong MaskSize, Hlong SearchSize, double Anisotropy, const char* PostIteration, double Smoothness) const;

  // Perform an inpainting by coherence transport.
  HImage InpaintingCt(const HRegion& Region, double Epsilon, double Kappa, double Sigma, double Rho, const HTuple& ChannelCoefficients) const;

  // Perform an inpainting by coherence transport.
  HImage InpaintingCt(const HRegion& Region, double Epsilon, double Kappa, double Sigma, double Rho, double ChannelCoefficients) const;

  // Perform an inpainting by smoothing of level lines.
  HImage InpaintingMcf(const HRegion& Region, double Sigma, double Theta, Hlong Iterations) const;

  // Perform an inpainting by coherence enhancing diffusion.
  HImage InpaintingCed(const HRegion& Region, double Sigma, double Rho, double Theta, Hlong Iterations) const;

  // Perform an inpainting by anisotropic diffusion.
  HImage InpaintingAniso(const HRegion& Region, const HString& Mode, double Contrast, double Theta, Hlong Iterations, double Rho) const;

  // Perform an inpainting by anisotropic diffusion.
  HImage InpaintingAniso(const HRegion& Region, const char* Mode, double Contrast, double Theta, Hlong Iterations, double Rho) const;

  // Perform a harmonic interpolation on an image region.
  HImage HarmonicInterpolation(const HRegion& Region, double Precision) const;

  // Expand the domain of an image and set the gray values in the expanded domain.
  HImage ExpandDomainGray(Hlong ExpansionRange) const;

  // Compute the topographic primal sketch of an image.
  HImage TopographicSketch() const;

  // Compute an affine transformation of the color values of a multichannel image.
  HImage LinearTransColor(const HTuple& TransMat) const;

  // Compute the transformation matrix of the principal component analysis of multichannel images.
  HTuple GenPrincipalCompTrans(HTuple* TransInv, HTuple* Mean, HTuple* Cov, HTuple* InfoPerComp) const;

  // Compute the principal components of multichannel images.
  HImage PrincipalComp(HTuple* InfoPerComp) const;

  // Determine the fuzzy entropy of regions.
  HTuple FuzzyEntropy(const HRegion& Regions, Hlong Apar, Hlong Cpar) const;

  // Calculate the fuzzy perimeter of a region.
  HTuple FuzzyPerimeter(const HRegion& Regions, Hlong Apar, Hlong Cpar) const;

  // Perform a grayvalue closing with a selected mask.
  HImage GrayClosingShape(const HTuple& MaskHeight, const HTuple& MaskWidth, const HString& MaskShape) const;

  // Perform a grayvalue closing with a selected mask.
  HImage GrayClosingShape(double MaskHeight, double MaskWidth, const HString& MaskShape) const;

  // Perform a grayvalue closing with a selected mask.
  HImage GrayClosingShape(double MaskHeight, double MaskWidth, const char* MaskShape) const;

  // Perform a gray value opening with a selected mask.
  HImage GrayOpeningShape(const HTuple& MaskHeight, const HTuple& MaskWidth, const HString& MaskShape) const;

  // Perform a gray value opening with a selected mask.
  HImage GrayOpeningShape(double MaskHeight, double MaskWidth, const HString& MaskShape) const;

  // Perform a gray value opening with a selected mask.
  HImage GrayOpeningShape(double MaskHeight, double MaskWidth, const char* MaskShape) const;

  // Determine the minimum gray value within a selected mask.
  HImage GrayErosionShape(const HTuple& MaskHeight, const HTuple& MaskWidth, const HString& MaskShape) const;

  // Determine the minimum gray value within a selected mask.
  HImage GrayErosionShape(double MaskHeight, double MaskWidth, const HString& MaskShape) const;

  // Determine the minimum gray value within a selected mask.
  HImage GrayErosionShape(double MaskHeight, double MaskWidth, const char* MaskShape) const;

  // Determine the maximum gray value within a selected mask.
  HImage GrayDilationShape(const HTuple& MaskHeight, const HTuple& MaskWidth, const HString& MaskShape) const;

  // Determine the maximum gray value within a selected mask.
  HImage GrayDilationShape(double MaskHeight, double MaskWidth, const HString& MaskShape) const;

  // Determine the maximum gray value within a selected mask.
  HImage GrayDilationShape(double MaskHeight, double MaskWidth, const char* MaskShape) const;

  // Determine the gray value range within a rectangle.
  HImage GrayRangeRect(Hlong MaskHeight, Hlong MaskWidth) const;

  // Perform a gray value closing with a rectangular mask.
  HImage GrayClosingRect(Hlong MaskHeight, Hlong MaskWidth) const;

  // Perform a gray value opening with a rectangular mask.
  HImage GrayOpeningRect(Hlong MaskHeight, Hlong MaskWidth) const;

  // Determine the minimum gray value within a rectangle.
  HImage GrayErosionRect(Hlong MaskHeight, Hlong MaskWidth) const;

  // Determine the maximum gray value within a rectangle.
  HImage GrayDilationRect(Hlong MaskHeight, Hlong MaskWidth) const;

  // Thinning of gray value images.
  HImage GraySkeleton() const;

  // Transform an image with a gray-value look-up-table
  HImage LutTrans(const HTuple& Lut) const;

  // Calculate the correlation between an image and an arbitrary filter mask
  HImage ConvolImage(const HTuple& FilterMask, const HTuple& Margin) const;

  // Calculate the correlation between an image and an arbitrary filter mask
  HImage ConvolImage(const HString& FilterMask, const HString& Margin) const;

  // Calculate the correlation between an image and an arbitrary filter mask
  HImage ConvolImage(const char* FilterMask, const char* Margin) const;

  // Convert the type of an image.
  HImage ConvertImageType(const HString& NewType) const;

  // Convert the type of an image.
  HImage ConvertImageType(const char* NewType) const;

  // Convert two real-valued images into a vector field image.
  HImage RealToVectorField(const HImage& Col, const HString& Type) const;

  // Convert two real-valued images into a vector field image.
  HImage RealToVectorField(const HImage& Col, const char* Type) const;

  // Convert a vector field image into two real-valued images.
  HImage VectorFieldToReal(HImage* Col) const;

  // Convert two real images into a complex image.
  HImage RealToComplex(const HImage& ImageImaginary) const;

  // Convert a complex image into two real images.
  HImage ComplexToReal(HImage* ImageImaginary) const;

  // Paint regions with their average gray value.
  HImage RegionToMean(const HRegion& Regions) const;

  // Calculate the lowest possible gray value on an arbitrary path to the image border for each point in the image.
  HImage GrayInside() const;

  // Symmetry of gray values along a row.
  HImage Symmetry(Hlong MaskSize, double Direction, double Exponent) const;

  // Selection of gray values of a multi-channel image using an index image.
  HImage SelectGrayvaluesFromChannels(const HImage& IndexImage) const;

  // Extract depth using mutiple focus levels.
  HImage DepthFromFocus(HImage* Confidence, const HTuple& Filter, const HTuple& Selection) const;

  // Extract depth using mutiple focus levels.
  HImage DepthFromFocus(HImage* Confidence, const HString& Filter, const HString& Selection) const;

  // Extract depth using mutiple focus levels.
  HImage DepthFromFocus(HImage* Confidence, const char* Filter, const char* Selection) const;

  // Compute the uncalibrated scene flow between two stereo image pairs.
  HImage SceneFlowUncalib(const HImage& ImageRect2T1, const HImage& ImageRect1T2, const HImage& ImageRect2T2, const HImage& Disparity, HImage* DisparityChange, const HTuple& SmoothingFlow, const HTuple& SmoothingDisparity, const HTuple& GenParamName, const HTuple& GenParamValue) const;

  // Compute the uncalibrated scene flow between two stereo image pairs.
  HImage SceneFlowUncalib(const HImage& ImageRect2T1, const HImage& ImageRect1T2, const HImage& ImageRect2T2, const HImage& Disparity, HImage* DisparityChange, double SmoothingFlow, double SmoothingDisparity, const HString& GenParamName, const HString& GenParamValue) const;

  // Compute the uncalibrated scene flow between two stereo image pairs.
  HImage SceneFlowUncalib(const HImage& ImageRect2T1, const HImage& ImageRect1T2, const HImage& ImageRect2T2, const HImage& Disparity, HImage* DisparityChange, double SmoothingFlow, double SmoothingDisparity, const char* GenParamName, const char* GenParamValue) const;

  // Unwarp an image using a vector field.
  HImage UnwarpImageVectorField(const HImage& VectorField) const;

  // Convolve a vector field with derivatives of the Gaussian.
  HImage DerivateVectorField(const HTuple& Sigma, const HString& Component) const;

  // Convolve a vector field with derivatives of the Gaussian.
  HImage DerivateVectorField(double Sigma, const HString& Component) const;

  // Convolve a vector field with derivatives of the Gaussian.
  HImage DerivateVectorField(double Sigma, const char* Component) const;

  // Compute the length of the vectors of a vector field.
  HImage VectorFieldLength(const HString& Mode) const;

  // Compute the length of the vectors of a vector field.
  HImage VectorFieldLength(const char* Mode) const;

  // Compute the optical flow between two images.
  HImage OpticalFlowMg(const HImage& ImageT2, const HString& Algorithm, double SmoothingSigma, double IntegrationSigma, double FlowSmoothness, double GradientConstancy, const HTuple& MGParamName, const HTuple& MGParamValue) const;

  // Compute the optical flow between two images.
  HImage OpticalFlowMg(const HImage& ImageT2, const HString& Algorithm, double SmoothingSigma, double IntegrationSigma, double FlowSmoothness, double GradientConstancy, const HString& MGParamName, const HString& MGParamValue) const;

  // Compute the optical flow between two images.
  HImage OpticalFlowMg(const HImage& ImageT2, const char* Algorithm, double SmoothingSigma, double IntegrationSigma, double FlowSmoothness, double GradientConstancy, const char* MGParamName, const char* MGParamValue) const;

  // Matching a template and an image in a resolution pyramid.
  HImage ExhaustiveMatchMg(const HImage& ImageTemplate, const HString& Mode, Hlong Level, Hlong Threshold) const;

  // Matching a template and an image in a resolution pyramid.
  HImage ExhaustiveMatchMg(const HImage& ImageTemplate, const char* Mode, Hlong Level, Hlong Threshold) const;

  // Preparing a pattern for template matching with rotation.
  HTemplate CreateTemplateRot(Hlong NumLevel, double AngleStart, double AngleExtend, double AngleStep, const HString& Optimize, const HString& GrayValues) const;

  // Preparing a pattern for template matching with rotation.
  HTemplate CreateTemplateRot(Hlong NumLevel, double AngleStart, double AngleExtend, double AngleStep, const char* Optimize, const char* GrayValues) const;

  // Preparing a pattern for template matching.
  HTemplate CreateTemplate(Hlong FirstError, Hlong NumLevel, const HString& Optimize, const HString& GrayValues) const;

  // Preparing a pattern for template matching.
  HTemplate CreateTemplate(Hlong FirstError, Hlong NumLevel, const char* Optimize, const char* GrayValues) const;

  // Adapting a template to the size of an image.
  void AdaptTemplate(const HTemplate& TemplateID) const;

  // Searching all good grayvalue matches in a pyramid.
  HRegion FastMatchMg(const HTemplate& TemplateID, double MaxError, const HTuple& NumLevel) const;

  // Searching all good grayvalue matches in a pyramid.
  HRegion FastMatchMg(const HTemplate& TemplateID, double MaxError, Hlong NumLevel) const;

  // Searching the best grayvalue matches in a pre generated pyramid.
  void BestMatchPreMg(const HTemplate& TemplateID, double MaxError, const HString& SubPixel, Hlong NumLevels, const HTuple& WhichLevels, double* Row, double* Column, double* Error) const;

  // Searching the best grayvalue matches in a pre generated pyramid.
  void BestMatchPreMg(const HTemplate& TemplateID, double MaxError, const HString& SubPixel, Hlong NumLevels, Hlong WhichLevels, double* Row, double* Column, double* Error) const;

  // Searching the best grayvalue matches in a pre generated pyramid.
  void BestMatchPreMg(const HTemplate& TemplateID, double MaxError, const char* SubPixel, Hlong NumLevels, Hlong WhichLevels, double* Row, double* Column, double* Error) const;

  // Searching the best grayvalue matches in a pyramid.
  void BestMatchMg(const HTemplate& TemplateID, double MaxError, const HString& SubPixel, Hlong NumLevels, const HTuple& WhichLevels, double* Row, double* Column, double* Error) const;

  // Searching the best grayvalue matches in a pyramid.
  void BestMatchMg(const HTemplate& TemplateID, double MaxError, const HString& SubPixel, Hlong NumLevels, Hlong WhichLevels, double* Row, double* Column, double* Error) const;

  // Searching the best grayvalue matches in a pyramid.
  void BestMatchMg(const HTemplate& TemplateID, double MaxError, const char* SubPixel, Hlong NumLevels, Hlong WhichLevels, double* Row, double* Column, double* Error) const;

  // Searching all good matches of a template and an image.
  HRegion FastMatch(const HTemplate& TemplateID, double MaxError) const;

  // Searching the best matching of a template and a pyramid with rotation.
  void BestMatchRotMg(const HTemplate& TemplateID, double AngleStart, double AngleExtend, double MaxError, const HString& SubPixel, Hlong NumLevels, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* Error) const;

  // Searching the best matching of a template and a pyramid with rotation.
  void BestMatchRotMg(const HTemplate& TemplateID, double AngleStart, double AngleExtend, double MaxError, const HString& SubPixel, Hlong NumLevels, double* Row, double* Column, double* Angle, double* Error) const;

  // Searching the best matching of a template and a pyramid with rotation.
  void BestMatchRotMg(const HTemplate& TemplateID, double AngleStart, double AngleExtend, double MaxError, const char* SubPixel, Hlong NumLevels, double* Row, double* Column, double* Angle, double* Error) const;

  // Searching the best matching of a template and an image with rotation.
  void BestMatchRot(const HTemplate& TemplateID, double AngleStart, double AngleExtend, double MaxError, const HString& SubPixel, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* Error) const;

  // Searching the best matching of a template and an image with rotation.
  void BestMatchRot(const HTemplate& TemplateID, double AngleStart, double AngleExtend, double MaxError, const HString& SubPixel, double* Row, double* Column, double* Angle, double* Error) const;

  // Searching the best matching of a template and an image with rotation.
  void BestMatchRot(const HTemplate& TemplateID, double AngleStart, double AngleExtend, double MaxError, const char* SubPixel, double* Row, double* Column, double* Angle, double* Error) const;

  // Searching the best matching of a template and an image.
  void BestMatch(const HTemplate& TemplateID, double MaxError, const HString& SubPixel, HTuple* Row, HTuple* Column, HTuple* Error) const;

  // Searching the best matching of a template and an image.
  void BestMatch(const HTemplate& TemplateID, double MaxError, const HString& SubPixel, double* Row, double* Column, double* Error) const;

  // Searching the best matching of a template and an image.
  void BestMatch(const HTemplate& TemplateID, double MaxError, const char* SubPixel, double* Row, double* Column, double* Error) const;

  // Matching of a template and an image.
  HImage ExhaustiveMatch(const HRegion& RegionOfInterest, const HImage& ImageTemplate, const HString& Mode) const;

  // Matching of a template and an image.
  HImage ExhaustiveMatch(const HRegion& RegionOfInterest, const HImage& ImageTemplate, const char* Mode) const;

  // Searching corners in images.
  HImage CornerResponse(Hlong Size, double Weight) const;

  // Calculating a Gauss pyramid.
  HImage GenGaussPyramid(const HString& Mode, double Scale) const;

  // Calculating a Gauss pyramid.
  HImage GenGaussPyramid(const char* Mode, double Scale) const;

  // Calculating the monotony operation.
  HImage Monotony() const;

  // Edge extraction using bandpass filters.
  HImage BandpassImage(const HString& FilterType) const;

  // Edge extraction using bandpass filters.
  HImage BandpassImage(const char* FilterType) const;

  // Detect color lines and their width.
  HXLDCont LinesColor(const HTuple& Sigma, const HTuple& Low, const HTuple& High, const HString& ExtractWidth, const HString& CompleteJunctions) const;

  // Detect color lines and their width.
  HXLDCont LinesColor(double Sigma, double Low, double High, const HString& ExtractWidth, const HString& CompleteJunctions) const;

  // Detect color lines and their width.
  HXLDCont LinesColor(double Sigma, double Low, double High, const char* ExtractWidth, const char* CompleteJunctions) const;

  // Detect lines and their width.
  HXLDCont LinesGauss(const HTuple& Sigma, const HTuple& Low, const HTuple& High, const HString& LightDark, const HString& ExtractWidth, const HString& LineModel, const HString& CompleteJunctions) const;

  // Detect lines and their width.
  HXLDCont LinesGauss(double Sigma, double Low, double High, const HString& LightDark, const HString& ExtractWidth, const HString& LineModel, const HString& CompleteJunctions) const;

  // Detect lines and their width.
  HXLDCont LinesGauss(double Sigma, double Low, double High, const char* LightDark, const char* ExtractWidth, const char* LineModel, const char* CompleteJunctions) const;

  // Detection of lines using the facet model.
  HXLDCont LinesFacet(Hlong MaskSize, const HTuple& Low, const HTuple& High, const HString& LightDark) const;

  // Detection of lines using the facet model.
  HXLDCont LinesFacet(Hlong MaskSize, double Low, double High, const HString& LightDark) const;

  // Detection of lines using the facet model.
  HXLDCont LinesFacet(Hlong MaskSize, double Low, double High, const char* LightDark) const;

  // Store a filter mask in the spatial domain as a real-image.
  void GenFilterMask(const HTuple& FilterMask, double Scale, Hlong Width, Hlong Height);

  // Store a filter mask in the spatial domain as a real-image.
  void GenFilterMask(const HString& FilterMask, double Scale, Hlong Width, Hlong Height);

  // Store a filter mask in the spatial domain as a real-image.
  void GenFilterMask(const char* FilterMask, double Scale, Hlong Width, Hlong Height);

  // Generate a mean filter in the frequency domain.
  void GenMeanFilter(const HString& MaskShape, double Diameter1, double Diameter2, double Phi, const HString& Norm, const HString& Mode, Hlong Width, Hlong Height);

  // Generate a mean filter in the frequency domain.
  void GenMeanFilter(const char* MaskShape, double Diameter1, double Diameter2, double Phi, const char* Norm, const char* Mode, Hlong Width, Hlong Height);

  // Generate a Gaussian filter in the frequency domain.
  void GenGaussFilter(double Sigma1, double Sigma2, double Phi, const HString& Norm, const HString& Mode, Hlong Width, Hlong Height);

  // Generate a Gaussian filter in the frequency domain.
  void GenGaussFilter(double Sigma1, double Sigma2, double Phi, const char* Norm, const char* Mode, Hlong Width, Hlong Height);

  // Generate a derivative filter in the frequency domain.
  void GenDerivativeFilter(const HString& Derivative, Hlong Exponent, const HString& Norm, const HString& Mode, Hlong Width, Hlong Height);

  // Generate a derivative filter in the frequency domain.
  void GenDerivativeFilter(const char* Derivative, Hlong Exponent, const char* Norm, const char* Mode, Hlong Width, Hlong Height);

  // Generate a bandpass filter with Gaussian or sinusoidal shape.
  void GenStdBandpass(double Frequency, double Sigma, const HString& Type, const HString& Norm, const HString& Mode, Hlong Width, Hlong Height);

  // Generate a bandpass filter with Gaussian or sinusoidal shape.
  void GenStdBandpass(double Frequency, double Sigma, const char* Type, const char* Norm, const char* Mode, Hlong Width, Hlong Height);

  // Generate a bandpass filter with sinusoidal shape.
  void GenSinBandpass(double Frequency, const HString& Norm, const HString& Mode, Hlong Width, Hlong Height);

  // Generate a bandpass filter with sinusoidal shape.
  void GenSinBandpass(double Frequency, const char* Norm, const char* Mode, Hlong Width, Hlong Height);

  // Generate an ideal band filter.
  void GenBandfilter(double MinFrequency, double MaxFrequency, const HString& Norm, const HString& Mode, Hlong Width, Hlong Height);

  // Generate an ideal band filter.
  void GenBandfilter(double MinFrequency, double MaxFrequency, const char* Norm, const char* Mode, Hlong Width, Hlong Height);

  // Generate an ideal bandpass filter.
  void GenBandpass(double MinFrequency, double MaxFrequency, const HString& Norm, const HString& Mode, Hlong Width, Hlong Height);

  // Generate an ideal bandpass filter.
  void GenBandpass(double MinFrequency, double MaxFrequency, const char* Norm, const char* Mode, Hlong Width, Hlong Height);

  // Generate an ideal lowpass filter.
  void GenLowpass(double Frequency, const HString& Norm, const HString& Mode, Hlong Width, Hlong Height);

  // Generate an ideal lowpass filter.
  void GenLowpass(double Frequency, const char* Norm, const char* Mode, Hlong Width, Hlong Height);

  // Generate an ideal highpass filter.
  void GenHighpass(double Frequency, const HString& Norm, const HString& Mode, Hlong Width, Hlong Height);

  // Generate an ideal highpass filter.
  void GenHighpass(double Frequency, const char* Norm, const char* Mode, Hlong Width, Hlong Height);

  // Return the power spectrum of a complex image.
  HImage PowerLn() const;

  // Return the power spectrum of a complex image.
  HImage PowerReal() const;

  // Return the power spectrum of a complex image.
  HImage PowerByte() const;

  // Return the phase of a complex image in degrees.
  HImage PhaseDeg() const;

  // Return the phase of a complex image in radians.
  HImage PhaseRad() const;

  // Calculate the energy of a two-channel image.
  HImage EnergyGabor(const HImage& ImageHilbert) const;

  // Convolve an image with a Gabor filter in the frequency domain.
  HImage ConvolGabor(const HImage& GaborFilter, HImage* ImageResultHilbert) const;

  // Generate a Gabor filter.
  void GenGabor(double Angle, double Frequency, double Bandwidth, double Orientation, const HString& Norm, const HString& Mode, Hlong Width, Hlong Height);

  // Generate a Gabor filter.
  void GenGabor(double Angle, double Frequency, double Bandwidth, double Orientation, const char* Norm, const char* Mode, Hlong Width, Hlong Height);

  // Compute the phase correlation of two images in the frequency domain.
  HImage PhaseCorrelationFft(const HImage& ImageFFT2) const;

  // Compute the correlation of two images in the frequency domain.
  HImage CorrelationFft(const HImage& ImageFFT2) const;

  // Convolve an image with a filter in the frequency domain.
  HImage ConvolFft(const HImage& ImageFilter) const;

  // Compute the real-valued fast Fourier transform of an image.
  HImage RftGeneric(const HString& Direction, const HString& Norm, const HString& ResultType, Hlong Width) const;

  // Compute the real-valued fast Fourier transform of an image.
  HImage RftGeneric(const char* Direction, const char* Norm, const char* ResultType, Hlong Width) const;

  // Compute the inverse fast Fourier transform of an image.
  HImage FftImageInv() const;

  // Compute the fast Fourier transform of an image.
  HImage FftImage() const;

  // Compute the fast Fourier transform of an image.
  HImage FftGeneric(const HString& Direction, Hlong Exponent, const HString& Norm, const HString& Mode, const HString& ResultType) const;

  // Compute the fast Fourier transform of an image.
  HImage FftGeneric(const char* Direction, Hlong Exponent, const char* Norm, const char* Mode, const char* ResultType) const;

  // Apply a shock filter to an image.
  HImage ShockFilter(double Theta, Hlong Iterations, const HString& Mode, double Sigma) const;

  // Apply a shock filter to an image.
  HImage ShockFilter(double Theta, Hlong Iterations, const char* Mode, double Sigma) const;

  // Apply the mean curvature flow to an image.
  HImage MeanCurvatureFlow(double Sigma, double Theta, Hlong Iterations) const;

  // Perform a coherence enhancing diffusion of an image.
  HImage CoherenceEnhancingDiff(double Sigma, double Rho, double Theta, Hlong Iterations) const;

  // Histogram linearisation of images
  HImage EquHistoImage() const;

  // Illuminate image.
  HImage Illuminate(Hlong MaskWidth, Hlong MaskHeight, double Factor) const;

  // Enhance contrast of the image.
  HImage Emphasize(Hlong MaskWidth, Hlong MaskHeight, double Factor) const;

  // Maximum gray value spreading in the value range 0 to 255.
  HImage ScaleImageMax() const;

  // Detect edges (amplitude and direction) using the Robinson operator.
  HImage RobinsonDir(HImage* ImageEdgeDir) const;

  // Detect edges (amplitude) using the Robinson operator.
  HImage RobinsonAmp() const;

  // Detect edges (amplitude and direction) using the Kirsch operator.
  HImage KirschDir(HImage* ImageEdgeDir) const;

  // Detect edges (amplitude) using the Kirsch operator.
  HImage KirschAmp() const;

  // Detect edges (amplitude and direction) using the Frei-Chen operator.
  HImage FreiDir(HImage* ImageEdgeDir) const;

  // Detect edges (amplitude) using the Frei-Chen operator.
  HImage FreiAmp() const;

  // Detect edges (amplitude and direction) using the Prewitt operator.
  HImage PrewittDir(HImage* ImageEdgeDir) const;

  // Detect edges (amplitude) using the Prewitt operator.
  HImage PrewittAmp() const;

  // Detect edges (amplitude) using the Sobel operator.
  HImage SobelAmp(const HString& FilterType, const HTuple& Size) const;

  // Detect edges (amplitude) using the Sobel operator.
  HImage SobelAmp(const HString& FilterType, Hlong Size) const;

  // Detect edges (amplitude) using the Sobel operator.
  HImage SobelAmp(const char* FilterType, Hlong Size) const;

  // Detect edges (amplitude and direction) using the Sobel operator.
  HImage SobelDir(HImage* EdgeDirection, const HString& FilterType, const HTuple& Size) const;

  // Detect edges (amplitude and direction) using the Sobel operator.
  HImage SobelDir(HImage* EdgeDirection, const HString& FilterType, Hlong Size) const;

  // Detect edges (amplitude and direction) using the Sobel operator.
  HImage SobelDir(HImage* EdgeDirection, const char* FilterType, Hlong Size) const;

  // Detect edges using the Roberts filter.
  HImage Roberts(const HString& FilterType) const;

  // Detect edges using the Roberts filter.
  HImage Roberts(const char* FilterType) const;

  // Calculate the Laplace operator by using finite differences.
  HImage Laplace(const HString& ResultType, const HTuple& MaskSize, const HString& FilterMask) const;

  // Calculate the Laplace operator by using finite differences.
  HImage Laplace(const HString& ResultType, Hlong MaskSize, const HString& FilterMask) const;

  // Calculate the Laplace operator by using finite differences.
  HImage Laplace(const char* ResultType, Hlong MaskSize, const char* FilterMask) const;

  // Extract high frequency components from an image.
  HImage HighpassImage(Hlong Width, Hlong Height) const;

  // Extract subpixel precise color edges using Deriche, Shen, or Canny filters.
  HXLDCont EdgesColorSubPix(const HString& Filter, double Alpha, const HTuple& Low, const HTuple& High) const;

  // Extract subpixel precise color edges using Deriche, Shen, or Canny filters.
  HXLDCont EdgesColorSubPix(const HString& Filter, double Alpha, double Low, double High) const;

  // Extract subpixel precise color edges using Deriche, Shen, or Canny filters.
  HXLDCont EdgesColorSubPix(const char* Filter, double Alpha, double Low, double High) const;

  // Extract color edges using Canny, Deriche, or Shen filters.
  HImage EdgesColor(HImage* ImaDir, const HString& Filter, double Alpha, const HString& NMS, Hlong Low, Hlong High) const;

  // Extract color edges using Canny, Deriche, or Shen filters.
  HImage EdgesColor(HImage* ImaDir, const char* Filter, double Alpha, const char* NMS, Hlong Low, Hlong High) const;

  // Extract sub-pixel precise edges using Deriche, Lanser, Shen, or Canny filters.
  HXLDCont EdgesSubPix(const HString& Filter, double Alpha, const HTuple& Low, const HTuple& High) const;

  // Extract sub-pixel precise edges using Deriche, Lanser, Shen, or Canny filters.
  HXLDCont EdgesSubPix(const HString& Filter, double Alpha, Hlong Low, Hlong High) const;

  // Extract sub-pixel precise edges using Deriche, Lanser, Shen, or Canny filters.
  HXLDCont EdgesSubPix(const char* Filter, double Alpha, Hlong Low, Hlong High) const;

  // Extract edges using Deriche, Lanser, Shen, or Canny filters.
  HImage EdgesImage(HImage* ImaDir, const HString& Filter, double Alpha, const HString& NMS, const HTuple& Low, const HTuple& High) const;

  // Extract edges using Deriche, Lanser, Shen, or Canny filters.
  HImage EdgesImage(HImage* ImaDir, const HString& Filter, double Alpha, const HString& NMS, Hlong Low, Hlong High) const;

  // Extract edges using Deriche, Lanser, Shen, or Canny filters.
  HImage EdgesImage(HImage* ImaDir, const char* Filter, double Alpha, const char* NMS, Hlong Low, Hlong High) const;

  // Convolve an image with derivatives of the Gaussian.
  HImage DerivateGauss(const HTuple& Sigma, const HString& Component) const;

  // Convolve an image with derivatives of the Gaussian.
  HImage DerivateGauss(double Sigma, const HString& Component) const;

  // Convolve an image with derivatives of the Gaussian.
  HImage DerivateGauss(double Sigma, const char* Component) const;

  // LoG-Operator (Laplace of Gaussian).
  HImage LaplaceOfGauss(const HTuple& Sigma) const;

  // LoG-Operator (Laplace of Gaussian).
  HImage LaplaceOfGauss(double Sigma) const;

  // Approximate the LoG operator (Laplace of Gaussian).
  HImage DiffOfGauss(double Sigma, double SigFactor) const;

  // Detect straight edge segments.
  void DetectEdgeSegments(Hlong SobelSize, Hlong MinAmplitude, Hlong MaxDistance, Hlong MinLength, HTuple* BeginRow, HTuple* BeginCol, HTuple* EndRow, HTuple* EndCol) const;

  // Release the look-up-table needed for color space transformation.
  static void ClearColorTransLut(const HColorTransLUT& ColorTransLUTHandle);

  // Color space transformation using pre-generated look-up-table.
  HImage ApplyColorTransLut(const HImage& Image2, const HImage& Image3, HImage* ImageResult2, HImage* ImageResult3, const HColorTransLUT& ColorTransLUTHandle) const;

  // Creates the look-up-table for transformation of an image from the RGB color space to an arbitrary color space.
  static HColorTransLUT CreateColorTransLut(const HString& ColorSpace, const HString& TransDirection, Hlong NumBits);

  // Creates the look-up-table for transformation of an image from the RGB color space to an arbitrary color space.
  static HColorTransLUT CreateColorTransLut(const char* ColorSpace, const char* TransDirection, Hlong NumBits);

  // Convert a single-channel color filter array image into an RGB image.
  HImage CfaToRgb(const HString& CFAType, const HString& Interpolation) const;

  // Convert a single-channel color filter array image into an RGB image.
  HImage CfaToRgb(const char* CFAType, const char* Interpolation) const;

  // Transform an RGB image into a gray scale image.
  HImage Rgb1ToGray() const;

  // Transform an RGB image to a gray scale image.
  HImage Rgb3ToGray(const HImage& ImageGreen, const HImage& ImageBlue) const;

  // Transform an image from the RGB color space to an arbitrary color space.
  HImage TransFromRgb(const HImage& ImageGreen, const HImage& ImageBlue, HImage* ImageResult2, HImage* ImageResult3, const HString& ColorSpace) const;

  // Transform an image from the RGB color space to an arbitrary color space.
  HImage TransFromRgb(const HImage& ImageGreen, const HImage& ImageBlue, HImage* ImageResult2, HImage* ImageResult3, const char* ColorSpace) const;

  // Transform an image from an arbitrary color space to the RGB color space.
  HImage TransToRgb(const HImage& ImageInput2, const HImage& ImageInput3, HImage* ImageGreen, HImage* ImageBlue, const HString& ColorSpace) const;

  // Transform an image from an arbitrary color space to the RGB color space.
  HImage TransToRgb(const HImage& ImageInput2, const HImage& ImageInput3, HImage* ImageGreen, HImage* ImageBlue, const char* ColorSpace) const;

  // Logical "AND" of each pixel using a bit mask.
  HImage BitMask(Hlong BitMask) const;

  // Extract a bit from the pixels.
  HImage BitSlice(Hlong Bit) const;

  // Right shift of all pixels of the image.
  HImage BitRshift(Hlong Shift) const;

  // Left shift of all pixels of the image.
  HImage BitLshift(Hlong Shift) const;

  // Complement all bits of the pixels.
  HImage BitNot() const;

  // Bit-by-bit XOR of all pixels of the input images.
  HImage BitXor(const HImage& Image2) const;

  // Bit-by-bit OR of all pixels of the input images.
  HImage BitOr(const HImage& Image2) const;

  // Bit-by-bit AND of all pixels of the input images.
  HImage BitAnd(const HImage& Image2) const;

  // Perform a gamma encoding or decoding of an image.
  HImage GammaImage(double Gamma, double Offset, double Threshold, const HTuple& MaxGray, const HString& Encode) const;

  // Perform a gamma encoding or decoding of an image.
  HImage GammaImage(double Gamma, double Offset, double Threshold, double MaxGray, const HString& Encode) const;

  // Perform a gamma encoding or decoding of an image.
  HImage GammaImage(double Gamma, double Offset, double Threshold, double MaxGray, const char* Encode) const;

  // Raise an image to a power.
  HImage PowImage(const HTuple& Exponent) const;

  // Raise an image to a power.
  HImage PowImage(double Exponent) const;

  // Calculate the exponentiation of an image.
  HImage ExpImage(const HTuple& Base) const;

  // Calculate the exponentiation of an image.
  HImage ExpImage(const HString& Base) const;

  // Calculate the exponentiation of an image.
  HImage ExpImage(const char* Base) const;

  // Calculate the logarithm of an image.
  HImage LogImage(const HTuple& Base) const;

  // Calculate the logarithm of an image.
  HImage LogImage(const HString& Base) const;

  // Calculate the logarithm of an image.
  HImage LogImage(const char* Base) const;

  // Calculate the arctangent of two images.
  HImage Atan2Image(const HImage& ImageX) const;

  // Calculate the arctangent of an image.
  HImage AtanImage() const;

  // Calculate the arccosine of an image.
  HImage AcosImage() const;

  // Calculate the arcsine of an image.
  HImage AsinImage() const;

  // Calculate the tangent of an image.
  HImage TanImage() const;

  // Calculate the cosine of an image.
  HImage CosImage() const;

  // Calculate the sine of an image.
  HImage SinImage() const;

  // Calculate the absolute difference of two images.
  HImage AbsDiffImage(const HImage& Image2, const HTuple& Mult) const;

  // Calculate the absolute difference of two images.
  HImage AbsDiffImage(const HImage& Image2, double Mult) const;

  // Calculate the square root of an image.
  HImage SqrtImage() const;

  // Subtract two images.
  HImage SubImage(const HImage& ImageSubtrahend, const HTuple& Mult, const HTuple& Add) const;

  // Subtract two images.
  HImage SubImage(const HImage& ImageSubtrahend, double Mult, double Add) const;

  // Scale the gray values of an image.
  HImage ScaleImage(const HTuple& Mult, const HTuple& Add) const;

  // Scale the gray values of an image.
  HImage ScaleImage(double Mult, double Add) const;

  // Divide two images.
  HImage DivImage(const HImage& Image2, const HTuple& Mult, const HTuple& Add) const;

  // Divide two images.
  HImage DivImage(const HImage& Image2, double Mult, double Add) const;

  // Multiply two images.
  HImage MultImage(const HImage& Image2, const HTuple& Mult, const HTuple& Add) const;

  // Multiply two images.
  HImage MultImage(const HImage& Image2, double Mult, double Add) const;

  // Add two images.
  HImage AddImage(const HImage& Image2, const HTuple& Mult, const HTuple& Add) const;

  // Add two images.
  HImage AddImage(const HImage& Image2, double Mult, double Add) const;

  // Calculate the absolute value (modulus) of an image.
  HImage AbsImage() const;

  // Calculate the minimum of two images pixel by pixel.
  HImage MinImage(const HImage& Image2) const;

  // Calculate the maximum of two images pixel by pixel.
  HImage MaxImage(const HImage& Image2) const;

  // Invert an image.
  HImage InvertImage() const;

  // Apply an automatic color correction to panorama images.
  HImage AdjustMosaicImages(const HTuple& From, const HTuple& To, Hlong ReferenceImage, const HTuple& HomMatrices2D, const HString& EstimationMethod, const HTuple& EstimateParameters, const HString& OECFModel) const;

  // Apply an automatic color correction to panorama images.
  HImage AdjustMosaicImages(const HTuple& From, const HTuple& To, Hlong ReferenceImage, const HTuple& HomMatrices2D, const HString& EstimationMethod, const HString& EstimateParameters, const HString& OECFModel) const;

  // Apply an automatic color correction to panorama images.
  HImage AdjustMosaicImages(const HTuple& From, const HTuple& To, Hlong ReferenceImage, const HTuple& HomMatrices2D, const char* EstimationMethod, const char* EstimateParameters, const char* OECFModel) const;

  // Create 6 cube map images of a spherical mosaic.
  HImage GenCubeMapMosaic(HImage* Rear, HImage* Left, HImage* Right, HImage* Top, HImage* Bottom, const HHomMat2DArray& CameraMatrices, const HHomMat2DArray& RotationMatrices, Hlong CubeMapDimension, const HTuple& StackingOrder, const HString& Interpolation) const;

  // Create 6 cube map images of a spherical mosaic.
  HImage GenCubeMapMosaic(HImage* Rear, HImage* Left, HImage* Right, HImage* Top, HImage* Bottom, const HHomMat2DArray& CameraMatrices, const HHomMat2DArray& RotationMatrices, Hlong CubeMapDimension, const HString& StackingOrder, const HString& Interpolation) const;

  // Create 6 cube map images of a spherical mosaic.
  HImage GenCubeMapMosaic(HImage* Rear, HImage* Left, HImage* Right, HImage* Top, HImage* Bottom, const HHomMat2DArray& CameraMatrices, const HHomMat2DArray& RotationMatrices, Hlong CubeMapDimension, const char* StackingOrder, const char* Interpolation) const;

  // Create a spherical mosaic image.
  HImage GenSphericalMosaic(const HHomMat2DArray& CameraMatrices, const HHomMat2DArray& RotationMatrices, const HTuple& LatMin, const HTuple& LatMax, const HTuple& LongMin, const HTuple& LongMax, const HTuple& LatLongStep, const HTuple& StackingOrder, const HTuple& Interpolation) const;

  // Create a spherical mosaic image.
  HImage GenSphericalMosaic(const HHomMat2DArray& CameraMatrices, const HHomMat2DArray& RotationMatrices, double LatMin, double LatMax, double LongMin, double LongMax, double LatLongStep, const HString& StackingOrder, const HString& Interpolation) const;

  // Create a spherical mosaic image.
  HImage GenSphericalMosaic(const HHomMat2DArray& CameraMatrices, const HHomMat2DArray& RotationMatrices, double LatMin, double LatMax, double LongMin, double LongMax, double LatLongStep, const char* StackingOrder, const char* Interpolation) const;

  // Combine multiple images into a mosaic image.
  HImage GenBundleAdjustedMosaic(const HHomMat2DArray& HomMatrices2D, const HTuple& StackingOrder, const HString& TransformDomain, HHomMat2D* TransMat2D) const;

  // Combine multiple images into a mosaic image.
  HImage GenBundleAdjustedMosaic(const HHomMat2DArray& HomMatrices2D, const HString& StackingOrder, const HString& TransformDomain, HHomMat2D* TransMat2D) const;

  // Combine multiple images into a mosaic image.
  HImage GenBundleAdjustedMosaic(const HHomMat2DArray& HomMatrices2D, const char* StackingOrder, const char* TransformDomain, HHomMat2D* TransMat2D) const;

  // Combine multiple images into a mosaic image.
  HImage GenProjectiveMosaic(Hlong StartImage, const HTuple& MappingSource, const HTuple& MappingDest, const HHomMat2DArray& HomMatrices2D, const HTuple& StackingOrder, const HString& TransformDomain, HHomMat2DArray* MosaicMatrices2D) const;

  // Combine multiple images into a mosaic image.
  HImage GenProjectiveMosaic(Hlong StartImage, const HTuple& MappingSource, const HTuple& MappingDest, const HHomMat2DArray& HomMatrices2D, const HString& StackingOrder, const HString& TransformDomain, HHomMat2DArray* MosaicMatrices2D) const;

  // Combine multiple images into a mosaic image.
  HImage GenProjectiveMosaic(Hlong StartImage, const HTuple& MappingSource, const HTuple& MappingDest, const HHomMat2DArray& HomMatrices2D, const char* StackingOrder, const char* TransformDomain, HHomMat2DArray* MosaicMatrices2D) const;

  // Apply a projective transformation to an image and specify the output image size.
  HImage ProjectiveTransImageSize(const HHomMat2D& HomMat2D, const HString& Interpolation, Hlong Width, Hlong Height, const HString& TransformDomain) const;

  // Apply a projective transformation to an image and specify the output image size.
  HImage ProjectiveTransImageSize(const HHomMat2D& HomMat2D, const char* Interpolation, Hlong Width, Hlong Height, const char* TransformDomain) const;

  // Apply a projective transformation to an image.
  HImage ProjectiveTransImage(const HHomMat2D& HomMat2D, const HString& Interpolation, const HString& AdaptImageSize, const HString& TransformDomain) const;

  // Apply a projective transformation to an image.
  HImage ProjectiveTransImage(const HHomMat2D& HomMat2D, const char* Interpolation, const char* AdaptImageSize, const char* TransformDomain) const;

  // Apply an arbitrary affine 2D transformation to an image and specify the output image size.
  HImage AffineTransImageSize(const HHomMat2D& HomMat2D, const HString& Interpolation, Hlong Width, Hlong Height) const;

  // Apply an arbitrary affine 2D transformation to an image and specify the output image size.
  HImage AffineTransImageSize(const HHomMat2D& HomMat2D, const char* Interpolation, Hlong Width, Hlong Height) const;

  // Apply an arbitrary affine 2D transformation to images.
  HImage AffineTransImage(const HHomMat2D& HomMat2D, const HString& Interpolation, const HString& AdaptImageSize) const;

  // Apply an arbitrary affine 2D transformation to images.
  HImage AffineTransImage(const HHomMat2D& HomMat2D, const char* Interpolation, const char* AdaptImageSize) const;

  // Zoom an image by a given factor.
  HImage ZoomImageFactor(double ScaleWidth, double ScaleHeight, const HString& Interpolation) const;

  // Zoom an image by a given factor.
  HImage ZoomImageFactor(double ScaleWidth, double ScaleHeight, const char* Interpolation) const;

  // Zoom an image to a given size.
  HImage ZoomImageSize(Hlong Width, Hlong Height, const HString& Interpolation) const;

  // Zoom an image to a given size.
  HImage ZoomImageSize(Hlong Width, Hlong Height, const char* Interpolation) const;

  // Mirror an image.
  HImage MirrorImage(const HString& Mode) const;

  // Mirror an image.
  HImage MirrorImage(const char* Mode) const;

  // Rotate an image about its center.
  HImage RotateImage(const HTuple& Phi, const HString& Interpolation) const;

  // Rotate an image about its center.
  HImage RotateImage(double Phi, const HString& Interpolation) const;

  // Rotate an image about its center.
  HImage RotateImage(double Phi, const char* Interpolation) const;

  // Transform an image in polar coordinates back to cartesian coordinates
  HImage PolarTransImageInv(const HTuple& Row, const HTuple& Column, double AngleStart, double AngleEnd, const HTuple& RadiusStart, const HTuple& RadiusEnd, Hlong Width, Hlong Height, const HString& Interpolation) const;

  // Transform an image in polar coordinates back to cartesian coordinates
  HImage PolarTransImageInv(double Row, double Column, double AngleStart, double AngleEnd, double RadiusStart, double RadiusEnd, Hlong Width, Hlong Height, const HString& Interpolation) const;

  // Transform an image in polar coordinates back to cartesian coordinates
  HImage PolarTransImageInv(double Row, double Column, double AngleStart, double AngleEnd, double RadiusStart, double RadiusEnd, Hlong Width, Hlong Height, const char* Interpolation) const;

  // Transform an annular arc in an image to polar coordinates.
  HImage PolarTransImageExt(const HTuple& Row, const HTuple& Column, double AngleStart, double AngleEnd, const HTuple& RadiusStart, const HTuple& RadiusEnd, Hlong Width, Hlong Height, const HString& Interpolation) const;

  // Transform an annular arc in an image to polar coordinates.
  HImage PolarTransImageExt(double Row, double Column, double AngleStart, double AngleEnd, double RadiusStart, double RadiusEnd, Hlong Width, Hlong Height, const HString& Interpolation) const;

  // Transform an annular arc in an image to polar coordinates.
  HImage PolarTransImageExt(double Row, double Column, double AngleStart, double AngleEnd, double RadiusStart, double RadiusEnd, Hlong Width, Hlong Height, const char* Interpolation) const;

  // Transform an image to polar coordinates
  HImage PolarTransImage(Hlong Row, Hlong Column, Hlong Width, Hlong Height) const;

  // Approximate an affine map from a displacement vector field.
  HHomMat2D VectorFieldToHomMat2d() const;

  // Deserialize a serialized image object.
  void DeserializeImage(const HSerializedItem& SerializedItemHandle);

  // Serialize an image object.
  HSerializedItem SerializeImage() const;

  // Write images in graphic formats.
  void WriteImage(const HString& Format, const HTuple& FillColor, const HTuple& FileName) const;

  // Write images in graphic formats.
  void WriteImage(const HString& Format, Hlong FillColor, const HString& FileName) const;

  // Write images in graphic formats.
  void WriteImage(const char* Format, Hlong FillColor, const char* FileName) const;

  // Read images.
  void ReadSequence(Hlong HeaderSize, Hlong SourceWidth, Hlong SourceHeight, Hlong StartRow, Hlong StartColumn, Hlong DestWidth, Hlong DestHeight, const HString& PixelType, const HString& BitOrder, const HString& ByteOrder, const HString& Pad, Hlong Index, const HString& FileName);

  // Read images.
  void ReadSequence(Hlong HeaderSize, Hlong SourceWidth, Hlong SourceHeight, Hlong StartRow, Hlong StartColumn, Hlong DestWidth, Hlong DestHeight, const char* PixelType, const char* BitOrder, const char* ByteOrder, const char* Pad, Hlong Index, const char* FileName);

  // Read an image with different file formats.
  void ReadImage(const HTuple& FileName);

  // Read an image with different file formats.
  void ReadImage(const HString& FileName);

  // Read an image with different file formats.
  void ReadImage(const char* FileName);

  // Return gray values of an image at the positions of an XLD contour.
  HTuple GetGrayvalContourXld(const HXLDCont& Contour, const HString& Interpolation) const;

  // Return gray values of an image at the positions of an XLD contour.
  HTuple GetGrayvalContourXld(const HXLDCont& Contour, const char* Interpolation) const;

  // Calculate gray value moments and approximation by a first order surface (plane).
  HTuple FitSurfaceFirstOrder(const HRegion& Regions, const HString& Algorithm, Hlong Iterations, double ClippingFactor, HTuple* Beta, HTuple* Gamma) const;

  // Calculate gray value moments and approximation by a first order surface (plane).
  double FitSurfaceFirstOrder(const HRegion& Regions, const HString& Algorithm, Hlong Iterations, double ClippingFactor, double* Beta, double* Gamma) const;

  // Calculate gray value moments and approximation by a first order surface (plane).
  double FitSurfaceFirstOrder(const HRegion& Regions, const char* Algorithm, Hlong Iterations, double ClippingFactor, double* Beta, double* Gamma) const;

  // Calculate gray value moments and approximation by a second order surface.
  HTuple FitSurfaceSecondOrder(const HRegion& Regions, const HString& Algorithm, Hlong Iterations, double ClippingFactor, HTuple* Beta, HTuple* Gamma, HTuple* Delta, HTuple* Epsilon, HTuple* Zeta) const;

  // Calculate gray value moments and approximation by a second order surface.
  double FitSurfaceSecondOrder(const HRegion& Regions, const HString& Algorithm, Hlong Iterations, double ClippingFactor, double* Beta, double* Gamma, double* Delta, double* Epsilon, double* Zeta) const;

  // Calculate gray value moments and approximation by a second order surface.
  double FitSurfaceSecondOrder(const HRegion& Regions, const char* Algorithm, Hlong Iterations, double ClippingFactor, double* Beta, double* Gamma, double* Delta, double* Epsilon, double* Zeta) const;

  // Create a curved gray surface with second order polynomial.
  void GenImageSurfaceSecondOrder(const HString& Type, double Alpha, double Beta, double Gamma, double Delta, double Epsilon, double Zeta, double Row, double Column, Hlong Width, Hlong Height);

  // Create a curved gray surface with second order polynomial.
  void GenImageSurfaceSecondOrder(const char* Type, double Alpha, double Beta, double Gamma, double Delta, double Epsilon, double Zeta, double Row, double Column, Hlong Width, Hlong Height);

  // Create a tilted gray surface with first order polynomial.
  void GenImageSurfaceFirstOrder(const HString& Type, double Alpha, double Beta, double Gamma, double Row, double Column, Hlong Width, Hlong Height);

  // Create a tilted gray surface with first order polynomial.
  void GenImageSurfaceFirstOrder(const char* Type, double Alpha, double Beta, double Gamma, double Row, double Column, Hlong Width, Hlong Height);

  // Determine the minimum and maximum gray values within regions.
  void MinMaxGray(const HRegion& Regions, const HTuple& Percent, HTuple* Min, HTuple* Max, HTuple* Range) const;

  // Determine the minimum and maximum gray values within regions.
  void MinMaxGray(const HRegion& Regions, double Percent, double* Min, double* Max, double* Range) const;

  // Calculate the mean and deviation of gray values.
  HTuple Intensity(const HRegion& Regions, HTuple* Deviation) const;

  // Calculate the mean and deviation of gray values.
  double Intensity(const HRegion& Regions, double* Deviation) const;

  // Calculate the gray value distribution of a single channel image within a certain gray value range.
  HTuple GrayHistoRange(const HRegion& Regions, const HTuple& Min, const HTuple& Max, Hlong NumBins, double* BinSize) const;

  // Calculate the gray value distribution of a single channel image within a certain gray value range.
  Hlong GrayHistoRange(const HRegion& Regions, double Min, double Max, Hlong NumBins, double* BinSize) const;

  // Calculate the histogram of two-channel gray value images.
  HImage Histo2dim(const HRegion& Regions, const HImage& ImageRow) const;

  // Calculate the gray value distribution.
  HTuple GrayHistoAbs(const HRegion& Regions, const HTuple& Quantization) const;

  // Calculate the gray value distribution.
  HTuple GrayHistoAbs(const HRegion& Regions, double Quantization) const;

  // Calculate the gray value distribution.
  HTuple GrayHisto(const HRegion& Regions, HTuple* RelativeHisto) const;

  // Determine the entropy and anisotropy of images.
  HTuple EntropyGray(const HRegion& Regions, HTuple* Anisotropy) const;

  // Determine the entropy and anisotropy of images.
  double EntropyGray(const HRegion& Regions, double* Anisotropy) const;

  // Calculate gray value features from a co-occurrence matrix.
  double CoocFeatureMatrix(double* Correlation, double* Homogeneity, double* Contrast) const;

  // Calculate a co-occurrence matrix and derive gray value features thereof.
  HTuple CoocFeatureImage(const HRegion& Regions, Hlong LdGray, const HTuple& Direction, HTuple* Correlation, HTuple* Homogeneity, HTuple* Contrast) const;

  // Calculate a co-occurrence matrix and derive gray value features thereof.
  double CoocFeatureImage(const HRegion& Regions, Hlong LdGray, Hlong Direction, double* Correlation, double* Homogeneity, double* Contrast) const;

  // Calculate the co-occurrence matrix of a region in an image.
  HImage GenCoocMatrix(const HRegion& Regions, Hlong LdGray, Hlong Direction) const;

  // Calculate gray value moments and approximation by a plane.
  void MomentsGrayPlane(const HRegion& Regions, HTuple* MRow, HTuple* MCol, HTuple* Alpha, HTuple* Beta, HTuple* Mean) const;

  // Calculate gray value moments and approximation by a plane.
  void MomentsGrayPlane(const HRegion& Regions, double* MRow, double* MCol, double* Alpha, double* Beta, double* Mean) const;

  // Calculate the deviation of the gray values from the approximating image plane.
  HTuple PlaneDeviation(const HRegion& Regions) const;

  // Compute the orientation and major axes of a region in a gray value image.
  HTuple EllipticAxisGray(const HRegion& Regions, HTuple* Rb, HTuple* Phi) const;

  // Compute the orientation and major axes of a region in a gray value image.
  double EllipticAxisGray(const HRegion& Regions, double* Rb, double* Phi) const;

  // Compute the area and center of gravity of a region in a gray value image.
  HTuple AreaCenterGray(const HRegion& Regions, HTuple* Row, HTuple* Column) const;

  // Compute the area and center of gravity of a region in a gray value image.
  double AreaCenterGray(const HRegion& Regions, double* Row, double* Column) const;

  // Calculate horizontal and vertical gray-value projections.
  HTuple GrayProjections(const HRegion& Region, const HString& Mode, HTuple* VertProjection) const;

  // Calculate horizontal and vertical gray-value projections.
  HTuple GrayProjections(const HRegion& Region, const char* Mode, HTuple* VertProjection) const;

  // Detect and read 2D data code symbols in an image or train the 2D data code model.
  HXLDCont FindDataCode2d(const HDataCode2D& DataCodeHandle, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* ResultHandles, HTuple* DecodedDataStrings) const;

  // Detect and read 2D data code symbols in an image or train the 2D data code model.
  HXLDCont FindDataCode2d(const HDataCode2D& DataCodeHandle, const HString& GenParamNames, Hlong GenParamValues, Hlong* ResultHandles, HString* DecodedDataStrings) const;

  // Detect and read 2D data code symbols in an image or train the 2D data code model.
  HXLDCont FindDataCode2d(const HDataCode2D& DataCodeHandle, const char* GenParamNames, Hlong GenParamValues, Hlong* ResultHandles, HString* DecodedDataStrings) const;

  // Convert image maps into other map types.
  HImage ConvertMapType(const HString& NewType, const HTuple& ImageWidth) const;

  // Convert image maps into other map types.
  HImage ConvertMapType(const HString& NewType, Hlong ImageWidth) const;

  // Convert image maps into other map types.
  HImage ConvertMapType(const char* NewType, Hlong ImageWidth) const;

  // Compute an absolute pose out of point correspondences between world and image coordinates.
  static HPose VectorToPose(const HTuple& WorldX, const HTuple& WorldY, const HTuple& WorldZ, const HTuple& ImageRow, const HTuple& ImageColumn, const HTuple& CameraParam, const HString& Method, const HTuple& QualityType, HTuple* Quality);

  // Compute an absolute pose out of point correspondences between world and image coordinates.
  static HPose VectorToPose(const HTuple& WorldX, const HTuple& WorldY, const HTuple& WorldZ, const HTuple& ImageRow, const HTuple& ImageColumn, const HTuple& CameraParam, const HString& Method, const HString& QualityType, double* Quality);

  // Compute an absolute pose out of point correspondences between world and image coordinates.
  static HPose VectorToPose(const HTuple& WorldX, const HTuple& WorldY, const HTuple& WorldZ, const HTuple& ImageRow, const HTuple& ImageColumn, const HTuple& CameraParam, const char* Method, const char* QualityType, double* Quality);

  // Compute a pose out of a homography describing the relation between world and image coordinates.
  static HPose ProjHomMat2dToPose(const HHomMat2D& Homography, const HHomMat2D& CameraMatrix, const HString& Method);

  // Compute a pose out of a homography describing the relation between world and image coordinates.
  static HPose ProjHomMat2dToPose(const HHomMat2D& Homography, const HHomMat2D& CameraMatrix, const char* Method);

  // Perform a radiometric self-calibration of a camera.
  HTuple RadiometricSelfCalibration(const HTuple& ExposureRatios, const HString& Features, const HString& FunctionType, double Smoothness, Hlong PolynomialDegree) const;

  // Perform a radiometric self-calibration of a camera.
  HTuple RadiometricSelfCalibration(double ExposureRatios, const HString& Features, const HString& FunctionType, double Smoothness, Hlong PolynomialDegree) const;

  // Perform a radiometric self-calibration of a camera.
  HTuple RadiometricSelfCalibration(double ExposureRatios, const char* Features, const char* FunctionType, double Smoothness, Hlong PolynomialDegree) const;

  // Apply a general transformation to an image.
  HImage MapImage(const HImage& Map) const;

  // Generate a projection map that describes the mapping of images corresponding to a changing radial distortion.
  void GenRadialDistortionMap(const HTuple& CamParamIn, const HTuple& CamParamOut, const HString& MapType);

  // Generate a projection map that describes the mapping of images corresponding to a changing radial distortion.
  void GenRadialDistortionMap(const HTuple& CamParamIn, const HTuple& CamParamOut, const char* MapType);

  // Generate a projection map that describes the mapping between the image plane and a the plane z=0 of a world coordinate system.
  void GenImageToWorldPlaneMap(const HTuple& CameraParam, const HPose& WorldPose, Hlong WidthIn, Hlong HeightIn, Hlong WidthMapped, Hlong HeightMapped, const HTuple& Scale, const HString& MapType);

  // Generate a projection map that describes the mapping between the image plane and a the plane z=0 of a world coordinate system.
  void GenImageToWorldPlaneMap(const HTuple& CameraParam, const HPose& WorldPose, Hlong WidthIn, Hlong HeightIn, Hlong WidthMapped, Hlong HeightMapped, const HString& Scale, const HString& MapType);

  // Generate a projection map that describes the mapping between the image plane and a the plane z=0 of a world coordinate system.
  void GenImageToWorldPlaneMap(const HTuple& CameraParam, const HPose& WorldPose, Hlong WidthIn, Hlong HeightIn, Hlong WidthMapped, Hlong HeightMapped, const char* Scale, const char* MapType);

  // Rectify an image by transforming it into the plane z=0 of a world  coordinate system.
  HImage ImageToWorldPlane(const HTuple& CameraParam, const HPose& WorldPose, Hlong Width, Hlong Height, const HTuple& Scale, const HString& Interpolation) const;

  // Rectify an image by transforming it into the plane z=0 of a world  coordinate system.
  HImage ImageToWorldPlane(const HTuple& CameraParam, const HPose& WorldPose, Hlong Width, Hlong Height, const HString& Scale, const HString& Interpolation) const;

  // Rectify an image by transforming it into the plane z=0 of a world  coordinate system.
  HImage ImageToWorldPlane(const HTuple& CameraParam, const HPose& WorldPose, Hlong Width, Hlong Height, const char* Scale, const char* Interpolation) const;

  // Change the radial distortion of pixel coordinates.
  static void ChangeRadialDistortionPoints(const HTuple& Row, const HTuple& Col, const HTuple& CamParamIn, const HTuple& CamParamOut, HTuple* RowChanged, HTuple* ColChanged);

  // Change the radial distortion of an image.
  HImage ChangeRadialDistortionImage(const HRegion& Region, const HTuple& CamParamIn, const HTuple& CamParamOut) const;

  // Simulate an image with calibration plate.
  void SimCaltab(const HString& CalPlateDescr, const HTuple& CameraParam, const HPose& CalPlatePose, Hlong GrayBackground, Hlong GrayPlate, Hlong GrayMarks, double ScaleFac);

  // Simulate an image with calibration plate.
  void SimCaltab(const char* CalPlateDescr, const HTuple& CameraParam, const HPose& CalPlatePose, Hlong GrayBackground, Hlong GrayPlate, Hlong GrayMarks, double ScaleFac);

  // Extract rectangularly arranged 2D calibration marks from the image and calculate initial values for the external camera parameters.
  HTuple FindMarksAndPose(const HRegion& CalPlateRegion, const HString& CalPlateDescr, const HTuple& StartCamParam, Hlong StartThresh, Hlong DeltaThresh, Hlong MinThresh, double Alpha, double MinContLength, double MaxDiamMarks, HTuple* CCoord, HPose* StartPose) const;

  // Extract rectangularly arranged 2D calibration marks from the image and calculate initial values for the external camera parameters.
  HTuple FindMarksAndPose(const HRegion& CalPlateRegion, const char* CalPlateDescr, const HTuple& StartCamParam, Hlong StartThresh, Hlong DeltaThresh, Hlong MinThresh, double Alpha, double MinContLength, double MaxDiamMarks, HTuple* CCoord, HPose* StartPose) const;

  // Segment the region of a standard calibration plate with rectangularly arranged marks in the image.
  HRegion FindCaltab(const HString& CalPlateDescr, const HTuple& SizeGauss, const HTuple& MarkThresh, Hlong MinDiamMarks) const;

  // Segment the region of a standard calibration plate with rectangularly arranged marks in the image.
  HRegion FindCaltab(const HString& CalPlateDescr, Hlong SizeGauss, Hlong MarkThresh, Hlong MinDiamMarks) const;

  // Segment the region of a standard calibration plate with rectangularly arranged marks in the image.
  HRegion FindCaltab(const char* CalPlateDescr, Hlong SizeGauss, Hlong MarkThresh, Hlong MinDiamMarks) const;

  // Decode bar code symbols within a rectangle.
  HTuple DecodeBarCodeRectangle2(const HBarCode& BarCodeHandle, const HTuple& CodeType, const HTuple& Row, const HTuple& Column, const HTuple& Phi, const HTuple& Length1, const HTuple& Length2) const;

  // Decode bar code symbols within a rectangle.
  HString DecodeBarCodeRectangle2(const HBarCode& BarCodeHandle, const HString& CodeType, double Row, double Column, double Phi, double Length1, double Length2) const;

  // Decode bar code symbols within a rectangle.
  HString DecodeBarCodeRectangle2(const HBarCode& BarCodeHandle, const char* CodeType, double Row, double Column, double Phi, double Length1, double Length2) const;

  // Detect and read bar code symbols in an image.
  HRegion FindBarCode(const HBarCode& BarCodeHandle, const HTuple& CodeType, HTuple* DecodedDataStrings) const;

  // Detect and read bar code symbols in an image.
  HRegion FindBarCode(const HBarCode& BarCodeHandle, const HString& CodeType, HString* DecodedDataStrings) const;

  // Detect and read bar code symbols in an image.
  HRegion FindBarCode(const HBarCode& BarCodeHandle, const char* CodeType, HString* DecodedDataStrings) const;

  // Extract the data values of the elements (in ECC 200: "modules") inside a bar code region ("Data Matrix symbol") and their positions in the image.
  HTuple Get2dBarCodePos(const HRegion& BarCodeRegion, const HTuple& BarCodeDescr, const HTuple& CodeRegDescr, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* BarCodeData, HTuple* DataElementRow, HTuple* DataElementCol) const;

  // Extract the values of the data elements (in ECC 200: "modules") inside a bar code region ("Data Matrix symbol").
  HTuple Get2dBarCode(const HRegion& BarCodeRegion, const HTuple& BarCodeDescr, const HTuple& CodeRegDescr, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* BarCodeData) const;

  // Find regions that might contain a 2D bar code.
  HRegion Find2dBarCode(const HTuple& BarCodeDescr, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* CodeRegDescr) const;

  // Find regions that might contain a 2D bar code.
  HRegion Find2dBarCode(const HTuple& BarCodeDescr, const HString& GenParamNames, double GenParamValues, HTuple* CodeRegDescr) const;

  // Find regions that might contain a 2D bar code.
  HRegion Find2dBarCode(const HTuple& BarCodeDescr, const char* GenParamNames, double GenParamValues, HTuple* CodeRegDescr) const;

  // Extract the widths of the elements inside a bar code region.
  HTuple Get1dBarCodeScanline(const HTuple& BarCodeDescr, const HTuple& GenericName, const HTuple& GenericValue, double Orientation, const HString& StopIfFound, HTuple* ScanlineNumPoints, HTuple* ScanlineDecoded, HTuple* ScanlinePointsRow, HTuple* ScanlinePointsColumn) const;

  // Extract the widths of the elements inside a bar code region.
  HTuple Get1dBarCodeScanline(const HTuple& BarCodeDescr, const HString& GenericName, double GenericValue, double Orientation, const HString& StopIfFound, Hlong* ScanlineNumPoints, Hlong* ScanlineDecoded, double* ScanlinePointsRow, double* ScanlinePointsColumn) const;

  // Extract the widths of the elements inside a bar code region.
  HTuple Get1dBarCodeScanline(const HTuple& BarCodeDescr, const char* GenericName, double GenericValue, double Orientation, const char* StopIfFound, Hlong* ScanlineNumPoints, Hlong* ScanlineDecoded, double* ScanlinePointsRow, double* ScanlinePointsColumn) const;

  // Extract the widths of the elements inside a bar code region.
  HTuple Get1dBarCode(const HTuple& BarCodeDescr, const HTuple& GenericName, const HTuple& GenericValue, double Orientation) const;

  // Extract the widths of the elements inside a bar code region.
  HTuple Get1dBarCode(const HTuple& BarCodeDescr, const HString& GenericName, double GenericValue, double Orientation) const;

  // Extract the widths of the elements inside a bar code region.
  HTuple Get1dBarCode(const HTuple& BarCodeDescr, const char* GenericName, double GenericValue, double Orientation) const;

  // Look for multiple bar code regions in an image.
  HRegion Find1dBarCodeRegion(const HTuple& BarCodeDescr, const HTuple& GenericName, const HTuple& GenericValue, HTuple* Orientation) const;

  // Look for multiple bar code regions in an image.
  HRegion Find1dBarCodeRegion(const HTuple& BarCodeDescr, const HString& GenericName, double GenericValue, double* Orientation) const;

  // Look for multiple bar code regions in an image.
  HRegion Find1dBarCodeRegion(const HTuple& BarCodeDescr, const char* GenericName, double GenericValue, double* Orientation) const;

  // Look for one bar code in an image.
  HRegion Find1dBarCodeScanline(const HTuple& BarCodeDescr, const HTuple& GenericName, const HTuple& GenericValue, const HString& StopIfFound, Hlong* BarcodeFound, HTuple* BarCodeElements, double* Orientation, HTuple* ScanlineNumPoints, HTuple* ScanlineDecoded, HTuple* ScanlinePointsRow, HTuple* ScanlinePointsColumn) const;

  // Look for one bar code in an image.
  HRegion Find1dBarCodeScanline(const HTuple& BarCodeDescr, const HString& GenericName, double GenericValue, const HString& StopIfFound, Hlong* BarcodeFound, HTuple* BarCodeElements, double* Orientation, Hlong* ScanlineNumPoints, Hlong* ScanlineDecoded, double* ScanlinePointsRow, double* ScanlinePointsColumn) const;

  // Look for one bar code in an image.
  HRegion Find1dBarCodeScanline(const HTuple& BarCodeDescr, const char* GenericName, double GenericValue, const char* StopIfFound, Hlong* BarcodeFound, HTuple* BarCodeElements, double* Orientation, Hlong* ScanlineNumPoints, Hlong* ScanlineDecoded, double* ScanlinePointsRow, double* ScanlinePointsColumn) const;

  // Look for one bar code in an image.
  HRegion Find1dBarCode(const HTuple& BarCodeDescr, const HTuple& GenericName, const HTuple& GenericValue, Hlong* BarcodeFound, HTuple* BarCodeElements, double* Orientation) const;

  // Look for one bar code in an image.
  HRegion Find1dBarCode(const HTuple& BarCodeDescr, const HString& GenericName, double GenericValue, Hlong* BarcodeFound, HTuple* BarCodeElements, double* Orientation) const;

  // Look for one bar code in an image.
  HRegion Find1dBarCode(const HTuple& BarCodeDescr, const char* GenericName, double GenericValue, Hlong* BarcodeFound, HTuple* BarCodeElements, double* Orientation) const;

  // Return the estimated background image.
  void GiveBgEsti(const HBgEsti& BgEstiHandle);

  // Change the estimated background image.
  void UpdateBgEsti(const HRegion& UpDateRegion, const HBgEsti& BgEstiHandle) const;

  // Estimate the background and return the foreground region.
  HRegion RunBgEsti(const HBgEsti& BgEstiHandle) const;

  // Generate and initialize a data set for the background estimation.
  HBgEsti CreateBgEsti(double Syspar1, double Syspar2, const HString& GainMode, double Gain1, double Gain2, const HString& AdaptMode, double MinDiff, Hlong StatNum, double ConfidenceC, double TimeC) const;

  // Generate and initialize a data set for the background estimation.
  HBgEsti CreateBgEsti(double Syspar1, double Syspar2, const char* GainMode, double Gain1, double Gain2, const char* AdaptMode, double MinDiff, Hlong StatNum, double ConfidenceC, double TimeC) const;

  // Asynchronous grab of images and preprocessed image data from the specified image acquisition device.
  HRegion GrabDataAsync(HXLDCont* Contours, const HFramegrabber& AcqHandle, double MaxDelay, HTuple* Data);

  // Asynchronous grab of images and preprocessed image data from the specified image acquisition device.
  HRegion GrabDataAsync(HXLDCont* Contours, const HFramegrabber& AcqHandle, double MaxDelay, HString* Data);

  // Synchronous grab of images and preprocessed image data from the specified image acquisition device.
  HRegion GrabData(HXLDCont* Contours, const HFramegrabber& AcqHandle, HTuple* Data);

  // Synchronous grab of images and preprocessed image data from the specified image acquisition device.
  HRegion GrabData(HXLDCont* Contours, const HFramegrabber& AcqHandle, HString* Data);

  // Asynchronous grab of an image from the specified image acquisition device.
  void GrabImageAsync(const HFramegrabber& AcqHandle, double MaxDelay);

  // Synchronous grab of an image from the specified image acquisition device.
  void GrabImage(const HFramegrabber& AcqHandle);

private:

  // Verify matching semantic type ('image')!
  void AssertObjectClass();

};

}

#endif
