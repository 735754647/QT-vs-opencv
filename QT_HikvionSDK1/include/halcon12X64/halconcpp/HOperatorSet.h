/***********************************************************
 * File generated by the HALCON-Compiler hcomp version 12.0
 * Usage: Interface to C++
 *
 * Software by: MVTec Software GmbH, www.mvtec.com
 ***********************************************************/


#ifndef HCPP_HOPERATORSET
#define HCPP_HOPERATORSET

namespace HalconCpp
{




  /***************************************************************************
   * Operators                                                               *
   ***************************************************************************/

// Compute the union of cotangential contours.
LIntExport void UnionCotangentialContoursXld(const HObject& Contours, HObject* UnionContours, const HTuple& FitClippingLength, const HTuple& FitLength, const HTuple& MaxTangAngle, const HTuple& MaxDist, const HTuple& MaxDistPerp, const HTuple& MaxOverlap, const HTuple& Mode);

// Transform a contour in polar coordinates back to cartesian coordinates
LIntExport void PolarTransContourXldInv(const HObject& PolarContour, HObject* XYTransContour, const HTuple& Row, const HTuple& Column, const HTuple& AngleStart, const HTuple& AngleEnd, const HTuple& RadiusStart, const HTuple& RadiusEnd, const HTuple& WidthIn, const HTuple& HeightIn, const HTuple& Width, const HTuple& Height);

// Transform a contour in an annular arc to polar coordinates.
LIntExport void PolarTransContourXld(const HObject& Contour, HObject* PolarTransContour, const HTuple& Row, const HTuple& Column, const HTuple& AngleStart, const HTuple& AngleEnd, const HTuple& RadiusStart, const HTuple& RadiusEnd, const HTuple& Width, const HTuple& Height);

// Create control data of a NURBS curve that interpolates given points.
LIntExport void GenNurbsInterp(const HTuple& Rows, const HTuple& Cols, const HTuple& Tangents, const HTuple& Degree, HTuple* CtrlRows, HTuple* CtrlCols, HTuple* Knots);

// Transform a NURBS curve into an XLD contour.
LIntExport void GenContourNurbsXld(HObject* Contour, const HTuple& Rows, const HTuple& Cols, const HTuple& Knots, const HTuple& Weights, const HTuple& Degree, const HTuple& MaxError, const HTuple& MaxDistance);

// Compute the union of closed polygons.
LIntExport void Union2ClosedPolygonsXld(const HObject& Polygons1, const HObject& Polygons2, HObject* PolygonsUnion);

// Compute the union of closed contours.
LIntExport void Union2ClosedContoursXld(const HObject& Contours1, const HObject& Contours2, HObject* ContoursUnion);

// Compute the symmetric difference of closed polygons.
LIntExport void SymmDifferenceClosedPolygonsXld(const HObject& Polygons1, const HObject& Polygons2, HObject* PolygonsDifference);

// Compute the symmetric difference of closed contours.
LIntExport void SymmDifferenceClosedContoursXld(const HObject& Contours1, const HObject& Contours2, HObject* ContoursDifference);

// Compute the difference of closed polygons.
LIntExport void DifferenceClosedPolygonsXld(const HObject& Polygons, const HObject& Sub, HObject* PolygonsDifference);

// Compute the difference of closed contours.
LIntExport void DifferenceClosedContoursXld(const HObject& Contours, const HObject& Sub, HObject* ContoursDifference);

// Intersect closed polygons.
LIntExport void IntersectionClosedPolygonsXld(const HObject& Polygons1, const HObject& Polygons2, HObject* PolygonsIntersection);

// Intersect closed contours.
LIntExport void IntersectionClosedContoursXld(const HObject& Contours1, const HObject& Contours2, HObject* ContoursIntersection);

// Compute the union of contours that belong to the same circle.
LIntExport void UnionCocircularContoursXld(const HObject& Contours, HObject* UnionContours, const HTuple& MaxArcAngleDiff, const HTuple& MaxArcOverlap, const HTuple& MaxTangentAngle, const HTuple& MaxDist, const HTuple& MaxRadiusDiff, const HTuple& MaxCenterDist, const HTuple& MergeSmallContours, const HTuple& Iterations);

// Crop an XLD contour.
LIntExport void CropContoursXld(const HObject& Contours, HObject* CroppedContours, const HTuple& Row1, const HTuple& Col1, const HTuple& Row2, const HTuple& Col2, const HTuple& CloseContours);

// Generate one XLD contour in the shape of a cross for each input point.
LIntExport void GenCrossContourXld(HObject* Cross, const HTuple& Row, const HTuple& Col, const HTuple& Size, const HTuple& Angle);

// Sort contours with respect to their relative position.
LIntExport void SortContoursXld(const HObject& Contours, HObject* SortedContours, const HTuple& SortMode, const HTuple& Order, const HTuple& RowOrCol);

// Merge XLD contours from successive line scan images.
LIntExport void MergeContLineScanXld(const HObject& CurrConts, const HObject& PrevConts, HObject* CurrMergedConts, HObject* PrevMergedConts, const HTuple& ImageHeight, const HTuple& Margin, const HTuple& MergeBorder, const HTuple& MaxImagesCont);

// Read XLD polygons from a file in ARC/INFO generate format.
LIntExport void ReadPolygonXldArcInfo(HObject* Polygons, const HTuple& FileName);

// Write XLD polygons to a file in ARC/INFO generate format.
LIntExport void WritePolygonXldArcInfo(const HObject& Polygons, const HTuple& FileName);

// Read XLD contours to a file in ARC/INFO generate format.
LIntExport void ReadContourXldArcInfo(HObject* Contours, const HTuple& FileName);

// Write XLD contours to a file in ARC/INFO generate format.
LIntExport void WriteContourXldArcInfo(const HObject& Contours, const HTuple& FileName);

// Read the geo coding from an ARC/INFO world file.
LIntExport void ReadWorldFile(const HTuple& FileName, HTuple* WorldTransformation);

// Compute the parallel contour of an XLD contour.
LIntExport void GenParallelContourXld(const HObject& Contours, HObject* ParallelContours, const HTuple& Mode, const HTuple& Distance);

// Create an XLD contour in the shape of a rectangle.
LIntExport void GenRectangle2ContourXld(HObject* Rectangle, const HTuple& Row, const HTuple& Column, const HTuple& Phi, const HTuple& Length1, const HTuple& Length2);

// Compute the distances of all contour points to a rectangle.
LIntExport void DistRectangle2ContourPointsXld(const HObject& Contour, const HTuple& ClippingEndPoints, const HTuple& Row, const HTuple& Column, const HTuple& Phi, const HTuple& Length1, const HTuple& Length2, HTuple* Distances);

// Fit rectangles to XLD contours.
LIntExport void FitRectangle2ContourXld(const HObject& Contours, const HTuple& Algorithm, const HTuple& MaxNumPoints, const HTuple& MaxClosureDist, const HTuple& ClippingEndPoints, const HTuple& Iterations, const HTuple& ClippingFactor, HTuple* Row, HTuple* Column, HTuple* Phi, HTuple* Length1, HTuple* Length2, HTuple* PointOrder);

// Segment XLD contour parts whose local attributes fulfill given  conditions.
LIntExport void SegmentContourAttribXld(const HObject& Contour, HObject* ContourPart, const HTuple& Attribute, const HTuple& Operation, const HTuple& Min, const HTuple& Max);

// Segment XLD contours into line segments and circular or elliptic arcs.
LIntExport void SegmentContoursXld(const HObject& Contours, HObject* ContoursSplit, const HTuple& Mode, const HTuple& SmoothCont, const HTuple& MaxLineDist1, const HTuple& MaxLineDist2);

// Approximate XLD contours by circles.
LIntExport void FitCircleContourXld(const HObject& Contours, const HTuple& Algorithm, const HTuple& MaxNumPoints, const HTuple& MaxClosureDist, const HTuple& ClippingEndPoints, const HTuple& Iterations, const HTuple& ClippingFactor, HTuple* Row, HTuple* Column, HTuple* Radius, HTuple* StartPhi, HTuple* EndPhi, HTuple* PointOrder);

// Approximate XLD contours by line segments.
LIntExport void FitLineContourXld(const HObject& Contours, const HTuple& Algorithm, const HTuple& MaxNumPoints, const HTuple& ClippingEndPoints, const HTuple& Iterations, const HTuple& ClippingFactor, HTuple* RowBegin, HTuple* ColBegin, HTuple* RowEnd, HTuple* ColEnd, HTuple* Nr, HTuple* Nc, HTuple* Dist);

// Compute the distances of all contour points to an ellipse.
LIntExport void DistEllipseContourPointsXld(const HObject& Contour, const HTuple& DistanceMode, const HTuple& ClippingEndPoints, const HTuple& Row, const HTuple& Column, const HTuple& Phi, const HTuple& Radius1, const HTuple& Radius2, HTuple* Distances);

// Compute the distance of contours to an ellipse.
LIntExport void DistEllipseContourXld(const HObject& Contours, const HTuple& Mode, const HTuple& MaxNumPoints, const HTuple& ClippingEndPoints, const HTuple& Row, const HTuple& Column, const HTuple& Phi, const HTuple& Radius1, const HTuple& Radius2, HTuple* MinDist, HTuple* MaxDist, HTuple* AvgDist, HTuple* SigmaDist);

// Approximate XLD contours by ellipses or elliptic arcs.
LIntExport void FitEllipseContourXld(const HObject& Contours, const HTuple& Algorithm, const HTuple& MaxNumPoints, const HTuple& MaxClosureDist, const HTuple& ClippingEndPoints, const HTuple& VossTabSize, const HTuple& Iterations, const HTuple& ClippingFactor, HTuple* Row, HTuple* Column, HTuple* Phi, HTuple* Radius1, HTuple* Radius2, HTuple* StartPhi, HTuple* EndPhi, HTuple* PointOrder);

// Create XLD contours corresponding to circles or circular arcs.
LIntExport void GenCircleContourXld(HObject* ContCircle, const HTuple& Row, const HTuple& Column, const HTuple& Radius, const HTuple& StartPhi, const HTuple& EndPhi, const HTuple& PointOrder, const HTuple& Resolution);

// Create an XLD contour that corresponds to an elliptic arc.
LIntExport void GenEllipseContourXld(HObject* ContEllipse, const HTuple& Row, const HTuple& Column, const HTuple& Phi, const HTuple& Radius1, const HTuple& Radius2, const HTuple& StartPhi, const HTuple& EndPhi, const HTuple& PointOrder, const HTuple& Resolution);

// Add noise to XLD contours.
LIntExport void AddNoiseWhiteContourXld(const HObject& Contours, HObject* NoisyContours, const HTuple& NumRegrPoints, const HTuple& Amp);

// Combine road hypotheses from two resolution levels.
LIntExport void CombineRoadsXld(const HObject& EdgePolygons, const HObject& ModParallels, const HObject& ExtParallels, const HObject& CenterLines, HObject* RoadSides, const HTuple& MaxAngleParallel, const HTuple& MaxAngleColinear, const HTuple& MaxDistanceParallel, const HTuple& MaxDistanceColinear);

// Join modified XLD parallels lying on the same polygon.
LIntExport void MaxParallelsXld(const HObject& ExtParallels, HObject* MaxPolygons);

// Extract parallel XLD polygons enclosing a homogeneous area.
LIntExport void ModParallelsXld(const HObject& Parallels, const HObject& Image, HObject* ModParallels, HObject* ExtParallels, const HTuple& Quality, const HTuple& MinGray, const HTuple& MaxGray, const HTuple& MaxStandard);

// Return information about the gray values of the area enclosed by XLD parallels.
LIntExport void InfoParallelsXld(const HObject& Parallels, const HObject& Image, HTuple* QualityMin, HTuple* QualityMax, HTuple* GrayMin, HTuple* GrayMax, HTuple* StandardMin, HTuple* StandardMax);

// Return an XLD parallel's data (as lines).
LIntExport void GetParallelsXld(const HObject& Parallels, HTuple* Row1, HTuple* Col1, HTuple* Length1, HTuple* Phi1, HTuple* Row2, HTuple* Col2, HTuple* Length2, HTuple* Phi2);

// Extract parallel XLD polygons.
LIntExport void GenParallelsXld(const HObject& Polygons, HObject* Parallels, const HTuple& Len, const HTuple& Dist, const HTuple& Alpha, const HTuple& Merge);

// Return an XLD polygon's data (as lines).
LIntExport void GetLinesXld(const HObject& Polygon, HTuple* BeginRow, HTuple* BeginCol, HTuple* EndRow, HTuple* EndCol, HTuple* Length, HTuple* Phi);

// Return an XLD polygon's data.
LIntExport void GetPolygonXld(const HObject& Polygon, HTuple* Row, HTuple* Col, HTuple* Length, HTuple* Phi);

// Approximate XLD contours by polygons.
LIntExport void GenPolygonsXld(const HObject& Contours, HObject* Polygons, const HTuple& Type, const HTuple& Alpha);

// Split XLD contours at dominant points.
LIntExport void SplitContoursXld(const HObject& Polygons, HObject* Contours, const HTuple& Mode, const HTuple& Weight, const HTuple& Smooth);

// Apply a projective transformation to an XLD contour.
LIntExport void ProjectiveTransContourXld(const HObject& Contours, HObject* ContoursProjTrans, const HTuple& HomMat2D);

// Apply an arbitrary affine transformation to XLD polygons.
LIntExport void AffineTransPolygonXld(const HObject& Polygons, HObject* PolygonsAffinTrans, const HTuple& HomMat2D);

// Apply an arbitrary affine 2D transformation to XLD contours.
LIntExport void AffineTransContourXld(const HObject& Contours, HObject* ContoursAffinTrans, const HTuple& HomMat2D);

// Close an XLD contour.
LIntExport void CloseContoursXld(const HObject& Contours, HObject* ClosedContours);

// Clip the end points of an XLD contour.
LIntExport void ClipEndPointsContoursXld(const HObject& Contours, HObject* ClippedContours, const HTuple& Mode, const HTuple& Length);

// Clip an XLD contour.
LIntExport void ClipContoursXld(const HObject& Contours, HObject* ClippedContours, const HTuple& Row1, const HTuple& Column1, const HTuple& Row2, const HTuple& Column2);

// Select XLD contours with a local maximum of gray values.
LIntExport void LocalMaxContoursXld(const HObject& Contours, const HObject& Image, HObject* LocalMaxContours, const HTuple& MinPercent, const HTuple& MinDiff, const HTuple& Distance);

// Compute the union of neighboring straight contours that have a similar  distance from a given line.
LIntExport void UnionStraightContoursHistoXld(const HObject& Contours, HObject* UnionContours, HObject* SelectedContours, const HTuple& RefLineStartRow, const HTuple& RefLineStartColumn, const HTuple& RefLineEndRow, const HTuple& RefLineEndColumn, const HTuple& Width, const HTuple& MaxWidth, const HTuple& FilterSize, HTuple* HistoValues);

// Compute the union of neighboring straight contours that have a similar  direction.
LIntExport void UnionStraightContoursXld(const HObject& Contours, HObject* UnionContours, const HTuple& MaxDist, const HTuple& MaxDiff, const HTuple& Percent, const HTuple& Mode, const HTuple& Iterations);

// Compute the union of collinear contours  (operator with extended functionality).
LIntExport void UnionCollinearContoursExtXld(const HObject& Contours, HObject* UnionContours, const HTuple& MaxDistAbs, const HTuple& MaxDistRel, const HTuple& MaxShift, const HTuple& MaxAngle, const HTuple& MaxOverlap, const HTuple& MaxRegrError, const HTuple& MaxCosts, const HTuple& WeightDist, const HTuple& WeightShift, const HTuple& WeightAngle, const HTuple& WeightLink, const HTuple& WeightRegr, const HTuple& Mode);

// Unite approximately collinear contours.
LIntExport void UnionCollinearContoursXld(const HObject& Contours, HObject* UnionContours, const HTuple& MaxDistAbs, const HTuple& MaxDistRel, const HTuple& MaxShift, const HTuple& MaxAngle, const HTuple& Mode);

// Compute the union of contours whose end points are close together.
LIntExport void UnionAdjacentContoursXld(const HObject& Contours, HObject* UnionContours, const HTuple& MaxDistAbs, const HTuple& MaxDistRel, const HTuple& Mode);

// Select XLD contours according to several features.
LIntExport void SelectContoursXld(const HObject& Contours, HObject* SelectedContours, const HTuple& Feature, const HTuple& Min1, const HTuple& Max1, const HTuple& Min2, const HTuple& Max2);

// Return XLD contour parameters.
LIntExport void GetRegressParamsXld(const HObject& Contours, HTuple* Length, HTuple* Nx, HTuple* Ny, HTuple* Dist, HTuple* Fpx, HTuple* Fpy, HTuple* Lpx, HTuple* Lpy, HTuple* Mean, HTuple* Deviation);

// Calculate the parameters of a regression line to an XLD contour.
LIntExport void RegressContoursXld(const HObject& Contours, HObject* RegressContours, const HTuple& Mode, const HTuple& Iterations);

// Calculate the direction of an XLD contour for each contour point.
LIntExport void GetContourAngleXld(const HObject& Contour, const HTuple& AngleMode, const HTuple& CalcMode, const HTuple& Lookaround, HTuple* Angles);

// Smooth an XLD contour.
LIntExport void SmoothContoursXld(const HObject& Contours, HObject* SmoothedContours, const HTuple& NumRegrPoints);

// Return the number of points in an XLD contour.
LIntExport void ContourPointNumXld(const HObject& Contour, HTuple* Length);

// Return the names of the defined global attributes of an XLD contour.
LIntExport void QueryContourGlobalAttribsXld(const HObject& Contour, HTuple* Attribs);

// Return global attributes values of an XLD contour.
LIntExport void GetContourGlobalAttribXld(const HObject& Contour, const HTuple& Name, HTuple* Attrib);

// Return the names of the defined attributes of an XLD contour.
LIntExport void QueryContourAttribsXld(const HObject& Contour, HTuple* Attribs);

// Return point attribute values of an XLD contour.
LIntExport void GetContourAttribXld(const HObject& Contour, const HTuple& Name, HTuple* Attrib);

// Return the coordinates of an XLD contour.
LIntExport void GetContourXld(const HObject& Contour, HTuple* Row, HTuple* Col);

// Generate XLD contours from regions.
LIntExport void GenContourRegionXld(const HObject& Regions, HObject* Contours, const HTuple& Mode);

// Generate an XLD contour with rounded corners from a polygon (given as tuples).
LIntExport void GenContourPolygonRoundedXld(HObject* Contour, const HTuple& Row, const HTuple& Col, const HTuple& Radius, const HTuple& SamplingInterval);

// Generate an XLD contour from a polygon (given as tuples).
LIntExport void GenContourPolygonXld(HObject* Contour, const HTuple& Row, const HTuple& Col);

// Convert a skeleton into XLD contours.
LIntExport void GenContoursSkeletonXld(const HObject& Skeleton, HObject* Contours, const HTuple& Length, const HTuple& Mode);

// Display an XLD object.
LIntExport void DispXld(const HObject& XLDObject, const HTuple& WindowHandle);

// Image restoration by Wiener filtering.
LIntExport void WienerFilterNi(const HObject& Image, const HObject& Psf, const HObject& NoiseRegion, HObject* RestoredImage, const HTuple& MaskWidth, const HTuple& MaskHeight);

// Image restoration by Wiener filtering.
LIntExport void WienerFilter(const HObject& Image, const HObject& Psf, const HObject& FilteredImage, HObject* RestoredImage);

// Generate an impulse response of a (linearly) motion blurring.
LIntExport void GenPsfMotion(HObject* Psf, const HTuple& PSFwidth, const HTuple& PSFheight, const HTuple& Blurring, const HTuple& Angle, const HTuple& Type);

// Simulation of (linearly) motion blur.
LIntExport void SimulateMotion(const HObject& Image, HObject* MovedImage, const HTuple& Blurring, const HTuple& Angle, const HTuple& Type);

// Generate an impulse response of an uniform out-of-focus blurring.
LIntExport void GenPsfDefocus(HObject* Psf, const HTuple& PSFwidth, const HTuple& PSFheight, const HTuple& Blurring);

// Simulate an uniform out-of-focus blurring of an image.
LIntExport void SimulateDefocus(const HObject& Image, HObject* DefocusedImage, const HTuple& Blurring);

// Deserialize a variation model.
LIntExport void DeserializeVariationModel(const HTuple& SerializedItemHandle, HTuple* ModelID);

// Serialize a variation model.
LIntExport void SerializeVariationModel(const HTuple& ModelID, HTuple* SerializedItemHandle);

// Read a variation model from a file.
LIntExport void ReadVariationModel(const HTuple& FileName, HTuple* ModelID);

// Write a variation model to a file.
LIntExport void WriteVariationModel(const HTuple& ModelID, const HTuple& FileName);

// Return the threshold images used for image comparison by a variation model.
LIntExport void GetThreshImagesVariationModel(HObject* MinImage, HObject* MaxImage, const HTuple& ModelID);

// Return the images used for image comparison by a variation model.
LIntExport void GetVariationModel(HObject* Image, HObject* VarImage, const HTuple& ModelID);

// Compare an image to a variation model.
LIntExport void CompareExtVariationModel(const HObject& Image, HObject* Region, const HTuple& ModelID, const HTuple& Mode);

// Compare an image to a variation model.
LIntExport void CompareVariationModel(const HObject& Image, HObject* Region, const HTuple& ModelID);

// Prepare a variation model for comparison with an image.
LIntExport void PrepareDirectVariationModel(const HObject& RefImage, const HObject& VarImage, const HTuple& ModelID, const HTuple& AbsThreshold, const HTuple& VarThreshold);

// Prepare a variation model for comparison with an image.
LIntExport void PrepareVariationModel(const HTuple& ModelID, const HTuple& AbsThreshold, const HTuple& VarThreshold);

// Train a variation model.
LIntExport void TrainVariationModel(const HObject& Images, const HTuple& ModelID);

// Free the memory of all variation models.
LIntExport void ClearAllVariationModels();

// Free the memory of a variation model.
LIntExport void ClearVariationModel(const HTuple& ModelID);

// Free the memory of the training data of a variation model.
LIntExport void ClearTrainDataVariationModel(const HTuple& ModelID);

// Create a variation model for image comparison.
LIntExport void CreateVariationModel(const HTuple& Width, const HTuple& Height, const HTuple& Type, const HTuple& Mode, HTuple* ModelID);

// Compute the union set of two input tuples.
LIntExport void TupleUnion(const HTuple& Set1, const HTuple& Set2, HTuple* Union);

// Compute the intersection set of two input tuples.
LIntExport void TupleIntersection(const HTuple& Set1, const HTuple& Set2, HTuple* Intersection);

// Compute the difference set of two input tuples.
LIntExport void TupleDifference(const HTuple& Set1, const HTuple& Set2, HTuple* Difference);

// Compute the symmetric difference set of two input tuples.
LIntExport void TupleSymmdiff(const HTuple& Set1, const HTuple& Set2, HTuple* SymmDiff);

// Test whether the types of the elements of a tuple are of type string.
LIntExport void TupleIsStringElem(const HTuple& T, HTuple* IsString);

// Test whether the types of the elements of a tuple are of type real.
LIntExport void TupleIsRealElem(const HTuple& T, HTuple* IsReal);

// Test whether the types of the elements of a tuple are of type integer.
LIntExport void TupleIsIntElem(const HTuple& T, HTuple* IsInt);

// Return the types of the elements of a tuple.
LIntExport void TupleTypeElem(const HTuple& T, HTuple* Types);

// Test whether a tuple is of type mixed.
LIntExport void TupleIsMixed(const HTuple& T, HTuple* IsMixed);

// Test if the internal representation of a tuple is of type string.
LIntExport void TupleIsString(const HTuple& T, HTuple* IsString);

// Test if the internal representation of a tuple is of type real.
LIntExport void TupleIsReal(const HTuple& T, HTuple* IsReal);

// Test if the internal representation of a tuple is of type integer.
LIntExport void TupleIsInt(const HTuple& T, HTuple* IsInt);

// Return the type of a tuple.
LIntExport void TupleType(const HTuple& T, HTuple* Type);

// Calculate the value distribution of a tuple within a certain value range.
LIntExport void TupleHistoRange(const HTuple& Tuple, const HTuple& Min, const HTuple& Max, const HTuple& NumBins, HTuple* Histo, HTuple* BinSize);

// Select tuple elements matching a regular expression.
LIntExport void TupleRegexpSelect(const HTuple& Data, const HTuple& Expression, HTuple* Selection);

// Test if a string matches a regular expression.
LIntExport void TupleRegexpTest(const HTuple& Data, const HTuple& Expression, HTuple* NumMatches);

// Replace a substring using regular expressions.
LIntExport void TupleRegexpReplace(const HTuple& Data, const HTuple& Expression, const HTuple& Replace, HTuple* Result);

// Extract substrings using regular expressions.
LIntExport void TupleRegexpMatch(const HTuple& Data, const HTuple& Expression, HTuple* Matches);

// Return a tuple of random numbers between 0 and 1.
LIntExport void TupleRand(const HTuple& Length, HTuple* Rand);

// Return the number of elements of a tuple.
LIntExport void TupleLength(const HTuple& Tuple, HTuple* Length);

// Calculate the sign of a tuple.
LIntExport void TupleSgn(const HTuple& T, HTuple* Sgn);

// Calculate the elementwise maximum of two tuples.
LIntExport void TupleMax2(const HTuple& T1, const HTuple& T2, HTuple* Max2);

// Calculate the elementwise minimum of two tuples.
LIntExport void TupleMin2(const HTuple& T1, const HTuple& T2, HTuple* Min2);

// Return the maximal element of a tuple.
LIntExport void TupleMax(const HTuple& Tuple, HTuple* Max);

// Return the minimal element of a tuple.
LIntExport void TupleMin(const HTuple& Tuple, HTuple* Min);

// Calculate the cumulative sums of a tuple.
LIntExport void TupleCumul(const HTuple& Tuple, HTuple* Cumul);

// Select the element of rank n of a tuple.
LIntExport void TupleSelectRank(const HTuple& Tuple, const HTuple& RankIndex, HTuple* Selected);

// Return the median of the elements of a tuple.
LIntExport void TupleMedian(const HTuple& Tuple, HTuple* Median);

// Return the sum of all elements of a tuple.
LIntExport void TupleSum(const HTuple& Tuple, HTuple* Sum);

// Return the mean value of a tuple of numbers.
LIntExport void TupleMean(const HTuple& Tuple, HTuple* Mean);

// Return the standard deviation of the elements of a tuple.
LIntExport void TupleDeviation(const HTuple& Tuple, HTuple* Deviation);

// Discard all but one of successive identical elements of a tuple.
LIntExport void TupleUniq(const HTuple& Tuple, HTuple* Uniq);

// Return the index of the last occurence of a tuple within another tuple.
LIntExport void TupleFindLast(const HTuple& Tuple, const HTuple& ToFind, HTuple* Index);

// Return the index of the first occurrence of a tuple within another tuple.
LIntExport void TupleFindFirst(const HTuple& Tuple, const HTuple& ToFind, HTuple* Index);

// Return the indices of all occurrences of a tuple within another tuple.
LIntExport void TupleFind(const HTuple& Tuple, const HTuple& ToFind, HTuple* Indices);

// Sort the elements of a tuple and return the indices of the sorted tuple.
LIntExport void TupleSortIndex(const HTuple& Tuple, HTuple* Indices);

// Sort the elements of a tuple in ascending order.
LIntExport void TupleSort(const HTuple& Tuple, HTuple* Sorted);

// Invert a tuple.
LIntExport void TupleInverse(const HTuple& Tuple, HTuple* Inverted);

// Concatenate two tuples to a new one.
LIntExport void TupleConcat(const HTuple& T1, const HTuple& T2, HTuple* Concat);

// Select several elements of a tuple.
LIntExport void TupleSelectRange(const HTuple& Tuple, const HTuple& Leftindex, const HTuple& Rightindex, HTuple* Selected);

// Select all elements from index "n" to the end of a tuple.
LIntExport void TupleLastN(const HTuple& Tuple, const HTuple& Index, HTuple* Selected);

// Select the first elements of a tuple up to the index "n".
LIntExport void TupleFirstN(const HTuple& Tuple, const HTuple& Index, HTuple* Selected);

// Inserts one or more elements into a tuple at index.
LIntExport void TupleInsert(const HTuple& Tuple, const HTuple& Index, const HTuple& InsertTuple, HTuple* Extended);

// Replaces one or more elements of a tuple.
LIntExport void TupleReplace(const HTuple& Tuple, const HTuple& Index, const HTuple& ReplaceTuple, HTuple* Replaced);

// Remove elements from a tuple.
LIntExport void TupleRemove(const HTuple& Tuple, const HTuple& Index, HTuple* Reduced);

// Select in mask specified elements of a tuple.
LIntExport void TupleSelectMask(const HTuple& Tuple, const HTuple& Mask, HTuple* Selected);

// Select single elements of a tuple.
LIntExport void TupleSelect(const HTuple& Tuple, const HTuple& Index, HTuple* Selected);

// Select single character or bit from a tuple.
LIntExport void TupleStrBitSelect(const HTuple& Tuple, const HTuple& Index, HTuple* Selected);

// Generate a tuple with a sequence of equidistant values.
LIntExport void TupleGenSequence(const HTuple& Start, const HTuple& End, const HTuple& Step, HTuple* Sequence);

// Generate a tuple of a specific length and initialize its elements.
LIntExport void TupleGenConst(const HTuple& Length, const HTuple& Const, HTuple* Newtuple);

// Read one or more environment variables.
LIntExport void TupleEnvironment(const HTuple& Names, HTuple* Values);

// Split strings into substrings between predefined separator symbol(s).
LIntExport void TupleSplit(const HTuple& String, const HTuple& Separator, HTuple* Substrings);

// Cut characters from position "n1" through "n2" out of a string tuple.
LIntExport void TupleSubstr(const HTuple& String, const HTuple& Position1, const HTuple& Position2, HTuple* Substring);

// Cut all characters starting at position "n" out of a string tuple.
LIntExport void TupleStrLastN(const HTuple& String, const HTuple& Position, HTuple* Substring);

// Cut the first characters up to position "n" out of a string tuple.
LIntExport void TupleStrFirstN(const HTuple& String, const HTuple& Position, HTuple* Substring);

// Backward search for characters within a string tuple.
LIntExport void TupleStrrchr(const HTuple& String, const HTuple& ToFind, HTuple* Position);

// Forward search for characters within a string tuple.
LIntExport void TupleStrchr(const HTuple& String, const HTuple& ToFind, HTuple* Position);

// Backward search for strings within a string tuple.
LIntExport void TupleStrrstr(const HTuple& String, const HTuple& ToFind, HTuple* Position);

// Forward search for strings within a string tuple.
LIntExport void TupleStrstr(const HTuple& String, const HTuple& ToFind, HTuple* Position);

// Determine the length of every string within a tuple of strings.
LIntExport void TupleStrlen(const HTuple& T1, HTuple* Length);

// Test, whether a tuple is elementwise less or equal to another tuple.
LIntExport void TupleLessEqualElem(const HTuple& T1, const HTuple& T2, HTuple* Lesseq);

// Test, whether a tuple is elementwise less than another tuple.
LIntExport void TupleLessElem(const HTuple& T1, const HTuple& T2, HTuple* Less);

// Test, whether a tuple is elementwise greater or equal to another tuple.
LIntExport void TupleGreaterEqualElem(const HTuple& T1, const HTuple& T2, HTuple* Greatereq);

// Test, whether a tuple is elementwise greater than another tuple.
LIntExport void TupleGreaterElem(const HTuple& T1, const HTuple& T2, HTuple* Greater);

// Test, whether two tuples are elementwise not equal.
LIntExport void TupleNotEqualElem(const HTuple& T1, const HTuple& T2, HTuple* Nequal);

// Test, whether two tuples are elementwise equal.
LIntExport void TupleEqualElem(const HTuple& T1, const HTuple& T2, HTuple* Equal);

// Test whether a tuple is less or equal to another tuple.
LIntExport void TupleLessEqual(const HTuple& T1, const HTuple& T2, HTuple* Lesseq);

// Test whether a tuple is less than another tuple.
LIntExport void TupleLess(const HTuple& T1, const HTuple& T2, HTuple* Less);

// Test whether a tuple is greater or equal to another tuple.
LIntExport void TupleGreaterEqual(const HTuple& T1, const HTuple& T2, HTuple* Greatereq);

// Test whether a tuple is greater than another tuple.
LIntExport void TupleGreater(const HTuple& T1, const HTuple& T2, HTuple* Greater);

// Test whether two tuples are not equal.
LIntExport void TupleNotEqual(const HTuple& T1, const HTuple& T2, HTuple* Nequal);

// Test whether two tuples are equal.
LIntExport void TupleEqual(const HTuple& T1, const HTuple& T2, HTuple* Equal);

// Compute the logical not of a tuple.
LIntExport void TupleNot(const HTuple& T, HTuple* Not);

// Compute the logical exclusive or of two tuples.
LIntExport void TupleXor(const HTuple& T1, const HTuple& T2, HTuple* Xor);

// Compute the logical or of two tuples.
LIntExport void TupleOr(const HTuple& T1, const HTuple& T2, HTuple* Or);

// Compute the logical and of two tuples.
LIntExport void TupleAnd(const HTuple& T1, const HTuple& T2, HTuple* And);

// Compute the bitwise not of a tuple.
LIntExport void TupleBnot(const HTuple& T, HTuple* BNot);

// Compute the bitwise exclusive or of two tuples.
LIntExport void TupleBxor(const HTuple& T1, const HTuple& T2, HTuple* BXor);

// Compute the bitwise or of two tuples.
LIntExport void TupleBor(const HTuple& T1, const HTuple& T2, HTuple* BOr);

// Compute the bitwise and of two tuples.
LIntExport void TupleBand(const HTuple& T1, const HTuple& T2, HTuple* BAnd);

// Shift a tuple bitwise to the right.
LIntExport void TupleRsh(const HTuple& T, const HTuple& Shift, HTuple* Rsh);

// Shift a tuple bitwise to the left.
LIntExport void TupleLsh(const HTuple& T, const HTuple& Shift, HTuple* Lsh);

// Convert a tuple of integers into strings with the corresponding ASCII codes.
LIntExport void TupleChrt(const HTuple& T, HTuple* Chrt);

// Convert a tuple of strings into a tuple of their ASCII codes.
LIntExport void TupleOrds(const HTuple& T, HTuple* Ords);

// Convert a tuple of integers into strings with the corresponding ASCII codes.
LIntExport void TupleChr(const HTuple& T, HTuple* Chr);

// Convert a tuple of strings of length 1 into a tuple of their ASCII codes.
LIntExport void TupleOrd(const HTuple& T, HTuple* Ord);

// Convert a tuple into a tuple of strings.
LIntExport void TupleString(const HTuple& T, const HTuple& Format, HTuple* String);

// Check a tuple (of strings) whether it represents numbers.
LIntExport void TupleIsNumber(const HTuple& T, HTuple* IsNumber);

// Convert a tuple (of strings) into a tuple of numbers.
LIntExport void TupleNumber(const HTuple& T, HTuple* Number);

// Convert a tuple into a tuple of integer numbers.
LIntExport void TupleRound(const HTuple& T, HTuple* Round);

// Convert a tuple into a tuple of integer numbers.
LIntExport void TupleInt(const HTuple& T, HTuple* Int);

// Convert a tuple into a tuple of floating point numbers.
LIntExport void TupleReal(const HTuple& T, HTuple* Real);

// Calculate the ldexp function of two tuples.
LIntExport void TupleLdexp(const HTuple& T1, const HTuple& T2, HTuple* Ldexp);

// Calculate the remainder of the floating point division of two tuples.
LIntExport void TupleFmod(const HTuple& T1, const HTuple& T2, HTuple* Fmod);

// Calculate the remainder of the integer division of two tuples.
LIntExport void TupleMod(const HTuple& T1, const HTuple& T2, HTuple* Mod);

// Compute the ceiling function of a tuple.
LIntExport void TupleCeil(const HTuple& T, HTuple* Ceil);

// Compute the floor function of a tuple.
LIntExport void TupleFloor(const HTuple& T, HTuple* Floor);

// Calculate the power function of two tuples.
LIntExport void TuplePow(const HTuple& T1, const HTuple& T2, HTuple* Pow);

// Compute the base 10 logarithm of a tuple.
LIntExport void TupleLog10(const HTuple& T, HTuple* Log);

// Compute the natural logarithm of a tuple.
LIntExport void TupleLog(const HTuple& T, HTuple* Log);

// Compute the exponential of a tuple.
LIntExport void TupleExp(const HTuple& T, HTuple* Exp);

// Compute the hyperbolic tangent of a tuple.
LIntExport void TupleTanh(const HTuple& T, HTuple* Tanh);

// Compute the hyperbolic cosine of a tuple.
LIntExport void TupleCosh(const HTuple& T, HTuple* Cosh);

// Compute the hyperbolic sine of a tuple.
LIntExport void TupleSinh(const HTuple& T, HTuple* Sinh);

// Convert a tuple from degrees to radians.
LIntExport void TupleRad(const HTuple& Deg, HTuple* Rad);

// Convert a tuple from radians to degrees.
LIntExport void TupleDeg(const HTuple& Rad, HTuple* Deg);

// Compute the arctangent of a tuple for all four quadrants.
LIntExport void TupleAtan2(const HTuple& Y, const HTuple& X, HTuple* ATan);

// Compute the arctangent of a tuple.
LIntExport void TupleAtan(const HTuple& T, HTuple* ATan);

// Compute the arccosine of a tuple.
LIntExport void TupleAcos(const HTuple& T, HTuple* ACos);

// Compute the arcsine of a tuple.
LIntExport void TupleAsin(const HTuple& T, HTuple* ASin);

// Compute the tangent of a tuple.
LIntExport void TupleTan(const HTuple& T, HTuple* Tan);

// Compute the cosine of a tuple.
LIntExport void TupleCos(const HTuple& T, HTuple* Cos);

// Compute the sine of a tuple.
LIntExport void TupleSin(const HTuple& T, HTuple* Sin);

// Compute the absolute value of a tuple (as floating point numbers).
LIntExport void TupleFabs(const HTuple& T, HTuple* Abs);

// Compute the square root of a tuple.
LIntExport void TupleSqrt(const HTuple& T, HTuple* Sqrt);

// Compute the absolute value of a tuple.
LIntExport void TupleAbs(const HTuple& T, HTuple* Abs);

// Negate a tuple.
LIntExport void TupleNeg(const HTuple& T, HTuple* Neg);

// Divide two tuples.
LIntExport void TupleDiv(const HTuple& Q1, const HTuple& Q2, HTuple* Quot);

// Multiply two tuples.
LIntExport void TupleMult(const HTuple& P1, const HTuple& P2, HTuple* Prod);

// Subtract two tuples.
LIntExport void TupleSub(const HTuple& D1, const HTuple& D2, HTuple* Diff);

// Add two tuples.
LIntExport void TupleAdd(const HTuple& S1, const HTuple& S2, HTuple* Sum);

// Deserialize a serialized tuple.
LIntExport void DeserializeTuple(const HTuple& SerializedItemHandle, HTuple* Tuple);

// Serialize a tuple.
LIntExport void SerializeTuple(const HTuple& Tuple, HTuple* SerializedItemHandle);

// Write a tuple to a file.
LIntExport void WriteTuple(const HTuple& Tuple, const HTuple& FileName);

// Read a tuple from a file.
LIntExport void ReadTuple(const HTuple& FileName, HTuple* Tuple);

// Compute the average of a set of poses.
LIntExport void PoseAverage(const HTuple& Poses, const HTuple& Weights, const HTuple& Mode, const HTuple& SigmaT, const HTuple& SigmaR, HTuple* AveragePose, HTuple* Quality);

// Perform a rotation by a unit quaternion.
LIntExport void QuatRotatePoint3d(const HTuple& Quaternion, const HTuple& Px, const HTuple& Py, const HTuple& Pz, HTuple* Qx, HTuple* Qy, HTuple* Qz);

// Generate the conjugation of a quaternion.
LIntExport void QuatConjugate(const HTuple& Quaternion, HTuple* ConjugatedQuaternion);

// Normalizes a quaternion.
LIntExport void QuatNormalize(const HTuple& Quaternion, HTuple* NormalizedQuaternion);

// Create a rotation quaternion.
LIntExport void AxisAngleToQuat(const HTuple& AxisX, const HTuple& AxisY, const HTuple& AxisZ, const HTuple& Angle, HTuple* Quaternion);

// Convert a quaternion into the corresponding 3D pose.
LIntExport void QuatToPose(const HTuple& Quaternion, HTuple* Pose);

// Invert each pose in a tuple of 3D poses.
LIntExport void PoseInvert(const HTuple& Pose, HTuple* PoseInvert);

// Combine 3D poses given in two tuples.
LIntExport void PoseCompose(const HTuple& PoseLeft, const HTuple& PoseRight, HTuple* PoseCompose);

// Convert a quaternion into the corresponding rotation matrix.
LIntExport void QuatToHomMat3d(const HTuple& Quaternion, HTuple* RotationMatrix);

// Convert the rotational part of a 3D pose to a quaternion.
LIntExport void PoseToQuat(const HTuple& Pose, HTuple* Quaternion);

// Interpolation of two quaternions.
LIntExport void QuatInterpolate(const HTuple& QuaternionStart, const HTuple& QuaternionEnd, const HTuple& InterpPos, HTuple* QuaternionInterpolated);

// Multiply two quaternions.
LIntExport void QuatCompose(const HTuple& QuaternionLeft, const HTuple& QuaternionRight, HTuple* QuaternionComposed);

// Deserialize a serialized homogeneous 3D transformation matrix.
LIntExport void DeserializeHomMat3d(const HTuple& SerializedItemHandle, HTuple* HomMat3D);

// Serialize a homogeneous 3D transformation matrix.
LIntExport void SerializeHomMat3d(const HTuple& HomMat3D, HTuple* SerializedItemHandle);

// Deserialize a serialized homogeneous 2D transformation matrix.
LIntExport void DeserializeHomMat2d(const HTuple& SerializedItemHandle, HTuple* HomMat2D);

// Serialize a homogeneous 2D transformation matrix.
LIntExport void SerializeHomMat2d(const HTuple& HomMat2D, HTuple* SerializedItemHandle);

// Deserialize a serialized quaternion.
LIntExport void DeserializeQuat(const HTuple& SerializedItemHandle, HTuple* Quaternion);

// Serialize a quaternion.
LIntExport void SerializeQuat(const HTuple& Quaternion, HTuple* SerializedItemHandle);

// Project a homogeneous 3D point using a projective transformation matrix.
LIntExport void ProjectiveTransHomPoint3d(const HTuple& HomMat3D, const HTuple& Px, const HTuple& Py, const HTuple& Pz, const HTuple& Pw, HTuple* Qx, HTuple* Qy, HTuple* Qz, HTuple* Qw);

// Project a 3D point using a projective transformation matrix.
LIntExport void ProjectiveTransPoint3d(const HTuple& HomMat3D, const HTuple& Px, const HTuple& Py, const HTuple& Pz, HTuple* Qx, HTuple* Qy, HTuple* Qz);

// Apply an arbitrary affine 3D transformation to points.
LIntExport void AffineTransPoint3d(const HTuple& HomMat3D, const HTuple& Px, const HTuple& Py, const HTuple& Pz, HTuple* Qx, HTuple* Qy, HTuple* Qz);

// Approximate a 3D transformation from point correspondences.
LIntExport void VectorToHomMat3d(const HTuple& TransformationType, const HTuple& Px, const HTuple& Py, const HTuple& Pz, const HTuple& Qx, const HTuple& Qy, const HTuple& Qz, HTuple* HomMat3D);

// Compute the determinant of a homogeneous 3D transformation matrix.
LIntExport void HomMat3dDeterminant(const HTuple& HomMat3D, HTuple* Determinant);

// Transpose a homogeneous 3D transformation matrix.
LIntExport void HomMat3dTranspose(const HTuple& HomMat3D, HTuple* HomMat3DTranspose);

// Invert a homogeneous 3D transformation matrix.
LIntExport void HomMat3dInvert(const HTuple& HomMat3D, HTuple* HomMat3DInvert);

// Multiply two homogeneous 3D transformation matrices.
LIntExport void HomMat3dCompose(const HTuple& HomMat3DLeft, const HTuple& HomMat3DRight, HTuple* HomMat3DCompose);

// Add a rotation to a homogeneous 3D transformation matrix.
LIntExport void HomMat3dRotateLocal(const HTuple& HomMat3D, const HTuple& Phi, const HTuple& Axis, HTuple* HomMat3DRotate);

// Add a rotation to a homogeneous 3D transformation matrix.
LIntExport void HomMat3dRotate(const HTuple& HomMat3D, const HTuple& Phi, const HTuple& Axis, const HTuple& Px, const HTuple& Py, const HTuple& Pz, HTuple* HomMat3DRotate);

// Add a scaling to a homogeneous 3D transformation matrix.
LIntExport void HomMat3dScaleLocal(const HTuple& HomMat3D, const HTuple& Sx, const HTuple& Sy, const HTuple& Sz, HTuple* HomMat3DScale);

// Add a scaling to a homogeneous 3D transformation matrix.
LIntExport void HomMat3dScale(const HTuple& HomMat3D, const HTuple& Sx, const HTuple& Sy, const HTuple& Sz, const HTuple& Px, const HTuple& Py, const HTuple& Pz, HTuple* HomMat3DScale);

// Add a translation to a homogeneous 3D transformation matrix.
LIntExport void HomMat3dTranslateLocal(const HTuple& HomMat3D, const HTuple& Tx, const HTuple& Ty, const HTuple& Tz, HTuple* HomMat3DTranslate);

// Add a translation to a homogeneous 3D transformation matrix.
LIntExport void HomMat3dTranslate(const HTuple& HomMat3D, const HTuple& Tx, const HTuple& Ty, const HTuple& Tz, HTuple* HomMat3DTranslate);

// Generate the homogeneous transformation matrix of the identical 3D transformation.
LIntExport void HomMat3dIdentity(HTuple* HomMat3DIdentity);

// Project an affine 3D transformation matrix to a 2D projective transformation matrix.
LIntExport void HomMat3dProject(const HTuple& HomMat3D, const HTuple& PrincipalPointRow, const HTuple& PrincipalPointCol, const HTuple& Focus, HTuple* HomMat2D);

// Perform a bundle adjustment of an image mosaic.
LIntExport void BundleAdjustMosaic(const HTuple& NumImages, const HTuple& ReferenceImage, const HTuple& MappingSource, const HTuple& MappingDest, const HTuple& HomMatrices2D, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HTuple& NumCorrespondences, const HTuple& Transformation, HTuple* MosaicMatrices2D, HTuple* Rows, HTuple* Cols, HTuple* Error);

// Compute a projective transformation matrix and the radial distortion coefficient between two images by finding correspondences between points based on known approximations of the projective transformation matrix and the radial distortion coefficient.
LIntExport void ProjMatchPointsDistortionRansacGuided(const HObject& Image1, const HObject& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HTuple& GrayMatchMethod, const HTuple& MaskSize, const HTuple& HomMat2DGuide, const HTuple& KappaGuide, const HTuple& DistanceTolerance, const HTuple& MatchThreshold, const HTuple& EstimationMethod, const HTuple& DistanceThreshold, const HTuple& RandSeed, HTuple* HomMat2D, HTuple* Kappa, HTuple* Error, HTuple* Points1, HTuple* Points2);

// Compute a projective transformation matrix between two images and the radial distortion coefficient by automatically finding correspondences between points.
LIntExport void ProjMatchPointsDistortionRansac(const HObject& Image1, const HObject& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HTuple& GrayMatchMethod, const HTuple& MaskSize, const HTuple& RowMove, const HTuple& ColMove, const HTuple& RowTolerance, const HTuple& ColTolerance, const HTuple& Rotation, const HTuple& MatchThreshold, const HTuple& EstimationMethod, const HTuple& DistanceThreshold, const HTuple& RandSeed, HTuple* HomMat2D, HTuple* Kappa, HTuple* Error, HTuple* Points1, HTuple* Points2);

// Compute a projective transformation matrix between two images by finding correspondences between points based on a known approximation of the projective transformation matrix.
LIntExport void ProjMatchPointsRansacGuided(const HObject& Image1, const HObject& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HTuple& GrayMatchMethod, const HTuple& MaskSize, const HTuple& HomMat2DGuide, const HTuple& DistanceTolerance, const HTuple& MatchThreshold, const HTuple& EstimationMethod, const HTuple& DistanceThreshold, const HTuple& RandSeed, HTuple* HomMat2D, HTuple* Points1, HTuple* Points2);

// Compute a projective transformation matrix between two images by finding correspondences between points.
LIntExport void ProjMatchPointsRansac(const HObject& Image1, const HObject& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HTuple& GrayMatchMethod, const HTuple& MaskSize, const HTuple& RowMove, const HTuple& ColMove, const HTuple& RowTolerance, const HTuple& ColTolerance, const HTuple& Rotation, const HTuple& MatchThreshold, const HTuple& EstimationMethod, const HTuple& DistanceThreshold, const HTuple& RandSeed, HTuple* HomMat2D, HTuple* Points1, HTuple* Points2);

// Compute a projective transformation matrix and the radial distortion coefficient using given point correspondences.
LIntExport void VectorToProjHomMat2dDistortion(const HTuple& Points1Row, const HTuple& Points1Col, const HTuple& Points2Row, const HTuple& Points2Col, const HTuple& CovRR1, const HTuple& CovRC1, const HTuple& CovCC1, const HTuple& CovRR2, const HTuple& CovRC2, const HTuple& CovCC2, const HTuple& ImageWidth, const HTuple& ImageHeight, const HTuple& Method, HTuple* HomMat2D, HTuple* Kappa, HTuple* Error);

// Compute a homogeneous transformation matrix using given point correspondences.
LIntExport void HomVectorToProjHomMat2d(const HTuple& Px, const HTuple& Py, const HTuple& Pw, const HTuple& Qx, const HTuple& Qy, const HTuple& Qw, const HTuple& Method, HTuple* HomMat2D);

// Compute a projective transformation matrix using given point correspondences.
LIntExport void VectorToProjHomMat2d(const HTuple& Px, const HTuple& Py, const HTuple& Qx, const HTuple& Qy, const HTuple& Method, const HTuple& CovXX1, const HTuple& CovYY1, const HTuple& CovXY1, const HTuple& CovXX2, const HTuple& CovYY2, const HTuple& CovXY2, HTuple* HomMat2D, HTuple* Covariance);

// Compute the affine transformation parameters from a homogeneous 2D transformation matrix.
LIntExport void HomMat2dToAffinePar(const HTuple& HomMat2D, HTuple* Sx, HTuple* Sy, HTuple* Phi, HTuple* Theta, HTuple* Tx, HTuple* Ty);

// Compute a rigid affine transformation from points and angles.
LIntExport void VectorAngleToRigid(const HTuple& Row1, const HTuple& Column1, const HTuple& Angle1, const HTuple& Row2, const HTuple& Column2, const HTuple& Angle2, HTuple* HomMat2D);

// Approximate an affine transformation from point-to-line correspondences.
LIntExport void PointLineToHomMat2d(const HTuple& TransformationType, const HTuple& Px, const HTuple& Py, const HTuple& L1x, const HTuple& L1y, const HTuple& L2x, const HTuple& L2y, HTuple* HomMat2D);

// Approximate a rigid affine transformation from point correspondences.
LIntExport void VectorToRigid(const HTuple& Px, const HTuple& Py, const HTuple& Qx, const HTuple& Qy, HTuple* HomMat2D);

// Approximate an similarity transformation from point correspondences.
LIntExport void VectorToSimilarity(const HTuple& Px, const HTuple& Py, const HTuple& Qx, const HTuple& Qy, HTuple* HomMat2D);

// Approximate an anisotropic similarity transformation from point correspondences.
LIntExport void VectorToAniso(const HTuple& Px, const HTuple& Py, const HTuple& Qx, const HTuple& Qy, HTuple* HomMat2D);

// Approximate an affine transformation from point correspondences.
LIntExport void VectorToHomMat2d(const HTuple& Px, const HTuple& Py, const HTuple& Qx, const HTuple& Qy, HTuple* HomMat2D);

// Project pixel coordinates using a homogeneous projective transformation matrix.
LIntExport void ProjectiveTransPixel(const HTuple& HomMat2D, const HTuple& Row, const HTuple& Col, HTuple* RowTrans, HTuple* ColTrans);

// Project a homogeneous 2D point using a projective transformation matrix.
LIntExport void ProjectiveTransPoint2d(const HTuple& HomMat2D, const HTuple& Px, const HTuple& Py, const HTuple& Pw, HTuple* Qx, HTuple* Qy, HTuple* Qw);

// Apply an arbitrary affine 2D transformation to pixel coordinates.
LIntExport void AffineTransPixel(const HTuple& HomMat2D, const HTuple& Row, const HTuple& Col, HTuple* RowTrans, HTuple* ColTrans);

// Apply an arbitrary affine 2D transformation to points.
LIntExport void AffineTransPoint2d(const HTuple& HomMat2D, const HTuple& Px, const HTuple& Py, HTuple* Qx, HTuple* Qy);

// Compute the determinant of a homogeneous 2D transformation matrix.
LIntExport void HomMat2dDeterminant(const HTuple& HomMat2D, HTuple* Determinant);

// Transpose a homogeneous 2D transformation matrix.
LIntExport void HomMat2dTranspose(const HTuple& HomMat2D, HTuple* HomMat2DTranspose);

// Invert a homogeneous 2D transformation matrix.
LIntExport void HomMat2dInvert(const HTuple& HomMat2D, HTuple* HomMat2DInvert);

// Multiply two homogeneous 2D transformation matrices.
LIntExport void HomMat2dCompose(const HTuple& HomMat2DLeft, const HTuple& HomMat2DRight, HTuple* HomMat2DCompose);

// Add a reflection to a homogeneous 2D transformation matrix.
LIntExport void HomMat2dReflectLocal(const HTuple& HomMat2D, const HTuple& Px, const HTuple& Py, HTuple* HomMat2DReflect);

// Add a reflection to a homogeneous 2D transformation matrix.
LIntExport void HomMat2dReflect(const HTuple& HomMat2D, const HTuple& Px, const HTuple& Py, const HTuple& Qx, const HTuple& Qy, HTuple* HomMat2DReflect);

// Add a slant to a homogeneous 2D transformation matrix.
LIntExport void HomMat2dSlantLocal(const HTuple& HomMat2D, const HTuple& Theta, const HTuple& Axis, HTuple* HomMat2DSlant);

// Add a slant to a homogeneous 2D transformation matrix.
LIntExport void HomMat2dSlant(const HTuple& HomMat2D, const HTuple& Theta, const HTuple& Axis, const HTuple& Px, const HTuple& Py, HTuple* HomMat2DSlant);

// Add a rotation to a homogeneous 2D transformation matrix.
LIntExport void HomMat2dRotateLocal(const HTuple& HomMat2D, const HTuple& Phi, HTuple* HomMat2DRotate);

// Add a rotation to a homogeneous 2D transformation matrix.
LIntExport void HomMat2dRotate(const HTuple& HomMat2D, const HTuple& Phi, const HTuple& Px, const HTuple& Py, HTuple* HomMat2DRotate);

// Add a scaling to a homogeneous 2D transformation matrix.
LIntExport void HomMat2dScaleLocal(const HTuple& HomMat2D, const HTuple& Sx, const HTuple& Sy, HTuple* HomMat2DScale);

// Add a scaling to a homogeneous 2D transformation matrix.
LIntExport void HomMat2dScale(const HTuple& HomMat2D, const HTuple& Sx, const HTuple& Sy, const HTuple& Px, const HTuple& Py, HTuple* HomMat2DScale);

// Add a translation to a homogeneous 2D transformation matrix.
LIntExport void HomMat2dTranslateLocal(const HTuple& HomMat2D, const HTuple& Tx, const HTuple& Ty, HTuple* HomMat2DTranslate);

// Add a translation to a homogeneous 2D transformation matrix.
LIntExport void HomMat2dTranslate(const HTuple& HomMat2D, const HTuple& Tx, const HTuple& Ty, HTuple* HomMat2DTranslate);

// Generate the homogeneous transformation matrix of the identical 2D transformation.
LIntExport void HomMat2dIdentity(HTuple* HomMat2DIdentity);

// Clear all scattered data interpolators.
LIntExport void ClearAllScatteredDataInterpolators();

// Clear a scattered data interpolator.
LIntExport void ClearScatteredDataInterpolator(const HTuple& ScatteredDataInterpolatorHandle);

// Interpolation of scattered data using a scattered data interpolator.
LIntExport void InterpolateScatteredData(const HTuple& ScatteredDataInterpolatorHandle, const HTuple& Row, const HTuple& Column, HTuple* ValueInterpolated);

// Creates an interpolator for the interpolation of scattered data.
LIntExport void CreateScatteredDataInterpolator(const HTuple& Method, const HTuple& Rows, const HTuple& Columns, const HTuple& Values, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* ScatteredDataInterpolatorHandle);

// Creating an image from the interpolation of scattered data.
LIntExport void InterpolateScatteredDataPointsToImage(HObject* ImageInterpolated, const HTuple& Method, const HTuple& Rows, const HTuple& Columns, const HTuple& Values, const HTuple& Width, const HTuple& Height, const HTuple& GenParamNames, const HTuple& GenParamValues);

// Interpolation of an image.
LIntExport void InterpolateScatteredDataImage(const HObject& Image, const HObject& RegionInterpolate, HObject* ImageInterpolated, const HTuple& Method, const HTuple& GenParamNames, const HTuple& GenParamValues);

// Read out the system time.
LIntExport void GetSystemTime(HTuple* MSecond, HTuple* Second, HTuple* Minute, HTuple* Hour, HTuple* Day, HTuple* YDay, HTuple* Month, HTuple* Year);

// Query compute device parameters.
LIntExport void GetComputeDeviceParam(const HTuple& DeviceHandle, const HTuple& ParamName, HTuple* ParamValue);

// Set parameters of an compute device.
LIntExport void SetComputeDeviceParam(const HTuple& DeviceHandle, const HTuple& ParamName, const HTuple& ParamValue);

// Close all compute devices.
LIntExport void ReleaseAllComputeDevices();

// Close a compute_device.
LIntExport void ReleaseComputeDevice(const HTuple& DeviceHandle);

// Deactivate all compute devices.
LIntExport void DeactivateAllComputeDevices();

// Deactivate a compute device.
LIntExport void DeactivateComputeDevice(const HTuple& DeviceHandle);

// Activate a compute device.
LIntExport void ActivateComputeDevice(const HTuple& DeviceHandle);

// Initialize a compute device.
LIntExport void InitComputeDevice(const HTuple& DeviceHandle, const HTuple& Operators);

// Open a compute device.
LIntExport void OpenComputeDevice(const HTuple& DeviceIdentifier, HTuple* DeviceHandle);

// Get information on a compute device.
LIntExport void GetComputeDeviceInfo(const HTuple& DeviceIdentifier, const HTuple& InfoName, HTuple* Info);

// Get the list of available compute devices.
LIntExport void QueryAvailableComputeDevices(HTuple* DeviceIdentifier);

// Clear the buffer of a serial connection.
LIntExport void ClearSerial(const HTuple& SerialHandle, const HTuple& Channel);

// Write to a serial connection.
LIntExport void WriteSerial(const HTuple& SerialHandle, const HTuple& Data);

// Read from a serial device.
LIntExport void ReadSerial(const HTuple& SerialHandle, const HTuple& NumCharacters, HTuple* Data);

// Get the parameters of a serial device.
LIntExport void GetSerialParam(const HTuple& SerialHandle, HTuple* BaudRate, HTuple* DataBits, HTuple* FlowControl, HTuple* Parity, HTuple* StopBits, HTuple* TotalTimeOut, HTuple* InterCharTimeOut);

// Set the parameters of a serial device.
LIntExport void SetSerialParam(const HTuple& SerialHandle, const HTuple& BaudRate, const HTuple& DataBits, const HTuple& FlowControl, const HTuple& Parity, const HTuple& StopBits, const HTuple& TotalTimeOut, const HTuple& InterCharTimeOut);

// Close all serial devices.
LIntExport void CloseAllSerials();

// Close a serial device.
LIntExport void CloseSerial(const HTuple& SerialHandle);

// Open a serial device.
LIntExport void OpenSerial(const HTuple& PortName, HTuple* SerialHandle);

// Delaying the execution of the program.
LIntExport void WaitSeconds(const HTuple& Seconds);

// Execute a system command.
LIntExport void SystemCall(const HTuple& Command);

// Set HALCON system parameters.
LIntExport void SetSystem(const HTuple& SystemParameter, const HTuple& Value);

// Activating and deactivating of HALCON control modes.
LIntExport void SetCheck(const HTuple& Check);

// Initialization of the HALCON system.
LIntExport void ResetObjDb(const HTuple& DefaultImageWidth, const HTuple& DefaultImageHeight, const HTuple& DefaultChannels);

// Get current value of HALCON system parameters.
LIntExport void GetSystem(const HTuple& Query, HTuple* Information);

// State of the HALCON control modes.
LIntExport void GetCheck(HTuple* Check);

// Inquiry after the error text of a HALCON error number.
LIntExport void GetErrorText(const HTuple& ErrorCode, HTuple* ErrorMessage);

// Passed Time.
LIntExport void CountSeconds(HTuple* Seconds);

// Number of entries in the HALCON database.
LIntExport void CountRelation(const HTuple& RelationName, HTuple* NumOfTuples);

// Receive an image over a socket connection.
LIntExport void ReceiveImage(HObject* Image, const HTuple& Socket);

// Send an image over a socket connection.
LIntExport void SendImage(const HObject& Image, const HTuple& Socket);

// Receive regions over a socket connection.
LIntExport void ReceiveRegion(HObject* Region, const HTuple& Socket);

// Send regions over a socket connection.
LIntExport void SendRegion(const HObject& Region, const HTuple& Socket);

// Receive an XLD object over a socket connection.
LIntExport void ReceiveXld(HObject* XLD, const HTuple& Socket);

// Send an XLD object over a socket connection.
LIntExport void SendXld(const HObject& XLD, const HTuple& Socket);

// Receive a tuple over a socket connection.
LIntExport void ReceiveTuple(const HTuple& Socket, HTuple* Tuple);

// Send a tuple over a socket connection.
LIntExport void SendTuple(const HTuple& Socket, const HTuple& Tuple);

// Receive arbitrary data from external devices or applications using a generic socket connection.
LIntExport void ReceiveData(const HTuple& Socket, const HTuple& Format, HTuple* Data, HTuple* From);

// Send arbitrary data to external devices or applications using a generic socket communication.
LIntExport void SendData(const HTuple& Socket, const HTuple& Format, const HTuple& Data, const HTuple& To);

// Get the value of a socket parameter.
LIntExport void GetSocketParam(const HTuple& Socket, const HTuple& ParamName, HTuple* ParamValue);

// Set a socket parameter.
LIntExport void SetSocketParam(const HTuple& Socket, const HTuple& ParamName, const HTuple& ParamValue);

// Determine the HALCON data type of the next socket data.
LIntExport void GetNextSocketDataType(const HTuple& Socket, HTuple* DataType);

// Get the socket descriptor of a socket used by the operating system.
LIntExport void GetSocketDescriptor(const HTuple& Socket, HTuple* SocketDescriptor);

// Get the timeout of a socket.
LIntExport void GetSocketTimeout(const HTuple& Socket, HTuple* Timeout);

// Set the timeout of a socket.
LIntExport void SetSocketTimeout(const HTuple& Socket, const HTuple& Timeout);

// Close all opened sockets.
LIntExport void CloseAllSockets();

// Close a socket.
LIntExport void CloseSocket(const HTuple& Socket);

// Accept a connection request on a listening socket of the protocol type 'HALCON' or 'TCP'/'TCP4'/'TCP6'.
LIntExport void SocketAcceptConnect(const HTuple& AcceptingSocket, const HTuple& Wait, HTuple* Socket);

// Open a socket and connect it to an accepting socket.
LIntExport void OpenSocketConnect(const HTuple& HostName, const HTuple& Port, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* Socket);

// Open a socket that accepts connection requests.
LIntExport void OpenSocketAccept(const HTuple& Port, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* AcceptingSocket);

// Returns the extended error information for the calling thread's last HALCON error.
LIntExport void GetExtendedErrorInfo(HTuple* OperatorName, HTuple* ErrorCode, HTuple* ErrorMessage);

// Query of used modules and the module key.
LIntExport void GetModules(HTuple* UsedModules, HTuple* ModuleKey);

// Compute the distance values for a rectified stereo image pair using multi-scanline optimization.
LIntExport void BinocularDistanceMs(const HObject& ImageRect1, const HObject& ImageRect2, HObject* Distance, HObject* Score, const HTuple& CamParamRect1, const HTuple& CamParamRect2, const HTuple& RelPoseRect, const HTuple& MinDisparity, const HTuple& MaxDisparity, const HTuple& SurfaceSmoothing, const HTuple& EdgeSmoothing, const HTuple& GenParamName, const HTuple& GenParamValue);

// Compute the disparities of a rectified stereo image pair using multi-scanline optimization.
LIntExport void BinocularDisparityMs(const HObject& ImageRect1, const HObject& ImageRect2, HObject* Disparity, HObject* Score, const HTuple& MinDisparity, const HTuple& MaxDisparity, const HTuple& SurfaceSmoothing, const HTuple& EdgeSmoothing, const HTuple& GenParamName, const HTuple& GenParamValue);

// Compute the distance values for a rectified stereo image pair using multigrid methods.
LIntExport void BinocularDistanceMg(const HObject& ImageRect1, const HObject& ImageRect2, HObject* Distance, HObject* Score, const HTuple& CamParamRect1, const HTuple& CamParamRect2, const HTuple& RelPoseRect, const HTuple& GrayConstancy, const HTuple& GradientConstancy, const HTuple& Smoothness, const HTuple& InitialGuess, const HTuple& CalculateScore, const HTuple& MGParamName, const HTuple& MGParamValue);

// Compute the disparities of a rectified stereo image pair using multigrid methods.
LIntExport void BinocularDisparityMg(const HObject& ImageRect1, const HObject& ImageRect2, HObject* Disparity, HObject* Score, const HTuple& GrayConstancy, const HTuple& GradientConstancy, const HTuple& Smoothness, const HTuple& InitialGuess, const HTuple& CalculateScore, const HTuple& MGParamName, const HTuple& MGParamValue);

// Compute the projective 3d reconstruction of points based on the fundamental matrix.
LIntExport void Reconst3dFromFundamentalMatrix(const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HTuple& CovRR1, const HTuple& CovRC1, const HTuple& CovCC1, const HTuple& CovRR2, const HTuple& CovRC2, const HTuple& CovCC2, const HTuple& FMatrix, const HTuple& CovFMat, HTuple* X, HTuple* Y, HTuple* Z, HTuple* W, HTuple* CovXYZW);

// Compute the projective rectification of weakly calibrated binocular stereo images.
LIntExport void GenBinocularProjRectification(HObject* Map1, HObject* Map2, const HTuple& FMatrix, const HTuple& CovFMat, const HTuple& Width1, const HTuple& Height1, const HTuple& Width2, const HTuple& Height2, const HTuple& SubSampling, const HTuple& Mapping, HTuple* CovFMatRect, HTuple* H1, HTuple* H2);

// Compute the fundamental matrix and the radial distortion coefficient given a set of image point correspondences and reconstruct 3D points.
LIntExport void VectorToFundamentalMatrixDistortion(const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HTuple& CovRR1, const HTuple& CovRC1, const HTuple& CovCC1, const HTuple& CovRR2, const HTuple& CovRC2, const HTuple& CovCC2, const HTuple& ImageWidth, const HTuple& ImageHeight, const HTuple& Method, HTuple* FMatrix, HTuple* Kappa, HTuple* Error, HTuple* X, HTuple* Y, HTuple* Z, HTuple* W);

// Compute the fundamental matrix from the relative orientation of two cameras.
LIntExport void RelPoseToFundamentalMatrix(const HTuple& RelPose, const HTuple& CovRelPose, const HTuple& CamPar1, const HTuple& CamPar2, HTuple* FMatrix, HTuple* CovFMat);

// Compute the fundamental matrix from an essential matrix.
LIntExport void EssentialToFundamentalMatrix(const HTuple& EMatrix, const HTuple& CovEMat, const HTuple& CamMat1, const HTuple& CamMat2, HTuple* FMatrix, HTuple* CovFMat);

// Compute the relative orientation between two cameras given image point correspondences and known camera parameters and reconstruct 3D space points.
LIntExport void VectorToRelPose(const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HTuple& CovRR1, const HTuple& CovRC1, const HTuple& CovCC1, const HTuple& CovRR2, const HTuple& CovRC2, const HTuple& CovCC2, const HTuple& CamPar1, const HTuple& CamPar2, const HTuple& Method, HTuple* RelPose, HTuple* CovRelPose, HTuple* Error, HTuple* X, HTuple* Y, HTuple* Z, HTuple* CovXYZ);

// Compute the essential matrix given image point correspondences and known camera matrices and reconstruct 3D points.
LIntExport void VectorToEssentialMatrix(const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HTuple& CovRR1, const HTuple& CovRC1, const HTuple& CovCC1, const HTuple& CovRR2, const HTuple& CovRC2, const HTuple& CovCC2, const HTuple& CamMat1, const HTuple& CamMat2, const HTuple& Method, HTuple* EMatrix, HTuple* CovEMat, HTuple* Error, HTuple* X, HTuple* Y, HTuple* Z, HTuple* CovXYZ);

// Compute the fundamental matrix given a set of image point correspondences and reconstruct 3D points.
LIntExport void VectorToFundamentalMatrix(const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HTuple& CovRR1, const HTuple& CovRC1, const HTuple& CovCC1, const HTuple& CovRR2, const HTuple& CovRC2, const HTuple& CovCC2, const HTuple& Method, HTuple* FMatrix, HTuple* CovFMat, HTuple* Error, HTuple* X, HTuple* Y, HTuple* Z, HTuple* W, HTuple* CovXYZW);

// Compute the fundamental matrix and the radial distortion coefficient for a pair of stereo images by automatically finding correspondences between image points.
LIntExport void MatchFundamentalMatrixDistortionRansac(const HObject& Image1, const HObject& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HTuple& GrayMatchMethod, const HTuple& MaskSize, const HTuple& RowMove, const HTuple& ColMove, const HTuple& RowTolerance, const HTuple& ColTolerance, const HTuple& Rotation, const HTuple& MatchThreshold, const HTuple& EstimationMethod, const HTuple& DistanceThreshold, const HTuple& RandSeed, HTuple* FMatrix, HTuple* Kappa, HTuple* Error, HTuple* Points1, HTuple* Points2);

// Compute the relative orientation between two cameras by automatically finding correspondences between image points.
LIntExport void MatchRelPoseRansac(const HObject& Image1, const HObject& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HTuple& CamPar1, const HTuple& CamPar2, const HTuple& GrayMatchMethod, const HTuple& MaskSize, const HTuple& RowMove, const HTuple& ColMove, const HTuple& RowTolerance, const HTuple& ColTolerance, const HTuple& Rotation, const HTuple& MatchThreshold, const HTuple& EstimationMethod, const HTuple& DistanceThreshold, const HTuple& RandSeed, HTuple* RelPose, HTuple* CovRelPose, HTuple* Error, HTuple* Points1, HTuple* Points2);

// Compute the essential matrix for a pair of stereo images by automatically finding correspondences between image points.
LIntExport void MatchEssentialMatrixRansac(const HObject& Image1, const HObject& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HTuple& CamMat1, const HTuple& CamMat2, const HTuple& GrayMatchMethod, const HTuple& MaskSize, const HTuple& RowMove, const HTuple& ColMove, const HTuple& RowTolerance, const HTuple& ColTolerance, const HTuple& Rotation, const HTuple& MatchThreshold, const HTuple& EstimationMethod, const HTuple& DistanceThreshold, const HTuple& RandSeed, HTuple* EMatrix, HTuple* CovEMat, HTuple* Error, HTuple* Points1, HTuple* Points2);

// Compute the fundamental matrix for a pair of stereo images by automatically finding correspondences between image points.
LIntExport void MatchFundamentalMatrixRansac(const HObject& Image1, const HObject& Image2, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HTuple& GrayMatchMethod, const HTuple& MaskSize, const HTuple& RowMove, const HTuple& ColMove, const HTuple& RowTolerance, const HTuple& ColTolerance, const HTuple& Rotation, const HTuple& MatchThreshold, const HTuple& EstimationMethod, const HTuple& DistanceThreshold, const HTuple& RandSeed, HTuple* FMatrix, HTuple* CovFMat, HTuple* Error, HTuple* Points1, HTuple* Points2);

// Compute the distance values for a rectified stereo image pair using correlation techniques.
LIntExport void BinocularDistance(const HObject& ImageRect1, const HObject& ImageRect2, HObject* Distance, HObject* Score, const HTuple& CamParamRect1, const HTuple& CamParamRect2, const HTuple& RelPoseRect, const HTuple& Method, const HTuple& MaskWidth, const HTuple& MaskHeight, const HTuple& TextureThresh, const HTuple& MinDisparity, const HTuple& MaxDisparity, const HTuple& NumLevels, const HTuple& ScoreThresh, const HTuple& Filter, const HTuple& SubDistance);

// Compute the disparities of a rectified image pair using correlation techniques.
LIntExport void BinocularDisparity(const HObject& ImageRect1, const HObject& ImageRect2, HObject* Disparity, HObject* Score, const HTuple& Method, const HTuple& MaskWidth, const HTuple& MaskHeight, const HTuple& TextureThresh, const HTuple& MinDisparity, const HTuple& MaxDisparity, const HTuple& NumLevels, const HTuple& ScoreThresh, const HTuple& Filter, const HTuple& SubDisparity);

// Get a 3D point from the intersection of two lines of sight within a binocular camera system.
LIntExport void IntersectLinesOfSight(const HTuple& CamParam1, const HTuple& CamParam2, const HTuple& RelPose, const HTuple& Row1, const HTuple& Col1, const HTuple& Row2, const HTuple& Col2, HTuple* X, HTuple* Y, HTuple* Z, HTuple* Dist);

// Transform a disparity image into 3D points in a rectified stereo system.
LIntExport void DisparityImageToXyz(const HObject& Disparity, HObject* X, HObject* Y, HObject* Z, const HTuple& CamParamRect1, const HTuple& CamParamRect2, const HTuple& RelPoseRect);

// Transform an image point and its disparity into a 3D point in a rectified stereo system.
LIntExport void DisparityToPoint3d(const HTuple& CamParamRect1, const HTuple& CamParamRect2, const HTuple& RelPoseRect, const HTuple& Row1, const HTuple& Col1, const HTuple& Disparity, HTuple* X, HTuple* Y, HTuple* Z);

// Transform a disparity value into a distance value in a rectified binocular stereo system.
LIntExport void DisparityToDistance(const HTuple& CamParamRect1, const HTuple& CamParamRect2, const HTuple& RelPoseRect, const HTuple& Disparity, HTuple* Distance);

// Transfrom a distance value into a disparity in a rectified stereo system.
LIntExport void DistanceToDisparity(const HTuple& CamParamRect1, const HTuple& CamParamRect2, const HTuple& RelPoseRect, const HTuple& Distance, HTuple* Disparity);

// Generate transformation maps that describe the mapping of the images of a binocular camera pair to a common rectified image plane.
LIntExport void GenBinocularRectificationMap(HObject* Map1, HObject* Map2, const HTuple& CamParam1, const HTuple& CamParam2, const HTuple& RelPose, const HTuple& SubSampling, const HTuple& Method, const HTuple& MapType, HTuple* CamParamRect1, HTuple* CamParamRect2, HTuple* CamPoseRect1, HTuple* CamPoseRect2, HTuple* RelPoseRect);

// Determine all camera parameters of a binocular stereo system.
LIntExport void BinocularCalibration(const HTuple& NX, const HTuple& NY, const HTuple& NZ, const HTuple& NRow1, const HTuple& NCol1, const HTuple& NRow2, const HTuple& NCol2, const HTuple& StartCamParam1, const HTuple& StartCamParam2, const HTuple& NStartPose1, const HTuple& NStartPose2, const HTuple& EstimateParams, HTuple* CamParam1, HTuple* CamParam2, HTuple* NFinalPose1, HTuple* NFinalPose2, HTuple* RelPose, HTuple* Errors);

// Inquiring for possible settings of the HALCON debugging tool.
LIntExport void QuerySpy(HTuple* Classes, HTuple* Values);

// Control of the HALCON Debugging Tools.
LIntExport void SetSpy(const HTuple& Class, const HTuple& Value);

// Current configuration of the HALCON debugging-tool.
LIntExport void GetSpy(const HTuple& Class, HTuple* Value);

// Read a sheet-of-light model from a file and create a new model.
LIntExport void ReadSheetOfLightModel(const HTuple& FileName, HTuple* SheetOfLightModelID);

// Write a sheet-of-light model to a file.
LIntExport void WriteSheetOfLightModel(const HTuple& SheetOfLightModelID, const HTuple& FileName);

// Deserialize a sheet-of-light model.
LIntExport void DeserializeSheetOfLightModel(const HTuple& SerializedItemHandle, HTuple* SheetOfLightModelID);

// Serialize a sheet-of-light model.
LIntExport void SerializeSheetOfLightModel(const HTuple& SheetOfLightModelID, HTuple* SerializedItemHandle);

// Create a calibration object for sheet-of-light calibration.
LIntExport void CreateSheetOfLightCalibObject(const HTuple& Width, const HTuple& Length, const HTuple& HeightMin, const HTuple& HeightMax, const HTuple& FileName);

// Calibrate a sheet-of-light setup with a 3D calibration object.
LIntExport void CalibrateSheetOfLight(const HTuple& SheetOfLightModelID, HTuple* Error);

// Get the result of a calibrated measurement performed with the  sheet-of-light technique as a 3D object model.
LIntExport void GetSheetOfLightResultObjectModel3d(const HTuple& SheetOfLightModelID, HTuple* ObjectModel3D);

// Get the iconic results of a measurement performed with the sheet-of light technique.
LIntExport void GetSheetOfLightResult(HObject* ResultValue, const HTuple& SheetOfLightModelID, const HTuple& ResultName);

// Apply the calibration transformations to the input disparity image.
LIntExport void ApplySheetOfLightCalibration(const HObject& Disparity, const HTuple& SheetOfLightModelID);

// Set sheet of light profiles by measured disparities.
LIntExport void SetProfileSheetOfLight(const HObject& ProfileDisparityImage, const HTuple& SheetOfLightModelID, const HTuple& MovementPoses);

// Process the profile image provided as input and store the resulting disparity to the sheet-of-light model.
LIntExport void MeasureProfileSheetOfLight(const HObject& ProfileImage, const HTuple& SheetOfLightModelID, const HTuple& MovementPose);

// Set selected parameters of the sheet-of-light model.
LIntExport void SetSheetOfLightParam(const HTuple& SheetOfLightModelID, const HTuple& GenParamName, const HTuple& GenParamValue);

// Get the value of a parameter, which has been set in a sheet-of-light model.
LIntExport void GetSheetOfLightParam(const HTuple& SheetOfLightModelID, const HTuple& GenParamName, HTuple* GenParamValue);

// For a given sheet-of-light model get the names of the generic iconic or control parameters that can be used in the different sheet-of-light operators.
LIntExport void QuerySheetOfLightParams(const HTuple& SheetOfLightModelID, const HTuple& QueryName, HTuple* GenParamNames);

// Reset a sheet-of-light model.
LIntExport void ResetSheetOfLightModel(const HTuple& SheetOfLightModelID);

// Delete all sheet-of-light models and free the allocated memory.
LIntExport void ClearAllSheetOfLightModels();

// Delete a sheet-of-light model and free the allocated memory.
LIntExport void ClearSheetOfLightModel(const HTuple& SheetOfLightModelID);

// Create a model to perform 3D-measurements using the sheet-of-light technique.
LIntExport void CreateSheetOfLightModel(const HObject& ProfileRegion, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* SheetOfLightModelID);

// Shade a height field.
LIntExport void ShadeHeightField(const HObject& ImageHeight, HObject* ImageShade, const HTuple& Slant, const HTuple& Tilt, const HTuple& Albedo, const HTuple& Ambient, const HTuple& Shadows);

// Estimate the albedo of a surface and the amount of ambient light.
LIntExport void EstimateAlAm(const HObject& Image, HTuple* Albedo, HTuple* Ambient);

// Estimate the slant of a light source and the albedo of a surface.
LIntExport void EstimateSlAlZc(const HObject& Image, HTuple* Slant, HTuple* Albedo);

// Estimate the slant of a light source and the albedo of a surface.
LIntExport void EstimateSlAlLr(const HObject& Image, HTuple* Slant, HTuple* Albedo);

// Estimate the tilt of a light source.
LIntExport void EstimateTiltZc(const HObject& Image, HTuple* Tilt);

// Estimate the tilt of a light source.
LIntExport void EstimateTiltLr(const HObject& Image, HTuple* Tilt);

// Reconstruct a surface from at least three gray value images.
LIntExport void PhotStereo(const HObject& Images, HObject* Height, const HTuple& Slants, const HTuple& Tilts);

// Reconstruct a surface from surface gradients.
LIntExport void ReconstructHeightFieldFromGradient(const HObject& Gradient, HObject* HeightField, const HTuple& ReconstructionMethod, const HTuple& GenParamName, const HTuple& GenParamValue);

// Reconstruct a surface according to the photometric stereo technique.
LIntExport void PhotometricStereo(const HObject& Images, HObject* HeightField, HObject* Gradient, HObject* Albedo, const HTuple& Slants, const HTuple& Tilts, const HTuple& ResultType, const HTuple& ReconstructionMethod, const HTuple& GenParamName, const HTuple& GenParamValue);

// Reconstruct a surface from a gray value image.
LIntExport void SfsPentland(const HObject& Image, HObject* Height, const HTuple& Slant, const HTuple& Tilt, const HTuple& Albedo, const HTuple& Ambient);

// Reconstruct a surface from a gray value image.
LIntExport void SfsOrigLr(const HObject& Image, HObject* Height, const HTuple& Slant, const HTuple& Tilt, const HTuple& Albedo, const HTuple& Ambient);

// Reconstruct a surface from a gray value image.
LIntExport void SfsModLr(const HObject& Image, HObject* Height, const HTuple& Slant, const HTuple& Tilt, const HTuple& Albedo, const HTuple& Ambient);

// Receive a serialized item over a socket connection.
LIntExport void ReceiveSerializedItem(const HTuple& Socket, HTuple* SerializedItemHandle);

// Send a serialized item over a socket connection.
LIntExport void SendSerializedItem(const HTuple& Socket, const HTuple& SerializedItemHandle);

// Write a serialized item to a file.
LIntExport void FwriteSerializedItem(const HTuple& FileHandle, const HTuple& SerializedItemHandle);

// Read a serialized item from a file.
LIntExport void FreadSerializedItem(const HTuple& FileHandle, HTuple* SerializedItemHandle);

// Delete all current existing serialized items.
LIntExport void ClearAllSerializedItems();

// Delete a serialized item.
LIntExport void ClearSerializedItem(const HTuple& SerializedItemHandle);

// Access the data pointer of a serialized item.
LIntExport void GetSerializedItemPtr(const HTuple& SerializedItemHandle, HTuple* Pointer, HTuple* Size);

// Create a serialized item.
LIntExport void CreateSerializedItemPtr(const HTuple& Pointer, const HTuple& Size, const HTuple& Copy, HTuple* SerializedItemHandle);

// Fit 3D primitives into a set of 3D points.
LIntExport void FitPrimitivesObjectModel3d(const HTuple& ObjectModel3D, const HTuple& ParamName, const HTuple& ParamValue, HTuple* ObjectModel3DOut);

// Segment a set of 3D points into sub-sets with similar characteristics.
LIntExport void SegmentObjectModel3d(const HTuple& ObjectModel3D, const HTuple& ParamName, const HTuple& ParamValue, HTuple* ObjectModel3DOut);

// Clear all text results.
LIntExport void ClearAllTextResults();

// Clear a text result.
LIntExport void ClearTextResult(const HTuple& TextResultID);

// Query an iconic value of a text segmentation result.
LIntExport void GetTextObject(HObject* Characters, const HTuple& TextResultID, const HTuple& ResultName);

// Query a control value of a text segmentation result.
LIntExport void GetTextResult(const HTuple& TextResultID, const HTuple& ResultName, HTuple* ResultValue);

// Find text in an image.
LIntExport void FindText(const HObject& Image, const HTuple& TextModel, HTuple* TextResultID);

// Query parameters of a text model.
LIntExport void GetTextModelParam(const HTuple& TextModel, const HTuple& GenParamName, HTuple* GenParamValue);

// Set parameters of a text model.
LIntExport void SetTextModelParam(const HTuple& TextModel, const HTuple& GenParamName, const HTuple& GenParamValue);

// Clear all text models.
LIntExport void ClearAllTextModels();

// Clear a text model.
LIntExport void ClearTextModel(const HTuple& TextModel);

// Create a text model.
LIntExport void CreateTextModelReader(const HTuple& Mode, const HTuple& OCRClassifierMLP, HTuple* TextModel);

// Create a text model.
LIntExport void CreateTextModel(HTuple* TextModel);

// Selects characters from a given region.
LIntExport void SelectCharacters(const HObject& Region, HObject* RegionCharacters, const HTuple& DotPrint, const HTuple& StrokeWidth, const HTuple& CharWidth, const HTuple& CharHeight, const HTuple& Punctuation, const HTuple& DiacriticMarks, const HTuple& PartitionMethod, const HTuple& PartitionLines, const HTuple& FragmentDistance, const HTuple& ConnectFragments, const HTuple& ClutterSizeMax, const HTuple& StopAfter);

// Segments characters in a given region of an image.
LIntExport void SegmentCharacters(const HObject& Region, const HObject& Image, HObject* ImageForeground, HObject* RegionForeground, const HTuple& Method, const HTuple& EliminateLines, const HTuple& DotPrint, const HTuple& StrokeWidth, const HTuple& CharWidth, const HTuple& CharHeight, const HTuple& ThresholdOffset, const HTuple& Contrast, HTuple* UsedThreshold);

// Determines the slant of characters of a text line or paragraph.
LIntExport void TextLineSlant(const HObject& Region, const HObject& Image, const HTuple& CharHeight, const HTuple& SlantFrom, const HTuple& SlantTo, HTuple* SlantAngle);

// Determines the orientation of a text line or paragraph.
LIntExport void TextLineOrientation(const HObject& Region, const HObject& Image, const HTuple& CharHeight, const HTuple& OrientationFrom, const HTuple& OrientationTo, HTuple* OrientationAngle);

// Classify a byte image using a look-up table.
LIntExport void ClassifyImageClassLut(const HObject& Image, HObject* ClassRegions, const HTuple& ClassLUTHandle);

// Classify an image with a k-Nearest-Neighbor classifier.
LIntExport void ClassifyImageClassKnn(const HObject& Image, HObject* ClassRegions, HObject* DistanceImage, const HTuple& KNNHandle, const HTuple& RejectionThreshold);

// Add training samples from an image to the training data of a k-Nearest-Neighbor classifier.
LIntExport void AddSamplesImageClassKnn(const HObject& Image, const HObject& ClassRegions, const HTuple& KNNHandle);

// Classify an image with a Gaussian Mixture Model.
LIntExport void ClassifyImageClassGmm(const HObject& Image, HObject* ClassRegions, const HTuple& GMMHandle, const HTuple& RejectionThreshold);

// Add training samples from an image to the training data of a Gaussian Mixture Model.
LIntExport void AddSamplesImageClassGmm(const HObject& Image, const HObject& ClassRegions, const HTuple& GMMHandle, const HTuple& Randomize);

// Classify an image with a support vector machine.
LIntExport void ClassifyImageClassSvm(const HObject& Image, HObject* ClassRegions, const HTuple& SVMHandle);

// Add training samples from an image to the training data of a support vector machine.
LIntExport void AddSamplesImageClassSvm(const HObject& Image, const HObject& ClassRegions, const HTuple& SVMHandle);

// Classify an image with a multilayer perceptron.
LIntExport void ClassifyImageClassMlp(const HObject& Image, HObject* ClassRegions, const HTuple& MLPHandle, const HTuple& RejectionThreshold);

// Add training samples from an image to the training data of a multilayer perceptron.
LIntExport void AddSamplesImageClassMlp(const HObject& Image, const HObject& ClassRegions, const HTuple& MLPHandle);

// Construct classes for class_ndim_norm.
LIntExport void LearnNdimNorm(const HObject& Foreground, const HObject& Background, const HObject& Image, const HTuple& Metric, const HTuple& Distance, const HTuple& MinNumberPercent, HTuple* Radius, HTuple* Center, HTuple* Quality);

// Train a classificator using a multi-channel image.
LIntExport void LearnNdimBox(const HObject& Foreground, const HObject& Background, const HObject& MultiChannelImage, const HTuple& ClassifHandle);

// Classify pixels using hyper-cuboids.
LIntExport void ClassNdimBox(const HObject& MultiChannelImage, HObject* Regions, const HTuple& ClassifHandle);

// Classify pixels using hyper-spheres or hyper-cubes.
LIntExport void ClassNdimNorm(const HObject& MultiChannelImage, HObject* Regions, const HTuple& Metric, const HTuple& SingleMultiple, const HTuple& Radius, const HTuple& Center);

// Segment an image using two-dimensional pixel classification.
LIntExport void Class2dimSup(const HObject& ImageCol, const HObject& ImageRow, const HObject& FeatureSpace, HObject* RegionClass2Dim);

// Segment two images by clustering.
LIntExport void Class2dimUnsup(const HObject& Image1, const HObject& Image2, HObject* Classes, const HTuple& Threshold, const HTuple& NumClasses);

// Compare two images pixel by pixel.
LIntExport void CheckDifference(const HObject& Image, const HObject& Pattern, HObject* Selected, const HTuple& Mode, const HTuple& DiffLowerBound, const HTuple& DiffUpperBound, const HTuple& GrayOffset, const HTuple& AddRow, const HTuple& AddCol);

// Perform a threshold segmentation for extracting characters.
LIntExport void CharThreshold(const HObject& Image, const HObject& HistoRegion, HObject* Characters, const HTuple& Sigma, const HTuple& Percent, HTuple* Threshold);

// Extract regions with equal gray values from an image.
LIntExport void LabelToRegion(const HObject& LabelImage, HObject* Regions);

// Suppress non-maximum points on an edge.
LIntExport void NonmaxSuppressionAmp(const HObject& ImgAmp, HObject* ImageResult, const HTuple& Mode);

// Suppress non-maximum points on an edge using a direction image.
LIntExport void NonmaxSuppressionDir(const HObject& ImgAmp, const HObject& ImgDir, HObject* ImageResult, const HTuple& Mode);

// Perform a hysteresis threshold operation on an image.
LIntExport void HysteresisThreshold(const HObject& Image, HObject* RegionHysteresis, const HTuple& Low, const HTuple& High, const HTuple& MaxLength);

// Segment an image using binary thresholding.
LIntExport void BinaryThreshold(const HObject& Image, HObject* Region, const HTuple& Method, const HTuple& LightDark, HTuple* UsedThreshold);

// Segment an image using local thresholding.
LIntExport void LocalThreshold(const HObject& Image, HObject* Region, const HTuple& Method, const HTuple& LightDark, const HTuple& GenParamName, const HTuple& GenParamValue);

// Threshold an image by local mean and standard deviation analysis.
LIntExport void VarThreshold(const HObject& Image, HObject* Region, const HTuple& MaskWidth, const HTuple& MaskHeight, const HTuple& StdDevScale, const HTuple& AbsThreshold, const HTuple& LightDark);

// Segment an image using a local threshold.
LIntExport void DynThreshold(const HObject& OrigImage, const HObject& ThresholdImage, HObject* RegionDynThresh, const HTuple& Offset, const HTuple& LightDark);

// Segment an image using global threshold.
LIntExport void Threshold(const HObject& Image, HObject* Region, const HTuple& MinGray, const HTuple& MaxGray);

// Extract level crossings from an image with subpixel accuracy.
LIntExport void ThresholdSubPix(const HObject& Image, HObject* Border, const HTuple& Threshold);

// Segment an image using regiongrowing for multi-channel images.
LIntExport void RegiongrowingN(const HObject& MultiChannelImage, HObject* Regions, const HTuple& Metric, const HTuple& MinTolerance, const HTuple& MaxTolerance, const HTuple& MinSize);

// Segment an image using regiongrowing.
LIntExport void Regiongrowing(const HObject& Image, HObject* Regions, const HTuple& Row, const HTuple& Column, const HTuple& Tolerance, const HTuple& MinSize);

// Perform a regiongrowing using mean gray values.
LIntExport void RegiongrowingMean(const HObject& Image, HObject* Regions, const HTuple& StartRows, const HTuple& StartColumns, const HTuple& Tolerance, const HTuple& MinSize);

// Segment an image by "pouring water" over it.
LIntExport void Pouring(const HObject& Image, HObject* Regions, const HTuple& Mode, const HTuple& MinGray, const HTuple& MaxGray);

// Extract watershed basins from an image using a threshold.
LIntExport void WatershedsThreshold(const HObject& Image, HObject* Basins, const HTuple& Threshold);

// Extract watersheds and basins from an image.
LIntExport void Watersheds(const HObject& Image, HObject* Basins, HObject* Watersheds);

// Extract zero crossings from an image.
LIntExport void ZeroCrossing(const HObject& Image, HObject* RegionCrossing);

// Extract zero crossings from an image with subpixel accuracy.
LIntExport void ZeroCrossingSubPix(const HObject& Image, HObject* ZeroCrossings);

// Threshold operator for signed images.
LIntExport void DualThreshold(const HObject& Image, HObject* RegionCrossings, const HTuple& MinSize, const HTuple& MinGray, const HTuple& Threshold);

// Expand a region starting at a given line.
LIntExport void ExpandLine(const HObject& Image, HObject* RegionExpand, const HTuple& Coordinate, const HTuple& ExpandType, const HTuple& RowColumn, const HTuple& Threshold);

// Detect all local minima in an image.
LIntExport void LocalMin(const HObject& Image, HObject* LocalMinima);

// Detect all gray value lowlands.
LIntExport void Lowlands(const HObject& Image, HObject* Lowlands);

// Detect the centers of all gray value lowlands.
LIntExport void LowlandsCenter(const HObject& Image, HObject* Lowlands);

// Detect all local maxima in an image.
LIntExport void LocalMax(const HObject& Image, HObject* LocalMaxima);

// Detect all gray value plateaus.
LIntExport void Plateaus(const HObject& Image, HObject* Plateaus);

// Detect the centers of all gray value plateaus.
LIntExport void PlateausCenter(const HObject& Image, HObject* Plateaus);

// Determine gray value thresholds from a histogram.
LIntExport void HistoToThresh(const HTuple& Histogramm, const HTuple& Sigma, HTuple* MinThresh, HTuple* MaxThresh);

// Segment an image using thresholds determined from its histogram.
LIntExport void AutoThreshold(const HObject& Image, HObject* Regions, const HTuple& Sigma);

// Segment an image using an automatically determined threshold.
LIntExport void BinThreshold(const HObject& Image, HObject* Region);

// Fast thresholding of images using global thresholds.
LIntExport void FastThreshold(const HObject& Image, HObject* Region, const HTuple& MinGray, const HTuple& MaxGray, const HTuple& MinSize);

// Transform a region in polar coordinates back to cartesian coordinates.
LIntExport void PolarTransRegionInv(const HObject& PolarRegion, HObject* XYTransRegion, const HTuple& Row, const HTuple& Column, const HTuple& AngleStart, const HTuple& AngleEnd, const HTuple& RadiusStart, const HTuple& RadiusEnd, const HTuple& WidthIn, const HTuple& HeightIn, const HTuple& Width, const HTuple& Height, const HTuple& Interpolation);

// Transform a region within an annular arc to polar coordinates.
LIntExport void PolarTransRegion(const HObject& Region, HObject* PolarTransRegion, const HTuple& Row, const HTuple& Column, const HTuple& AngleStart, const HTuple& AngleEnd, const HTuple& RadiusStart, const HTuple& RadiusEnd, const HTuple& Width, const HTuple& Height, const HTuple& Interpolation);

// Merge regions from line scan images.
LIntExport void MergeRegionsLineScan(const HObject& CurrRegions, const HObject& PrevRegions, HObject* CurrMergedRegions, HObject* PrevMergedRegions, const HTuple& ImageHeight, const HTuple& MergeBorder, const HTuple& MaxImagesRegion);

// Partition a region into rectangles of approximately equal size.
LIntExport void PartitionRectangle(const HObject& Region, HObject* Partitioned, const HTuple& Width, const HTuple& Height);

// Partition a region horizontally at positions of small vertical extent.
LIntExport void PartitionDynamic(const HObject& Region, HObject* Partitioned, const HTuple& Distance, const HTuple& Percent);

// Convert regions to a label image.
LIntExport void RegionToLabel(const HObject& Region, HObject* ImageLabel, const HTuple& Type, const HTuple& Width, const HTuple& Height);

// Convert a region into a binary byte-image.
LIntExport void RegionToBin(const HObject& Region, HObject* BinImage, const HTuple& ForegroundGray, const HTuple& BackgroundGray, const HTuple& Width, const HTuple& Height);

// Return the union of two regions.
LIntExport void Union2(const HObject& Region1, const HObject& Region2, HObject* RegionUnion);

// Return the union of all input regions.
LIntExport void Union1(const HObject& Region, HObject* RegionUnion);

// Compute the closest-point transformation of a region.
LIntExport void ClosestPointTransform(const HObject& Region, HObject* Distances, HObject* ClosestPoints, const HTuple& Metric, const HTuple& Foreground, const HTuple& ClosestPointMode, const HTuple& Width, const HTuple& Height);

// Compute the distance transformation of a region.
LIntExport void DistanceTransform(const HObject& Region, HObject* DistanceImage, const HTuple& Metric, const HTuple& Foreground, const HTuple& Width, const HTuple& Height);

// Compute the skeleton of a region.
LIntExport void Skeleton(const HObject& Region, HObject* Skeleton);

// Apply a projective transformation to a region.
LIntExport void ProjectiveTransRegion(const HObject& Regions, HObject* TransRegions, const HTuple& HomMat2D, const HTuple& Interpolation);

// Apply an arbitrary affine 2D transformation to regions.
LIntExport void AffineTransRegion(const HObject& Region, HObject* RegionAffineTrans, const HTuple& HomMat2D, const HTuple& Interpolate);

// Reflect a region about an axis.
LIntExport void MirrorRegion(const HObject& Region, HObject* RegionMirror, const HTuple& Mode, const HTuple& WidthHeight);

// Zoom a region.
LIntExport void ZoomRegion(const HObject& Region, HObject* RegionZoom, const HTuple& ScaleWidth, const HTuple& ScaleHeight);

// Translate a region.
LIntExport void MoveRegion(const HObject& Region, HObject* RegionMoved, const HTuple& Row, const HTuple& Column);

// Find junctions and end points in a skeleton.
LIntExport void JunctionsSkeleton(const HObject& Region, HObject* EndPoints, HObject* JuncPoints);

// Calculate the intersection of two regions.
LIntExport void Intersection(const HObject& Region1, const HObject& Region2, HObject* RegionIntersection);

// Partition the image plane using given regions.
LIntExport void Interjacent(const HObject& Region, HObject* RegionInterjacent, const HTuple& Mode);

// Fill up holes in regions.
LIntExport void FillUp(const HObject& Region, HObject* RegionFillUp);

// Fill up holes in regions having given shape features.
LIntExport void FillUpShape(const HObject& Region, HObject* RegionFillUp, const HTuple& Feature, const HTuple& Min, const HTuple& Max);

// Fill gaps between regions or split overlapping regions.
LIntExport void ExpandRegion(const HObject& Regions, const HObject& ForbiddenArea, HObject* RegionExpanded, const HTuple& Iterations, const HTuple& Mode);

// Clip a region relative to its smallest surrounding rectangle.
LIntExport void ClipRegionRel(const HObject& Region, HObject* RegionClipped, const HTuple& Top, const HTuple& Bottom, const HTuple& Left, const HTuple& Right);

// Clip a region to a rectangle.
LIntExport void ClipRegion(const HObject& Region, HObject* RegionClipped, const HTuple& Row1, const HTuple& Column1, const HTuple& Row2, const HTuple& Column2);

// Rank operator for regions.
LIntExport void RankRegion(const HObject& Region, HObject* RegionCount, const HTuple& Width, const HTuple& Height, const HTuple& Number);

// Compute connected components of a region.
LIntExport void Connection(const HObject& Region, HObject* ConnectedRegions);

// Calculate the symmetric difference of two regions.
LIntExport void SymmDifference(const HObject& Region1, const HObject& Region2, HObject* RegionDifference);

// Calculate the difference of two regions.
LIntExport void Difference(const HObject& Region, const HObject& Sub, HObject* RegionDifference);

// Return the complement of a region.
LIntExport void Complement(const HObject& Region, HObject* RegionComplement);

// Determine the connected components of the background of given regions.
LIntExport void BackgroundSeg(const HObject& Foreground, HObject* BackgroundRegions);

// Generate a region having a given Hamming distance.
LIntExport void HammingChangeRegion(const HObject& InputRegion, HObject* OutputRegion, const HTuple& Width, const HTuple& Height, const HTuple& Distance);

// Remove noise from a region.
LIntExport void RemoveNoiseRegion(const HObject& InputRegion, HObject* OutputRegion, const HTuple& Type);

// Transform the shape of a region.
LIntExport void ShapeTrans(const HObject& Region, HObject* RegionTrans, const HTuple& Type);

// Fill gaps between regions (depending on gray value or color) or split overlapping regions.
LIntExport void ExpandGray(const HObject& Regions, const HObject& Image, const HObject& ForbiddenArea, HObject* RegionExpand, const HTuple& Iterations, const HTuple& Mode, const HTuple& Threshold);

// Fill gaps between regions (depending on gray value or color) or split overlapping regions.
LIntExport void ExpandGrayRef(const HObject& Regions, const HObject& Image, const HObject& ForbiddenArea, HObject* RegionExpand, const HTuple& Iterations, const HTuple& Mode, const HTuple& RefGray, const HTuple& Threshold);

// Split lines represented by one pixel wide, non-branching lines.
LIntExport void SplitSkeletonLines(const HObject& SkeletonRegion, const HTuple& MaxDistance, HTuple* BeginRow, HTuple* BeginCol, HTuple* EndRow, HTuple* EndCol);

// Split lines represented by one pixel wide, non-branching regions.
LIntExport void SplitSkeletonRegion(const HObject& SkeletonRegion, HObject* RegionLines, const HTuple& MaxDistance);

// Convert a histogram into a region.
LIntExport void GenRegionHisto(HObject* Region, const HTuple& Histogram, const HTuple& Row, const HTuple& Column, const HTuple& Scale);

// Eliminate runs of a given length.
LIntExport void EliminateRuns(const HObject& Region, HObject* RegionClipped, const HTuple& ElimShorter, const HTuple& ElimLonger);

// Calculate the 3D surface normals of a 3D object model.
LIntExport void SurfaceNormalsObjectModel3d(const HTuple& ObjectModel3D, const HTuple& Method, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* ObjectModel3DNormals);

// Smooth the 3D points of a 3D object model.
LIntExport void SmoothObjectModel3d(const HTuple& ObjectModel3D, const HTuple& Method, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* SmoothObjectModel3D);

// Create a surface triangulation for a 3D object model.
LIntExport void TriangulateObjectModel3d(const HTuple& ObjectModel3D, const HTuple& Method, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* TriangulatedObjectModel3D, HTuple* Information);

// Free the memory of all stereo models.
LIntExport void ClearAllStereoModels();

// Free the memory of a stereo model.
LIntExport void ClearStereoModel(const HTuple& StereoModelID);

// Reconstruct 3D points from calibrated multi-view stereo images.
LIntExport void ReconstructPointsStereo(const HTuple& StereoModelID, const HTuple& Row, const HTuple& Column, const HTuple& CovIP, const HTuple& CameraIdx, const HTuple& PointIdx, HTuple* X, HTuple* Y, HTuple* Z, HTuple* CovWP, HTuple* PointIdxOut);

// Reconstruct surface from calibrated multi-view stereo images.
LIntExport void ReconstructSurfaceStereo(const HObject& Images, const HTuple& StereoModelID, HTuple* ObjectModel3D);

// Get intermediate iconic results of a stereo reconstruction.
LIntExport void GetStereoModelObject(HObject* Object, const HTuple& StereoModelID, const HTuple& PairIndex, const HTuple& ObjectName);

// Return the list of image pairs set in a stereo model.
LIntExport void GetStereoModelImagePairs(const HTuple& StereoModelID, HTuple* From, HTuple* To);

// Specify image pairs to be used for surface stereo reconstruction.
LIntExport void SetStereoModelImagePairs(const HTuple& StereoModelID, const HTuple& From, const HTuple& To);

// Get stereo model parameters.
LIntExport void GetStereoModelParam(const HTuple& StereoModelID, const HTuple& ParamName, HTuple* ParamValue);

// Set stereo model parameters.
LIntExport void SetStereoModelParam(const HTuple& StereoModelID, const HTuple& ParamName, const HTuple& ParamValue);

// Create a HALCON stereo model.
LIntExport void CreateStereoModel(const HTuple& CameraSetupModelID, const HTuple& Method, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* StereoModelID);

// Query message queue parameters or information about the queue.
LIntExport void GetMessageQueueParam(const HTuple& QueueHandle, const HTuple& GenParamName, HTuple* GenParamValue);

// Set message queue parameters or invokes commands on the queue.
LIntExport void SetMessageQueueParam(const HTuple& QueueHandle, const HTuple& GenParamName, const HTuple& GenParamValue);

// Receive one or more messages from the message queue.
LIntExport void DequeueMessage(const HTuple& QueueHandle, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* MessageHandle);

// Enqueue one or more messages to the message queue.
LIntExport void EnqueueMessage(const HTuple& QueueHandle, const HTuple& MessageHandle, const HTuple& GenParamName, const HTuple& GenParamValue);

// Close a message queue handle and release all associated resources.
LIntExport void ClearMessageQueue(const HTuple& QueueHandle);

// Create a new empty message queue.
LIntExport void CreateMessageQueue(HTuple* QueueHandle);

// Query message parameters or information about the message.
LIntExport void GetMessageParam(const HTuple& MessageHandle, const HTuple& GenParamName, const HTuple& Key, HTuple* GenParamValue);

// Set message parameter or invoke commands on the message.
LIntExport void SetMessageParam(const HTuple& MessageHandle, const HTuple& GenParamName, const HTuple& Key, const HTuple& GenParamValue);

// Retrieve an object associated with the key from the message.
LIntExport void GetMessageObj(HObject* ObjectData, const HTuple& MessageHandle, const HTuple& Key);

// Add a key/object pair to the message.
LIntExport void SetMessageObj(const HObject& ObjectData, const HTuple& MessageHandle, const HTuple& Key);

// Retrieve a tuple associated with the key from the message.
LIntExport void GetMessageTuple(const HTuple& MessageHandle, const HTuple& Key, HTuple* TupleData);

// Add a key/tuple pair to the message.
LIntExport void SetMessageTuple(const HTuple& MessageHandle, const HTuple& Key, const HTuple& TupleData);

// Close a message handle and release all associated resources.
LIntExport void ClearMessage(const HTuple& MessageHandle);

// Create a new empty message.
LIntExport void CreateMessage(HTuple* MessageHandle);

// Destroy all condition synchronization objects.
LIntExport void ClearAllConditions();

// Destroy a condition synchronization object.
LIntExport void ClearCondition(const HTuple& ConditionHandle);

// Signal a condition synchronization object.
LIntExport void BroadcastCondition(const HTuple& ConditionHandle);

// Signal a condition synchronization object.
LIntExport void SignalCondition(const HTuple& ConditionHandle);

// Bounded wait on the signal of a condition synchronization object.
LIntExport void TimedWaitCondition(const HTuple& ConditionHandle, const HTuple& MutexHandle, const HTuple& Timeout);

// wait on the signal of a condition synchronization object.
LIntExport void WaitCondition(const HTuple& ConditionHandle, const HTuple& MutexHandle);

// Create a condition variable synchronization object.
LIntExport void CreateCondition(const HTuple& AttribName, const HTuple& AttribValue, HTuple* ConditionHandle);

// Destroy all barrier synchronization objects.
LIntExport void ClearAllBarriers();

// Destroy a barrier synchronization object.
LIntExport void ClearBarrier(const HTuple& BarrierHandle);

// Wait on the release of a barrier synchronization object.
LIntExport void WaitBarrier(const HTuple& BarrierHandle);

// Create a barrier synchronization object.
LIntExport void CreateBarrier(const HTuple& AttribName, const HTuple& AttribValue, const HTuple& TeamSize, HTuple* BarrierHandle);

// Clear all event synchronization objects.
LIntExport void ClearAllEvents();

// Clear the event synchronization object.
LIntExport void ClearEvent(const HTuple& EventHandle);

// Unlock an event synchronization object. 
LIntExport void SignalEvent(const HTuple& EventHandle);

// Lock an event synchronization object only it is unlocked.
LIntExport void TryWaitEvent(const HTuple& EventHandle, HTuple* Busy);

// Lock an event synchronization object.
LIntExport void WaitEvent(const HTuple& EventHandle);

// Create an event synchronization object.
LIntExport void CreateEvent(const HTuple& AttribName, const HTuple& AttribValue, HTuple* EventHandle);

// Clear all mutex synchronization objects.
LIntExport void ClearAllMutexes();

// Clear the mutex synchronization object.
LIntExport void ClearMutex(const HTuple& MutexHandle);

// Unlock a mutex synchronization object.
LIntExport void UnlockMutex(const HTuple& MutexHandle);

// Lock a mutex synchronization object.
LIntExport void TryLockMutex(const HTuple& MutexHandle, HTuple* Busy);

// Lock a mutex synchronization object.
LIntExport void LockMutex(const HTuple& MutexHandle);

// Create a mutual exclusion synchronization object.
LIntExport void CreateMutex(const HTuple& AttribName, const HTuple& AttribValue, HTuple* MutexHandle);

// Query the attributes of a threading / synchronization object.
LIntExport void GetThreadingAttrib(const HTuple& ThreadingHandle, HTuple* ThreadingClass, HTuple* AttribName, HTuple* AttribValue);

// Load knowledge about automatic parallelization from file.
LIntExport void LoadParKnowledge(const HTuple& FileName);

// Store knowledge about automatic parallelization in file.
LIntExport void StoreParKnowledge(const HTuple& FileName);

// Check hardware regarding its potential for parallel processing.
LIntExport void CheckParHwPotential(const HTuple& AllInpPars);

// Set AOP information for operators.
LIntExport void SetAopInfo(const HTuple& OperatorName, const HTuple& IndexName, const HTuple& IndexValue, const HTuple& InfoName, const HTuple& InfoValue);

// Return AOP information for operators. 
LIntExport void GetAopInfo(const HTuple& OperatorName, const HTuple& IndexName, const HTuple& IndexValue, const HTuple& InfoName, HTuple* InfoValue);

// Query indexing struxture of AOP information for operators. 
LIntExport void QueryAopInfo(const HTuple& OperatorName, const HTuple& IndexName, const HTuple& IndexValue, HTuple* Name, HTuple* Value);

// Check hardware regarding its potential for automatic operator parallelization.
LIntExport void OptimizeAop(const HTuple& OperatorName, const HTuple& IconicType, const HTuple& FileName, const HTuple& ParamName, const HTuple& ParamValue);

// Write knowledge about hardware dependent behavior of automatic operator parallelization to file.
LIntExport void WriteAopKnowledge(const HTuple& FileName, const HTuple& ParamName, const HTuple& ParamValue);

// Load knowledge about hardware dependent behavior of automatic operator parallelization.
LIntExport void ReadAopKnowledge(const HTuple& FileName, const HTuple& ParamName, const HTuple& ParamValue, HTuple* Attributes, HTuple* OperatorNames);

// 
LIntExport void SensorKalman(const HTuple& Dimension, const HTuple& MeasurementIn, HTuple* MeasurementOut);

// 
LIntExport void TestObjDef(const HObject& Object, HTuple* IsDefined);

// 
LIntExport void TestAccess(const HObject& Object, HObject* Dummy, const HTuple& NumReadChord, const HTuple& NumCopyObj, const HTuple& Write_chord);

// Calculate the difference of two object tuples.
LIntExport void ObjDiff(const HObject& Objects, const HObject& ObjectsSub, HObject* ObjectsDiff);

// Set single gray values in an image.
LIntExport void SetGrayval(const HObject& Image, const HTuple& Row, const HTuple& Column, const HTuple& Grayval);

// Paint XLD objects into an image.
LIntExport void PaintXld(const HObject& XLD, const HObject& Image, HObject* ImageResult, const HTuple& Grayval);

// Paint regions into an image.
LIntExport void PaintRegion(const HObject& Region, const HObject& Image, HObject* ImageResult, const HTuple& Grayval, const HTuple& Type);

// Overpaint regions in an image.
LIntExport void OverpaintRegion(const HObject& Image, const HObject& Region, const HTuple& Grayval, const HTuple& Type);

// Create an image with a specified constant gray value.
LIntExport void GenImageProto(const HObject& Image, HObject* ImageCleared, const HTuple& Grayval);

// Paint the gray values of an image into another image.
LIntExport void PaintGray(const HObject& ImageSource, const HObject& ImageDestination, HObject* MixedImage);

// Overpaint the gray values of an image.
LIntExport void OverpaintGray(const HObject& ImageDestination, const HObject& ImageSource);

// Convert an "integer number" into an iconic object.
LIntExport void IntegerToObj(HObject* Objects, const HTuple& SurrogateTuple);

// Convert an iconic object into an "integer number."
LIntExport void ObjToInteger(const HObject& Objects, const HTuple& Index, const HTuple& Number, HTuple* SurrogateTuple);

// Copy an iconic object in the HALCON database.
LIntExport void CopyObj(const HObject& Objects, HObject* ObjectsSelected, const HTuple& Index, const HTuple& NumObj);

// Concatenate two iconic object tuples.
LIntExport void ConcatObj(const HObject& Objects1, const HObject& Objects2, HObject* ObjectsConcat);

// Delete an iconic object from the HALCON database.
LIntExport void ClearObj(const HObject& Objects);

// Copy an image and allocate new memory for it.
LIntExport void CopyImage(const HObject& Image, HObject* DupImage);

// Select objects from an object tuple.
LIntExport void SelectObj(const HObject& Objects, HObject* ObjectSelected, const HTuple& Index);

// Compare iconic objects regarding equality.
LIntExport void CompareObj(const HObject& Objects1, const HObject& Objects2, const HTuple& Epsilon, HTuple* IsEqual);

// Test whether a region is contained in another region.
LIntExport void TestSubsetRegion(const HObject& Region1, const HObject& Region2, HTuple* IsSubset);

// Test whether the regions of two objects are identical.
LIntExport void TestEqualRegion(const HObject& Regions1, const HObject& Regions2, HTuple* IsEqual);

// Compare image objects regarding equality.
LIntExport void TestEqualObj(const HObject& Objects1, const HObject& Objects2, HTuple* IsEqual);

// Number of objects in a tuple.
LIntExport void CountObj(const HObject& Objects, HTuple* Number);

// Informations about the components of an image object.
LIntExport void GetChannelInfo(const HObject& Object, const HTuple& Request, const HTuple& Channel, HTuple* Information);

// Name of the class of an image object.
LIntExport void GetObjClass(const HObject& Object, HTuple* Class);

// Create a three-channel image from a pointer to the interleaved pixels.
LIntExport void GenImageInterleaved(HObject* ImageRGB, const HTuple& PixelPointer, const HTuple& ColorFormat, const HTuple& OriginalWidth, const HTuple& OriginalHeight, const HTuple& Alignment, const HTuple& Type, const HTuple& ImageWidth, const HTuple& ImageHeight, const HTuple& StartRow, const HTuple& StartColumn, const HTuple& BitsPerChannel, const HTuple& BitShift);

// Create a region from an XLD polygon.
LIntExport void GenRegionPolygonXld(const HObject& Polygon, HObject* Region, const HTuple& Mode);

// Create a region from an XLD contour.
LIntExport void GenRegionContourXld(const HObject& Contour, HObject* Region, const HTuple& Mode);

// Store a polygon as a "filled" region.
LIntExport void GenRegionPolygonFilled(HObject* Region, const HTuple& Rows, const HTuple& Columns);

// Store a polygon as a region.
LIntExport void GenRegionPolygon(HObject* Region, const HTuple& Rows, const HTuple& Columns);

// Store individual pixels as image region.
LIntExport void GenRegionPoints(HObject* Region, const HTuple& Rows, const HTuple& Columns);

// Create a region from a runlength coding.
LIntExport void GenRegionRuns(HObject* Region, const HTuple& Row, const HTuple& ColumnBegin, const HTuple& ColumnEnd);

// Create a rectangle of any orientation.
LIntExport void GenRectangle2(HObject* Rectangle, const HTuple& Row, const HTuple& Column, const HTuple& Phi, const HTuple& Length1, const HTuple& Length2);

// Create a rectangle parallel to the coordinate axes.
LIntExport void GenRectangle1(HObject* Rectangle, const HTuple& Row1, const HTuple& Column1, const HTuple& Row2, const HTuple& Column2);

// Create a random region.
LIntExport void GenRandomRegion(HObject* RegionRandom, const HTuple& Width, const HTuple& Height);

// Create an image from three pointers to the pixels (red/green/blue).
LIntExport void GenImage3(HObject* ImageRGB, const HTuple& Type, const HTuple& Width, const HTuple& Height, const HTuple& PixelPointerRed, const HTuple& PixelPointerGreen, const HTuple& PixelPointerBlue);

// Create an image from a pointer to the pixels.
LIntExport void GenImage1(HObject* Image, const HTuple& Type, const HTuple& Width, const HTuple& Height, const HTuple& PixelPointer);

// Create an image with constant gray value.
LIntExport void GenImageConst(HObject* Image, const HTuple& Type, const HTuple& Width, const HTuple& Height);

// Create an ellipse sector.
LIntExport void GenEllipseSector(HObject* EllipseSector, const HTuple& Row, const HTuple& Column, const HTuple& Phi, const HTuple& Radius1, const HTuple& Radius2, const HTuple& StartAngle, const HTuple& EndAngle);

// Create an ellipse.
LIntExport void GenEllipse(HObject* Ellipse, const HTuple& Row, const HTuple& Column, const HTuple& Phi, const HTuple& Radius1, const HTuple& Radius2);

// Create a circle sector.
LIntExport void GenCircleSector(HObject* CircleSector, const HTuple& Row, const HTuple& Column, const HTuple& Radius, const HTuple& StartAngle, const HTuple& EndAngle);

// Create a circle.
LIntExport void GenCircle(HObject* Circle, const HTuple& Row, const HTuple& Column, const HTuple& Radius);

// Create a checkered region.
LIntExport void GenCheckerRegion(HObject* RegionChecker, const HTuple& WidthRegion, const HTuple& HeightRegion, const HTuple& WidthPattern, const HTuple& HeightPattern);

// Create a region from lines or pixels.
LIntExport void GenGridRegion(HObject* RegionGrid, const HTuple& RowSteps, const HTuple& ColumnSteps, const HTuple& Type, const HTuple& Width, const HTuple& Height);

// Create random regions like circles, rectangles and ellipses.
LIntExport void GenRandomRegions(HObject* Regions, const HTuple& Type, const HTuple& WidthMin, const HTuple& WidthMax, const HTuple& HeightMin, const HTuple& HeightMax, const HTuple& PhiMin, const HTuple& PhiMax, const HTuple& NumRegions, const HTuple& Width, const HTuple& Height);

// Store input lines described in Hesse normal form as regions.
LIntExport void GenRegionHline(HObject* Regions, const HTuple& Orientation, const HTuple& Distance);

// Store input lines as regions.
LIntExport void GenRegionLine(HObject* RegionLines, const HTuple& BeginRow, const HTuple& BeginCol, const HTuple& EndRow, const HTuple& EndCol);

// Create an empty object tuple.
LIntExport void GenEmptyObj(HObject* EmptyObject);

// Create an empty region.
LIntExport void GenEmptyRegion(HObject* EmptyRegion);

// Create a gray value ramp.
LIntExport void GenImageGrayRamp(HObject* ImageGrayRamp, const HTuple& Alpha, const HTuple& Beta, const HTuple& Mean, const HTuple& Row, const HTuple& Column, const HTuple& Width, const HTuple& Height);

// Create a three-channel image from three pointers on the pixels with storage management.
LIntExport void GenImage3Extern(HObject* Image, const HTuple& Type, const HTuple& Width, const HTuple& Height, const HTuple& PointerRed, const HTuple& PointerGreen, const HTuple& PointerBlue, const HTuple& ClearProc);

// Create an image from a pointer on the pixels with storage management.
LIntExport void GenImage1Extern(HObject* Image, const HTuple& Type, const HTuple& Width, const HTuple& Height, const HTuple& PixelPointer, const HTuple& ClearProc);

// Create an image with a rectangular domain from a pointer on the pixels (with storage management).
LIntExport void GenImage1Rect(HObject* Image, const HTuple& PixelPointer, const HTuple& Width, const HTuple& Height, const HTuple& VerticalPitch, const HTuple& HorizontalBitPitch, const HTuple& BitsPerPixel, const HTuple& DoCopy, const HTuple& ClearProc);

// Access to the image data pointer and the image data inside the smallest rectangle of the domain of the input image.
LIntExport void GetImagePointer1Rect(const HObject& Image, HTuple* PixelPointer, HTuple* Width, HTuple* Height, HTuple* VerticalPitch, HTuple* HorizontalBitPitch, HTuple* BitsPerPixel);

// Access the pointers of a colored image.
LIntExport void GetImagePointer3(const HObject& ImageRGB, HTuple* PointerRed, HTuple* PointerGreen, HTuple* PointerBlue, HTuple* Type, HTuple* Width, HTuple* Height);

// Access the pointer of a channel.
LIntExport void GetImagePointer1(const HObject& Image, HTuple* Pointer, HTuple* Type, HTuple* Width, HTuple* Height);

// Return the type of an image.
LIntExport void GetImageType(const HObject& Image, HTuple* Type);

// Return the size of an image.
LIntExport void GetImageSize(const HObject& Image, HTuple* Width, HTuple* Height);

// Request time at which the image was created.
LIntExport void GetImageTime(const HObject& Image, HTuple* MSecond, HTuple* Second, HTuple* Minute, HTuple* Hour, HTuple* Day, HTuple* YDay, HTuple* Month, HTuple* Year);

// Return gray values of an image at the positions given by tuples of rows and columns.
LIntExport void GetGrayvalInterpolated(const HObject& Image, const HTuple& Row, const HTuple& Column, const HTuple& Interpolation, HTuple* Grayval);

// Access the gray values of an image object.
LIntExport void GetGrayval(const HObject& Image, const HTuple& Row, const HTuple& Column, HTuple* Grayval);

// Access the thickness of a region along the main axis.
LIntExport void GetRegionThickness(const HObject& Region, HTuple* Thickness, HTuple* Histogramm);

// Polygon approximation of a region.
LIntExport void GetRegionPolygon(const HObject& Region, const HTuple& Tolerance, HTuple* Rows, HTuple* Columns);

// Access the pixels of a region.
LIntExport void GetRegionPoints(const HObject& Region, HTuple* Rows, HTuple* Columns);

// Access the contour of an object.
LIntExport void GetRegionContour(const HObject& Region, HTuple* Rows, HTuple* Columns);

// Access the runlength coding of a region.
LIntExport void GetRegionRuns(const HObject& Region, HTuple* Row, HTuple* ColumnBegin, HTuple* ColumnEnd);

// Contour of an object as chain code.
LIntExport void GetRegionChain(const HObject& Region, HTuple* Row, HTuple* Column, HTuple* Chain);

// Access convex hull as contour.
LIntExport void GetRegionConvex(const HObject& Region, HTuple* Rows, HTuple* Columns);

// Verification of a pattern using an OCV tool.
LIntExport void DoOcvSimple(const HObject& Pattern, const HTuple& OCVHandle, const HTuple& PatternName, const HTuple& AdaptPos, const HTuple& AdaptSize, const HTuple& AdaptAngle, const HTuple& AdaptGray, const HTuple& Threshold, HTuple* Quality);

// Training of an OCV tool.
LIntExport void TraindOcvProj(const HObject& Pattern, const HTuple& OCVHandle, const HTuple& Name, const HTuple& Mode);

// Deserialize a serialized OCV tool.
LIntExport void DeserializeOcv(const HTuple& SerializedItemHandle, HTuple* OCVHandle);

// Serialize an OCV tool.
LIntExport void SerializeOcv(const HTuple& OCVHandle, HTuple* SerializedItemHandle);

// Reading an OCV tool from file.
LIntExport void ReadOcv(const HTuple& FileName, HTuple* OCVHandle);

// Saving an OCV tool to file.
LIntExport void WriteOcv(const HTuple& OCVHandle, const HTuple& FileName);

// Clear all OCV tools.
LIntExport void CloseAllOcvs();

// Clear an OCV tool.
LIntExport void CloseOcv(const HTuple& OCVHandle);

// Create a new OCV tool based on gray value projections.
LIntExport void CreateOcvProj(const HTuple& PatternNames, HTuple* OCVHandle);

// Classify a related group of characters with an OCR classifier.
LIntExport void DoOcrWordKnn(const HObject& Character, const HObject& Image, const HTuple& OCRHandle, const HTuple& Expression, const HTuple& NumAlternatives, const HTuple& NumCorrections, HTuple* Class, HTuple* Confidence, HTuple* Word, HTuple* Score);

// Deserialize a serialized k-NN-based OCR classifier.
LIntExport void DeserializeOcrClassKnn(const HTuple& SerializedItemHandle, HTuple* OCRHandle);

// Serialize a k-NN-based OCR classifier.
LIntExport void SerializeOcrClassKnn(const HTuple& OCRHandle, HTuple* SerializedItemHandle);

// Read an OCR classifier from a file.
LIntExport void ReadOcrClassKnn(const HTuple& FileName, HTuple* OCRHandle);

// Write a k-NN classifier for an OCR task to a file.
LIntExport void WriteOcrClassKnn(const HTuple& OCRHandle, const HTuple& FileName);

// Clear all OCR classifiers.
LIntExport void ClearAllOcrClassKnn();

// Clear an OCR classifier.
LIntExport void ClearOcrClassKnn(const HTuple& OCRHandle);

// Create an OCR classifier using a k-Nearest Neighbor (k-NN) classifier.
LIntExport void CreateOcrClassKnn(const HTuple& WidthCharacter, const HTuple& HeightCharacter, const HTuple& Interpolation, const HTuple& Features, const HTuple& Characters, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* OCRHandle);

// Trains an k-NN classifier for an OCR task.
LIntExport void TrainfOcrClassKnn(const HTuple& OCRHandle, const HTuple& TrainingFile, const HTuple& GenParamNames, const HTuple& GenParamValues);

// Compute the features of a character.
LIntExport void GetFeaturesOcrClassKnn(const HObject& Character, const HTuple& OCRHandle, const HTuple& Transform, HTuple* Features);

// Return the parameters of an OCR classifier.
LIntExport void GetParamsOcrClassKnn(const HTuple& OCRHandle, HTuple* WidthCharacter, HTuple* HeightCharacter, HTuple* Interpolation, HTuple* Features, HTuple* Characters, HTuple* Preprocessing, HTuple* NumTrees);

// Classify multiple characters with an k-NN classifier.
LIntExport void DoOcrMultiClassKnn(const HObject& Character, const HObject& Image, const HTuple& OCRHandle, HTuple* Class, HTuple* Confidence);

// Classify a single character with an OCR classifier.
LIntExport void DoOcrSingleClassKnn(const HObject& Character, const HObject& Image, const HTuple& OCRHandle, const HTuple& NumClasses, const HTuple& NumNeighbors, HTuple* Class, HTuple* Confidence);

// Select an optimal combination of features to classify OCR data.
LIntExport void SelectFeatureSetTrainfKnn(const HTuple& TrainingFile, const HTuple& FeatureList, const HTuple& SelectionMethod, const HTuple& Width, const HTuple& Height, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* OCRHandle, HTuple* FeatureSet, HTuple* Score);

// Select an optimal combination of features to classify OCR data from a (protected) training file.
LIntExport void SelectFeatureSetTrainfMlpProtected(const HTuple& TrainingFile, const HTuple& Password, const HTuple& FeatureList, const HTuple& SelectionMethod, const HTuple& Width, const HTuple& Height, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* OCRHandle, HTuple* FeatureSet, HTuple* Score);

// Selects an optimal combination of features to classify OCR data.
LIntExport void SelectFeatureSetTrainfMlp(const HTuple& TrainingFile, const HTuple& FeatureList, const HTuple& SelectionMethod, const HTuple& Width, const HTuple& Height, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* OCRHandle, HTuple* FeatureSet, HTuple* Score);

// Select an optimal combination of features to classify OCR data from a (protected) training file.
LIntExport void SelectFeatureSetTrainfSvmProtected(const HTuple& TrainingFile, const HTuple& Password, const HTuple& FeatureList, const HTuple& SelectionMethod, const HTuple& Width, const HTuple& Height, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* OCRHandle, HTuple* FeatureSet, HTuple* Score);

// Selects an optimal combination of features to classify OCR  data.
LIntExport void SelectFeatureSetTrainfSvm(const HTuple& TrainingFile, const HTuple& FeatureList, const HTuple& SelectionMethod, const HTuple& Width, const HTuple& Height, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* OCRHandle, HTuple* FeatureSet, HTuple* Score);

// Clear all lexica.
LIntExport void ClearAllLexica();

// Clear a lexicon.
LIntExport void ClearLexicon(const HTuple& LexiconHandle);

// Find a similar word in a lexicon.
LIntExport void SuggestLexicon(const HTuple& LexiconHandle, const HTuple& Word, HTuple* Suggestion, HTuple* NumCorrections);

// Check if a word is contained in a lexicon.
LIntExport void LookupLexicon(const HTuple& LexiconHandle, const HTuple& Word, HTuple* Found);

// Query all words from a lexicon.
LIntExport void InspectLexicon(const HTuple& LexiconHandle, HTuple* Words);

// Create a lexicon from a text file.
LIntExport void ImportLexicon(const HTuple& Name, const HTuple& FileName, HTuple* LexiconHandle);

// Create a lexicon from a tuple of words.
LIntExport void CreateLexicon(const HTuple& Name, const HTuple& Words, HTuple* LexiconHandle);

// Clear all SVM based OCR classifiers.
LIntExport void ClearAllOcrClassSvm();

// Clear an SVM-based OCR classifier.
LIntExport void ClearOcrClassSvm(const HTuple& OCRHandle);

// Deserialize a serialized SVM-based OCR classifier.
LIntExport void DeserializeOcrClassSvm(const HTuple& SerializedItemHandle, HTuple* OCRHandle);

// Serialize a SVM-based OCR classifier
LIntExport void SerializeOcrClassSvm(const HTuple& OCRHandle, HTuple* SerializedItemHandle);

// Read a SVM-based OCR classifier from a file.
LIntExport void ReadOcrClassSvm(const HTuple& FileName, HTuple* OCRHandle);

// Write an OCR classifier to a file.
LIntExport void WriteOcrClassSvm(const HTuple& OCRHandle, const HTuple& FileName);

// Compute the features of a character.
LIntExport void GetFeaturesOcrClassSvm(const HObject& Character, const HTuple& OCRHandle, const HTuple& Transform, HTuple* Features);

// Classify a related group of characters with an OCR classifier.
LIntExport void DoOcrWordSvm(const HObject& Character, const HObject& Image, const HTuple& OCRHandle, const HTuple& Expression, const HTuple& NumAlternatives, const HTuple& NumCorrections, HTuple* Class, HTuple* Word, HTuple* Score);

// Classify multiple characters with an SVM-based OCR classifier.
LIntExport void DoOcrMultiClassSvm(const HObject& Character, const HObject& Image, const HTuple& OCRHandle, HTuple* Class);

// Classify a single character with an SVM-based OCR classifier.
LIntExport void DoOcrSingleClassSvm(const HObject& Character, const HObject& Image, const HTuple& OCRHandle, const HTuple& Num, HTuple* Class);

// Approximate a trained SVM-based OCR classifier by a reduced SVM.
LIntExport void ReduceOcrClassSvm(const HTuple& OCRHandle, const HTuple& Method, const HTuple& MinRemainingSV, const HTuple& MaxError, HTuple* OCRHandleReduced);

// Train an OCR classifier with data from a (protected) training file.
LIntExport void TrainfOcrClassSvmProtected(const HTuple& OCRHandle, const HTuple& TrainingFile, const HTuple& Password, const HTuple& Epsilon, const HTuple& TrainMode);

// Train an OCR classifier.
LIntExport void TrainfOcrClassSvm(const HTuple& OCRHandle, const HTuple& TrainingFile, const HTuple& Epsilon, const HTuple& TrainMode);

// Compute the information content of the preprocessed feature vectors of an SVM-based OCR classifier.
LIntExport void GetPrepInfoOcrClassSvm(const HTuple& OCRHandle, const HTuple& TrainingFile, const HTuple& Preprocessing, HTuple* InformationCont, HTuple* CumInformationCont);

// Return the number of support vectors of an OCR classifier.
LIntExport void GetSupportVectorNumOcrClassSvm(const HTuple& OCRHandle, HTuple* NumSupportVectors, HTuple* NumSVPerSVM);

// Return the index of a support vector from a trained OCR classifier that is based on support vector machines.
LIntExport void GetSupportVectorOcrClassSvm(const HTuple& OCRHandle, const HTuple& IndexSupportVector, HTuple* Index);

// Return the parameters of an OCR classifier.
LIntExport void GetParamsOcrClassSvm(const HTuple& OCRHandle, HTuple* WidthCharacter, HTuple* HeightCharacter, HTuple* Interpolation, HTuple* Features, HTuple* Characters, HTuple* KernelType, HTuple* KernelParam, HTuple* Nu, HTuple* Mode, HTuple* Preprocessing, HTuple* NumComponents);

// Create an OCR classifier using a support vector machine.
LIntExport void CreateOcrClassSvm(const HTuple& WidthCharacter, const HTuple& HeightCharacter, const HTuple& Interpolation, const HTuple& Features, const HTuple& Characters, const HTuple& KernelType, const HTuple& KernelParam, const HTuple& Nu, const HTuple& Mode, const HTuple& Preprocessing, const HTuple& NumComponents, HTuple* OCRHandle);

// Clear all OCR classifiers.
LIntExport void ClearAllOcrClassMlp();

// Clear an OCR classifier.
LIntExport void ClearOcrClassMlp(const HTuple& OCRHandle);

// Deserialize a serialized MLP-based OCR classifier.
LIntExport void DeserializeOcrClassMlp(const HTuple& SerializedItemHandle, HTuple* OCRHandle);

// Serialize a MLP-based OCR classifier.
LIntExport void SerializeOcrClassMlp(const HTuple& OCRHandle, HTuple* SerializedItemHandle);

// Read an OCR classifier from a file.
LIntExport void ReadOcrClassMlp(const HTuple& FileName, HTuple* OCRHandle);

// Write an OCR classifier to a file.
LIntExport void WriteOcrClassMlp(const HTuple& OCRHandle, const HTuple& FileName);

// Compute the features of a character.
LIntExport void GetFeaturesOcrClassMlp(const HObject& Character, const HTuple& OCRHandle, const HTuple& Transform, HTuple* Features);

// Classify a related group of characters with an OCR classifier.
LIntExport void DoOcrWordMlp(const HObject& Character, const HObject& Image, const HTuple& OCRHandle, const HTuple& Expression, const HTuple& NumAlternatives, const HTuple& NumCorrections, HTuple* Class, HTuple* Confidence, HTuple* Word, HTuple* Score);

// Classify multiple characters with an OCR classifier.
LIntExport void DoOcrMultiClassMlp(const HObject& Character, const HObject& Image, const HTuple& OCRHandle, HTuple* Class, HTuple* Confidence);

// Classify a single character with an OCR classifier.
LIntExport void DoOcrSingleClassMlp(const HObject& Character, const HObject& Image, const HTuple& OCRHandle, const HTuple& Num, HTuple* Class, HTuple* Confidence);

// Train an OCR classifier with data from a (protected) training file.
LIntExport void TrainfOcrClassMlpProtected(const HTuple& OCRHandle, const HTuple& TrainingFile, const HTuple& Password, const HTuple& MaxIterations, const HTuple& WeightTolerance, const HTuple& ErrorTolerance, HTuple* Error, HTuple* ErrorLog);

// Train an OCR classifier.
LIntExport void TrainfOcrClassMlp(const HTuple& OCRHandle, const HTuple& TrainingFile, const HTuple& MaxIterations, const HTuple& WeightTolerance, const HTuple& ErrorTolerance, HTuple* Error, HTuple* ErrorLog);

// Compute the information content of the preprocessed feature vectors of an OCR classifier.
LIntExport void GetPrepInfoOcrClassMlp(const HTuple& OCRHandle, const HTuple& TrainingFile, const HTuple& Preprocessing, HTuple* InformationCont, HTuple* CumInformationCont);

// Return the rejection class parameters of an OCR classifier.
LIntExport void GetRejectionParamsOcrClassMlp(const HTuple& OCRHandle, const HTuple& GenParamName, HTuple* GenParamValue);

// Set the rejection class parameters of an OCR classifier.
LIntExport void SetRejectionParamsOcrClassMlp(const HTuple& OCRHandle, const HTuple& GenParamName, const HTuple& GenParamValue);

// Return the regularization parameters of an OCR classifier.
LIntExport void GetRegularizationParamsOcrClassMlp(const HTuple& OCRHandle, const HTuple& GenParamName, HTuple* GenParamValue);

// Set the regularization parameters of an OCR classifier.
LIntExport void SetRegularizationParamsOcrClassMlp(const HTuple& OCRHandle, const HTuple& GenParamName, const HTuple& GenParamValue);

// Return the parameters of an OCR classifier.
LIntExport void GetParamsOcrClassMlp(const HTuple& OCRHandle, HTuple* WidthCharacter, HTuple* HeightCharacter, HTuple* Interpolation, HTuple* Features, HTuple* Characters, HTuple* NumHidden, HTuple* Preprocessing, HTuple* NumComponents);

// Create an OCR classifier using a multilayer perceptron.
LIntExport void CreateOcrClassMlp(const HTuple& WidthCharacter, const HTuple& HeightCharacter, const HTuple& Interpolation, const HTuple& Features, const HTuple& Characters, const HTuple& NumHidden, const HTuple& Preprocessing, const HTuple& NumComponents, const HTuple& RandSeed, HTuple* OCRHandle);

// Serialize an OCR classifier.
LIntExport void SerializeOcr(const HTuple& OcrHandle, HTuple* SerializedItemHandle);

// Deserialize a serialized OCR classifier.
LIntExport void DeserializeOcr(const HTuple& SerializedItemHandle, HTuple* OcrHandle);

// Writing an OCR classifier into a file.
LIntExport void WriteOcr(const HTuple& OcrHandle, const HTuple& FileName);

// Read an OCR classifier from a file.
LIntExport void ReadOcr(const HTuple& FileName, HTuple* OcrHandle);

// Classify one character.
LIntExport void DoOcrSingle(const HObject& Character, const HObject& Image, const HTuple& OcrHandle, HTuple* Classes, HTuple* Confidences);

// Classify characters.
LIntExport void DoOcrMulti(const HObject& Character, const HObject& Image, const HTuple& OcrHandle, HTuple* Class, HTuple* Confidence);

// Get information about an OCR classifier.
LIntExport void InfoOcrClassBox(const HTuple& OcrHandle, HTuple* WidthPattern, HTuple* HeightPattern, HTuple* Interpolation, HTuple* WidthMaxChar, HTuple* HeightMaxChar, HTuple* Features, HTuple* Characters);

// Create a new OCR-classifier.
LIntExport void CreateOcrClassBox(const HTuple& WidthPattern, const HTuple& HeightPattern, const HTuple& Interpolation, const HTuple& Features, const HTuple& Character, HTuple* OcrHandle);

// Train an OCR classifier by the input of regions.
LIntExport void TraindOcrClassBox(const HObject& Character, const HObject& Image, const HTuple& OcrHandle, const HTuple& Class, HTuple* AvgConfidence);

// Train an OCR classifier with the help of a training file.
LIntExport void TrainfOcrClassBox(const HTuple& OcrHandle, const HTuple& TrainingFile, HTuple* AvgConfidence);

// Protection of training data.
LIntExport void ProtectOcrTrainf(const HTuple& TrainingFile, const HTuple& Password, const HTuple& TrainingFileProtected);

// Storing of training characters into a file.
LIntExport void WriteOcrTrainf(const HObject& Character, const HObject& Image, const HTuple& Class, const HTuple& TrainingFile);

// Define a new conversion table for the characters.
LIntExport void OcrChangeChar(const HTuple& OcrHandle, const HTuple& Character);

// Deallocation of the memory of an OCR classifier.
LIntExport void CloseOcr(const HTuple& OcrHandle);

// Sorting of regions with respect to their relative position.
LIntExport void SortRegion(const HObject& Regions, HObject* SortedRegions, const HTuple& SortMode, const HTuple& Order, const HTuple& RowOrCol);

// Destroy all OCR classifiers.
LIntExport void CloseAllOcrs();

// Test an OCR classifier.
LIntExport void TestdOcrClassBox(const HObject& Character, const HObject& Image, const HTuple& OcrHandle, const HTuple& Class, HTuple* Confidence);

// Cut out an image area relative to the domain.
LIntExport void CropDomainRel(const HObject& Image, HObject* ImagePart, const HTuple& Top, const HTuple& Left, const HTuple& Bottom, const HTuple& Right);

// Access the features which correspond to a character.
LIntExport void OcrGetFeatures(const HObject& Character, const HTuple& OcrHandle, HTuple* FeatureVector);

// Concat training files.
LIntExport void ConcatOcrTrainf(const HTuple& SingleFiles, const HTuple& ComposedFile);

// Write characters into a training file.
LIntExport void WriteOcrTrainfImage(const HObject& Character, const HTuple& Class, const HTuple& TrainingFile);

// Add characters to a training file.
LIntExport void AppendOcrTrainf(const HObject& Character, const HObject& Image, const HTuple& Class, const HTuple& TrainingFile);

// Query which characters are stored in a (protected) training file.
LIntExport void ReadOcrTrainfNamesProtected(const HTuple& TrainingFile, const HTuple& Password, HTuple* CharacterNames, HTuple* CharacterCount);

// Query which characters are stored in a training file.
LIntExport void ReadOcrTrainfNames(const HTuple& TrainingFile, HTuple* CharacterNames, HTuple* CharacterCount);

// Read training specific characters from files and convert to images.
LIntExport void ReadOcrTrainfSelect(HObject* Characters, const HTuple& TrainingFile, const HTuple& SearchNames, HTuple* FoundNames);

// Read training characters from files and convert to images.
LIntExport void ReadOcrTrainf(HObject* Characters, const HTuple& TrainingFile, HTuple* CharacterNames);

// Prune the branches of a region.
LIntExport void Pruning(const HObject& Region, HObject* RegionPrune, const HTuple& Length);

// Reduce a region to its boundary.
LIntExport void Boundary(const HObject& Region, HObject* RegionBorder, const HTuple& BoundaryType);

// Perform a closing after an opening with multiple structuring elements.
LIntExport void Fitting(const HObject& Region, const HObject& StructElements, HObject* RegionFitted);

// Generate standard structuring elements.
LIntExport void GenStructElements(HObject* StructElements, const HTuple& Type, const HTuple& Row, const HTuple& Column);

// Reflect a region about a point.
LIntExport void TransposeRegion(const HObject& Region, HObject* Transposed, const HTuple& Row, const HTuple& Column);

// Remove the result of a hit-or-miss operation from a region (sequential).
LIntExport void ThinningSeq(const HObject& Region, HObject* RegionThin, const HTuple& GolayElement, const HTuple& Iterations);

// Remove the result of a hit-or-miss operation from a region (using a Golay structuring element).
LIntExport void ThinningGolay(const HObject& Region, HObject* RegionThin, const HTuple& GolayElement, const HTuple& Rotation);

// Remove the result of a hit-or-miss operation from a region.
LIntExport void Thinning(const HObject& Region, const HObject& StructElement1, const HObject& StructElement2, HObject* RegionThin, const HTuple& Row, const HTuple& Column, const HTuple& Iterations);

// Add the result of a hit-or-miss operation to a region (sequential).
LIntExport void ThickeningSeq(const HObject& Region, HObject* RegionThick, const HTuple& GolayElement, const HTuple& Iterations);

// Add the result of a hit-or-miss operation to a region (using a Golay structuring element).
LIntExport void ThickeningGolay(const HObject& Region, HObject* RegionThick, const HTuple& GolayElement, const HTuple& Rotation);

// Add the result of a hit-or-miss operation to a region.
LIntExport void Thickening(const HObject& Region, const HObject& StructElement1, const HObject& StructElement2, HObject* RegionThick, const HTuple& Row, const HTuple& Column, const HTuple& Iterations);

// Hit-or-miss operation for regions using the Golay alphabet (sequential).
LIntExport void HitOrMissSeq(const HObject& Region, HObject* RegionHitMiss, const HTuple& GolayElement);

// Hit-or-miss operation for regions using the Golay alphabet.
LIntExport void HitOrMissGolay(const HObject& Region, HObject* RegionHitMiss, const HTuple& GolayElement, const HTuple& Rotation);

// Hit-or-miss operation for regions.
LIntExport void HitOrMiss(const HObject& Region, const HObject& StructElement1, const HObject& StructElement2, HObject* RegionHitMiss, const HTuple& Row, const HTuple& Column);

// Generate the structuring elements of the Golay alphabet.
LIntExport void GolayElements(HObject* StructElement1, HObject* StructElement2, const HTuple& GolayElement, const HTuple& Rotation, const HTuple& Row, const HTuple& Column);

// Thinning of a region.
LIntExport void MorphSkiz(const HObject& Region, HObject* RegionSkiz, const HTuple& Iterations1, const HTuple& Iterations2);

// Compute the morphological skeleton of a region.
LIntExport void MorphSkeleton(const HObject& Region, HObject* RegionSkeleton);

// Compute the union of bottom_hat and top_hat.
LIntExport void MorphHat(const HObject& Region, const HObject& StructElement, HObject* RegionMorphHat);

// Compute the bottom hat of regions.
LIntExport void BottomHat(const HObject& Region, const HObject& StructElement, HObject* RegionBottomHat);

// Compute the top hat of regions.
LIntExport void TopHat(const HObject& Region, const HObject& StructElement, HObject* RegionTopHat);

// Erode a region (using a reference point).
LIntExport void MinkowskiSub2(const HObject& Region, const HObject& StructElement, HObject* RegionMinkSub, const HTuple& Row, const HTuple& Column, const HTuple& Iterations);

// Erode a region.
LIntExport void MinkowskiSub1(const HObject& Region, const HObject& StructElement, HObject* RegionMinkSub, const HTuple& Iterations);

// Dilate a region (using a reference point).
LIntExport void MinkowskiAdd2(const HObject& Region, const HObject& StructElement, HObject* RegionMinkAdd, const HTuple& Row, const HTuple& Column, const HTuple& Iterations);

// Perform a Minkowski addition on a region.
LIntExport void MinkowskiAdd1(const HObject& Region, const HObject& StructElement, HObject* RegionMinkAdd, const HTuple& Iterations);

// Close a region with a rectangular structuring element.
LIntExport void ClosingRectangle1(const HObject& Region, HObject* RegionClosing, const HTuple& Width, const HTuple& Height);

// Close a region with an element from the Golay alphabet.
LIntExport void ClosingGolay(const HObject& Region, HObject* RegionClosing, const HTuple& GolayElement, const HTuple& Rotation);

// Close a region with a circular structuring element.
LIntExport void ClosingCircle(const HObject& Region, HObject* RegionClosing, const HTuple& Radius);

// Close a region.
LIntExport void Closing(const HObject& Region, const HObject& StructElement, HObject* RegionClosing);

// Separate overlapping regions.
LIntExport void OpeningSeg(const HObject& Region, const HObject& StructElement, HObject* RegionOpening);

// Open a region with an element from the Golay alphabet.
LIntExport void OpeningGolay(const HObject& Region, HObject* RegionOpening, const HTuple& GolayElement, const HTuple& Rotation);

// Open a region with a rectangular structuring element.
LIntExport void OpeningRectangle1(const HObject& Region, HObject* RegionOpening, const HTuple& Width, const HTuple& Height);

// Open a region with a circular structuring element.
LIntExport void OpeningCircle(const HObject& Region, HObject* RegionOpening, const HTuple& Radius);

// Open a region.
LIntExport void Opening(const HObject& Region, const HObject& StructElement, HObject* RegionOpening);

// Erode a region sequentially.
LIntExport void ErosionSeq(const HObject& Region, HObject* RegionErosion, const HTuple& GolayElement, const HTuple& Iterations);

// Erode a region with an element from the Golay alphabet.
LIntExport void ErosionGolay(const HObject& Region, HObject* RegionErosion, const HTuple& GolayElement, const HTuple& Iterations, const HTuple& Rotation);

// Erode a region with a rectangular structuring element.
LIntExport void ErosionRectangle1(const HObject& Region, HObject* RegionErosion, const HTuple& Width, const HTuple& Height);

// Erode a region with a circular structuring element.
LIntExport void ErosionCircle(const HObject& Region, HObject* RegionErosion, const HTuple& Radius);

// Erode a region (using a reference point).
LIntExport void Erosion2(const HObject& Region, const HObject& StructElement, HObject* RegionErosion, const HTuple& Row, const HTuple& Column, const HTuple& Iterations);

// Erode a region.
LIntExport void Erosion1(const HObject& Region, const HObject& StructElement, HObject* RegionErosion, const HTuple& Iterations);

// Dilate a region sequentially.
LIntExport void DilationSeq(const HObject& Region, HObject* RegionDilation, const HTuple& GolayElement, const HTuple& Iterations);

// Dilate a region with an element from the Golay alphabet.
LIntExport void DilationGolay(const HObject& Region, HObject* RegionDilation, const HTuple& GolayElement, const HTuple& Iterations, const HTuple& Rotation);

// Dilate a region with a rectangular structuring element.
LIntExport void DilationRectangle1(const HObject& Region, HObject* RegionDilation, const HTuple& Width, const HTuple& Height);

// Dilate a region with a circular structuring element.
LIntExport void DilationCircle(const HObject& Region, HObject* RegionDilation, const HTuple& Radius);

// Dilate a region (using a reference point).
LIntExport void Dilation2(const HObject& Region, const HObject& StructElement, HObject* RegionDilation, const HTuple& Row, const HTuple& Column, const HTuple& Iterations);

// Dilate a region.
LIntExport void Dilation1(const HObject& Region, const HObject& StructElement, HObject* RegionDilation, const HTuple& Iterations);

// Perform a gray value bottom hat transformation on an image.
LIntExport void GrayBothat(const HObject& Image, const HObject& SE, HObject* ImageBotHat);

// Perform a gray value top hat transformation on an image.
LIntExport void GrayTophat(const HObject& Image, const HObject& SE, HObject* ImageTopHat);

// Perform a gray value closing on an image.
LIntExport void GrayClosing(const HObject& Image, const HObject& SE, HObject* ImageClosing);

// Perform a gray value opening on an image.
LIntExport void GrayOpening(const HObject& Image, const HObject& SE, HObject* ImageOpening);

// Perform a gray value dilation on an image.
LIntExport void GrayDilation(const HObject& Image, const HObject& SE, HObject* ImageDilation);

// Perform a gray value erosion on an image.
LIntExport void GrayErosion(const HObject& Image, const HObject& SE, HObject* ImageErosion);

// Load a structuring element for gray morphology.
LIntExport void ReadGraySe(HObject* SE, const HTuple& FileName);

// Generate ellipsoidal structuring elements for gray morphology.
LIntExport void GenDiscSe(HObject* SE, const HTuple& Type, const HTuple& Width, const HTuple& Height, const HTuple& Smax);

// Query the model contour of a metrology object in image coordinates. 
LIntExport void GetMetrologyObjectModelContour(HObject* Contour, const HTuple& MetrologyHandle, const HTuple& Index, const HTuple& Resolution);

// Query the result contour of a metrology object. 
LIntExport void GetMetrologyObjectResultContour(HObject* Contour, const HTuple& MetrologyHandle, const HTuple& Index, const HTuple& Instance, const HTuple& Resolution);

// Alignment of a metrology model.
LIntExport void AlignMetrologyModel(const HTuple& MetrologyHandle, const HTuple& Row, const HTuple& Column, const HTuple& Angle);

// Add a metrology object to a metrology model.
LIntExport void AddMetrologyObjectGeneric(const HTuple& MetrologyHandle, const HTuple& Shape, const HTuple& ShapeParam, const HTuple& MeasureLength1, const HTuple& MeasureLength2, const HTuple& MeasureSigma, const HTuple& MeasureThreshold, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* Index);

// Get parameters that are valid for the entire metrology model.
LIntExport void GetMetrologyModelParam(const HTuple& MetrologyHandle, const HTuple& GenParamName, HTuple* GenParamValue);

// Set parameters that are valid for the entire metrology model.
LIntExport void SetMetrologyModelParam(const HTuple& MetrologyHandle, const HTuple& GenParamName, const HTuple& GenParamValue);

// Deserialize a serialized metrology model.
LIntExport void DeserializeMetrologyModel(const HTuple& SerializedItemHandle, HTuple* MetrologyHandle);

// Serialize a metrology model.
LIntExport void SerializeMetrologyModel(const HTuple& MetrologyHandle, HTuple* SerializedItemHandle);

// Transform metrology objects of a metrology model, e.g. for alignment.
LIntExport void TransformMetrologyObject(const HTuple& MetrologyHandle, const HTuple& Index, const HTuple& Row, const HTuple& Column, const HTuple& Phi, const HTuple& Mode);

// Write a metrology model to a file.
LIntExport void WriteMetrologyModel(const HTuple& MetrologyHandle, const HTuple& FileName);

// Read a metrology model from a file.
LIntExport void ReadMetrologyModel(const HTuple& FileName, HTuple* MetrologyHandle);

// Copy a metrology model.
LIntExport void CopyMetrologyModel(const HTuple& MetrologyHandle, const HTuple& Index, HTuple* CopiedMetrologyHandle);

// Copy metrology metrology objects of a metrology model.
LIntExport void CopyMetrologyObject(const HTuple& MetrologyHandle, const HTuple& Index, HTuple* CopiedIndices);

// Get the number of instances of the metrology objects of a metrology model.
LIntExport void GetMetrologyObjectNumInstances(const HTuple& MetrologyHandle, const HTuple& Index, HTuple* NumInstances);

// Get the results of the measurement of a metrology model.
LIntExport void GetMetrologyObjectResult(const HTuple& MetrologyHandle, const HTuple& Index, const HTuple& Instance, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* Parameter);

// Get the measure regions and the results of the edge location for the metrology objects of a metrology model.
LIntExport void GetMetrologyObjectMeasures(HObject* Contours, const HTuple& MetrologyHandle, const HTuple& Index, const HTuple& Transition, HTuple* Row, HTuple* Column);

// Measure and fit the geometric shapes of all metrology objects of a metrology model.
LIntExport void ApplyMetrologyModel(const HObject& Image, const HTuple& MetrologyHandle);

// Get the indices of the metrology objects of a metrology model.
LIntExport void GetMetrologyObjectIndices(const HTuple& MetrologyHandle, HTuple* Indices);

// Reset all fuzzy parameters and fuzzy functions of a metrology model.
LIntExport void ResetMetrologyObjectFuzzyParam(const HTuple& MetrologyHandle, const HTuple& Index);

// Reset all parameters of a metrology model.
LIntExport void ResetMetrologyObjectParam(const HTuple& MetrologyHandle, const HTuple& Index);

// Get a fuzzy parameter of a metroloy model.
LIntExport void GetMetrologyObjectFuzzyParam(const HTuple& MetrologyHandle, const HTuple& Index, const HTuple& GenParamName, HTuple* GenParamValue);

// Get one or several parameters of a metroloy model.
LIntExport void GetMetrologyObjectParam(const HTuple& MetrologyHandle, const HTuple& Index, const HTuple& GenParamName, HTuple* GenParamValue);

// Set fuzzy parameters or fuzzy functions for a metrology model.
LIntExport void SetMetrologyObjectFuzzyParam(const HTuple& MetrologyHandle, const HTuple& Index, const HTuple& GenParamName, const HTuple& GenParamValue);

// Set parameters for the metrology objects of a metrology model.
LIntExport void SetMetrologyObjectParam(const HTuple& MetrologyHandle, const HTuple& Index, const HTuple& GenParamName, const HTuple& GenParamValue);

// Add a rectangle to a metrology model.
LIntExport void AddMetrologyObjectRectangle2Measure(const HTuple& MetrologyHandle, const HTuple& Row, const HTuple& Column, const HTuple& Phi, const HTuple& Length1, const HTuple& Length2, const HTuple& MeasureLength1, const HTuple& MeasureLength2, const HTuple& MeasureSigma, const HTuple& MeasureThreshold, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* Index);

// Add a line to a metrology model.
LIntExport void AddMetrologyObjectLineMeasure(const HTuple& MetrologyHandle, const HTuple& RowBegin, const HTuple& ColumnBegin, const HTuple& RowEnd, const HTuple& ColumnEnd, const HTuple& MeasureLength1, const HTuple& MeasureLength2, const HTuple& MeasureSigma, const HTuple& MeasureThreshold, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* Index);

// Add an ellipse or an elliptic arc to a metrology model.
LIntExport void AddMetrologyObjectEllipseMeasure(const HTuple& MetrologyHandle, const HTuple& Row, const HTuple& Column, const HTuple& Phi, const HTuple& Radius1, const HTuple& Radius2, const HTuple& MeasureLength1, const HTuple& MeasureLength2, const HTuple& MeasureSigma, const HTuple& MeasureThreshold, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* Index);

// Add a circle or a circular arc to a metrology model.
LIntExport void AddMetrologyObjectCircleMeasure(const HTuple& MetrologyHandle, const HTuple& Row, const HTuple& Column, const HTuple& Radius, const HTuple& MeasureLength1, const HTuple& MeasureLength2, const HTuple& MeasureSigma, const HTuple& MeasureThreshold, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* Index);

// Delete all metrology models and free the allocated memory.
LIntExport void ClearAllMetrologyModels();

// Delete a metrology model and free the allocated memory.
LIntExport void ClearMetrologyModel(const HTuple& MetrologyHandle);

// Delete metrology objects and free the allocated memory.
LIntExport void ClearMetrologyObject(const HTuple& MetrologyHandle, const HTuple& Index);

// Set the size of the image of metrology objects.
LIntExport void SetMetrologyModelImageSize(const HTuple& MetrologyHandle, const HTuple& Width, const HTuple& Height);

// Create the data structure that is needed to measure geometric shapes.
LIntExport void CreateMetrologyModel(HTuple* MetrologyHandle);

// Serialize a measure object.
LIntExport void SerializeMeasure(const HTuple& MeasureHandle, HTuple* SerializedItemHandle);

// Deserialize a serialized measure object.
LIntExport void DeserializeMeasure(const HTuple& SerializedItemHandle, HTuple* MeasureHandle);

// Write a measure object to a file.
LIntExport void WriteMeasure(const HTuple& MeasureHandle, const HTuple& FileName);

// Read a measure object from a file.
LIntExport void ReadMeasure(const HTuple& FileName, HTuple* MeasureHandle);

// Extracting points with a particular gray value along a rectangle or an annular arc.
LIntExport void MeasureThresh(const HObject& Image, const HTuple& MeasureHandle, const HTuple& Sigma, const HTuple& Threshold, const HTuple& Select, HTuple* RowThresh, HTuple* ColumnThresh, HTuple* Distance);

// Delete all measure objects.
LIntExport void CloseAllMeasures();

// Delete a measure object.
LIntExport void CloseMeasure(const HTuple& MeasureHandle);

// Extract a gray value profile perpendicular to a rectangle or annular arc.
LIntExport void MeasureProjection(const HObject& Image, const HTuple& MeasureHandle, HTuple* GrayValues);

// Reset a fuzzy function.
LIntExport void ResetFuzzyMeasure(const HTuple& MeasureHandle, const HTuple& SetType);

// Specify a normalized fuzzy function for edge pairs.
LIntExport void SetFuzzyMeasureNormPair(const HTuple& MeasureHandle, const HTuple& PairSize, const HTuple& SetType, const HTuple& Function);

// Specify a fuzzy function.
LIntExport void SetFuzzyMeasure(const HTuple& MeasureHandle, const HTuple& SetType, const HTuple& Function);

// Extract straight edge pairs perpendicular to a rectangle or an annular arc.
LIntExport void FuzzyMeasurePairing(const HObject& Image, const HTuple& MeasureHandle, const HTuple& Sigma, const HTuple& AmpThresh, const HTuple& FuzzyThresh, const HTuple& Transition, const HTuple& Pairing, const HTuple& NumPairs, HTuple* RowEdgeFirst, HTuple* ColumnEdgeFirst, HTuple* AmplitudeFirst, HTuple* RowEdgeSecond, HTuple* ColumnEdgeSecond, HTuple* AmplitudeSecond, HTuple* RowPairCenter, HTuple* ColumnPairCenter, HTuple* FuzzyScore, HTuple* IntraDistance);

// Extract straight edge pairs perpendicular to a rectangle or an annular arc.
LIntExport void FuzzyMeasurePairs(const HObject& Image, const HTuple& MeasureHandle, const HTuple& Sigma, const HTuple& AmpThresh, const HTuple& FuzzyThresh, const HTuple& Transition, HTuple* RowEdgeFirst, HTuple* ColumnEdgeFirst, HTuple* AmplitudeFirst, HTuple* RowEdgeSecond, HTuple* ColumnEdgeSecond, HTuple* AmplitudeSecond, HTuple* RowEdgeCenter, HTuple* ColumnEdgeCenter, HTuple* FuzzyScore, HTuple* IntraDistance, HTuple* InterDistance);

// Extract straight edges perpendicular to a rectangle or an annular arc.
LIntExport void FuzzyMeasurePos(const HObject& Image, const HTuple& MeasureHandle, const HTuple& Sigma, const HTuple& AmpThresh, const HTuple& FuzzyThresh, const HTuple& Transition, HTuple* RowEdge, HTuple* ColumnEdge, HTuple* Amplitude, HTuple* FuzzyScore, HTuple* Distance);

// Extract straight edge pairs perpendicular to a rectangle or annular arc.
LIntExport void MeasurePairs(const HObject& Image, const HTuple& MeasureHandle, const HTuple& Sigma, const HTuple& Threshold, const HTuple& Transition, const HTuple& Select, HTuple* RowEdgeFirst, HTuple* ColumnEdgeFirst, HTuple* AmplitudeFirst, HTuple* RowEdgeSecond, HTuple* ColumnEdgeSecond, HTuple* AmplitudeSecond, HTuple* IntraDistance, HTuple* InterDistance);

// Extract straight edges perpendicular to a rectangle or annular arc.
LIntExport void MeasurePos(const HObject& Image, const HTuple& MeasureHandle, const HTuple& Sigma, const HTuple& Threshold, const HTuple& Transition, const HTuple& Select, HTuple* RowEdge, HTuple* ColumnEdge, HTuple* Amplitude, HTuple* Distance);

// Translate a measure object.
LIntExport void TranslateMeasure(const HTuple& MeasureHandle, const HTuple& Row, const HTuple& Column);

// Prepare the extraction of straight edges perpendicular to an annular arc.
LIntExport void GenMeasureArc(const HTuple& CenterRow, const HTuple& CenterCol, const HTuple& Radius, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& AnnulusRadius, const HTuple& Width, const HTuple& Height, const HTuple& Interpolation, HTuple* MeasureHandle);

// Prepare the extraction of straight edges perpendicular to a rectangle.
LIntExport void GenMeasureRectangle2(const HTuple& Row, const HTuple& Column, const HTuple& Phi, const HTuple& Length1, const HTuple& Length2, const HTuple& Width, const HTuple& Height, const HTuple& Interpolation, HTuple* MeasureHandle);

// Deserialize a serialized matrix.
LIntExport void DeserializeMatrix(const HTuple& SerializedItemHandle, HTuple* MatrixID);

// Serialize a matrix.
LIntExport void SerializeMatrix(const HTuple& MatrixID, HTuple* SerializedItemHandle);

// Read a matrix from a file.
LIntExport void ReadMatrix(const HTuple& FileName, HTuple* MatrixID);

// Write a matrix to a file.
LIntExport void WriteMatrix(const HTuple& MatrixID, const HTuple& FileFormat, const HTuple& FileName);

// Perform an orthogonal decomposition of a matrix.
LIntExport void OrthogonalDecomposeMatrix(const HTuple& MatrixID, const HTuple& DecompositionType, const HTuple& OutputMatricesType, const HTuple& ComputeOrthogonal, HTuple* MatrixOrthogonalID, HTuple* MatrixTriangularID);

// Decompose a matrix.
LIntExport void DecomposeMatrix(const HTuple& MatrixID, const HTuple& MatrixType, HTuple* Matrix1ID, HTuple* Matrix2ID);

// Compute the singular value decomposition of a matrix.
LIntExport void SvdMatrix(const HTuple& MatrixID, const HTuple& SVDType, const HTuple& ComputeSingularVectors, HTuple* MatrixUID, HTuple* MatrixSID, HTuple* MatrixVID);

// Compute the generalized eigenvalues and optionally the generalized eigenvectors of general matrices.
LIntExport void GeneralizedEigenvaluesGeneralMatrix(const HTuple& MatrixAID, const HTuple& MatrixBID, const HTuple& ComputeEigenvectors, HTuple* EigenvaluesRealID, HTuple* EigenvaluesImagID, HTuple* EigenvectorsRealID, HTuple* EigenvectorsImagID);

// Compute the generalized eigenvalues and optionally generalized eigenvectors of symmetric input matrices.
LIntExport void GeneralizedEigenvaluesSymmetricMatrix(const HTuple& MatrixAID, const HTuple& MatrixBID, const HTuple& ComputeEigenvectors, HTuple* EigenvaluesID, HTuple* EigenvectorsID);

// Compute the eigenvalues and optionally the eigenvectors of a general matrix.
LIntExport void EigenvaluesGeneralMatrix(const HTuple& MatrixID, const HTuple& ComputeEigenvectors, HTuple* EigenvaluesRealID, HTuple* EigenvaluesImagID, HTuple* EigenvectorsRealID, HTuple* EigenvectorsImagID);

// Compute the eigenvalues and optionally eigenvectors of a symmetric matrix.
LIntExport void EigenvaluesSymmetricMatrix(const HTuple& MatrixID, const HTuple& ComputeEigenvectors, HTuple* EigenvaluesID, HTuple* EigenvectorsID);

// Compute the solution of a system of equations.
LIntExport void SolveMatrix(const HTuple& MatrixLHSID, const HTuple& MatrixLHSType, const HTuple& Epsilon, const HTuple& MatrixRHSID, HTuple* MatrixResultID);

// Compute the determinant of a matrix.
LIntExport void DeterminantMatrix(const HTuple& MatrixID, const HTuple& MatrixType, HTuple* Value);

// Invert a matrix.
LIntExport void InvertMatrixMod(const HTuple& MatrixID, const HTuple& MatrixType, const HTuple& Epsilon);

// Invert a matrix.
LIntExport void InvertMatrix(const HTuple& MatrixID, const HTuple& MatrixType, const HTuple& Epsilon, HTuple* MatrixInvID);

// Transpose a matrix.
LIntExport void TransposeMatrixMod(const HTuple& MatrixID);

// Transpose a matrix.
LIntExport void TransposeMatrix(const HTuple& MatrixID, HTuple* MatrixTransposedID);

// Returns the elementwise maximum of a matrix.
LIntExport void MaxMatrix(const HTuple& MatrixID, const HTuple& MaxType, HTuple* MatrixMaxID);

// Returns the elementwise minimum of a matrix.
LIntExport void MinMatrix(const HTuple& MatrixID, const HTuple& MinType, HTuple* MatrixMinID);

// Compute the power functions of a matrix.
LIntExport void PowMatrixMod(const HTuple& MatrixID, const HTuple& MatrixType, const HTuple& Power);

// Compute the power functions of a matrix.
LIntExport void PowMatrix(const HTuple& MatrixID, const HTuple& MatrixType, const HTuple& Power, HTuple* MatrixPowID);

// Compute the power functions of the elements of a matrix.
LIntExport void PowElementMatrixMod(const HTuple& MatrixID, const HTuple& MatrixExpID);

// Compute the power functions of the elements of a matrix.
LIntExport void PowElementMatrix(const HTuple& MatrixID, const HTuple& MatrixExpID, HTuple* MatrixPowID);

// Compute the power functions of the elements of a matrix.
LIntExport void PowScalarElementMatrixMod(const HTuple& MatrixID, const HTuple& Power);

// Compute the power functions of the elements of a matrix.
LIntExport void PowScalarElementMatrix(const HTuple& MatrixID, const HTuple& Power, HTuple* MatrixPowID);

// Compute the square root values of the elements of a matrix.
LIntExport void SqrtMatrixMod(const HTuple& MatrixID);

// Compute the square root values of the elements of a matrix.
LIntExport void SqrtMatrix(const HTuple& MatrixID, HTuple* MatrixSqrtID);

// Compute the absolute values of the elements of a matrix.
LIntExport void AbsMatrixMod(const HTuple& MatrixID);

// Compute the absolute values of the elements of a matrix.
LIntExport void AbsMatrix(const HTuple& MatrixID, HTuple* MatrixAbsID);

// Norm of a matrix.
LIntExport void NormMatrix(const HTuple& MatrixID, const HTuple& NormType, HTuple* Value);

// Returns the elementwise mean of a matrix.
LIntExport void MeanMatrix(const HTuple& MatrixID, const HTuple& MeanType, HTuple* MatrixMeanID);

// Returns the elementwise sum of a matrix.
LIntExport void SumMatrix(const HTuple& MatrixID, const HTuple& SumType, HTuple* MatrixSumID);

// Divide matrices element-by-element.
LIntExport void DivElementMatrixMod(const HTuple& MatrixAID, const HTuple& MatrixBID);

// Divide matrices element-by-element.
LIntExport void DivElementMatrix(const HTuple& MatrixAID, const HTuple& MatrixBID, HTuple* MatrixDivID);

// Multiply matrices element-by-element.
LIntExport void MultElementMatrixMod(const HTuple& MatrixAID, const HTuple& MatrixBID);

// Multiply matrices element-by-element.
LIntExport void MultElementMatrix(const HTuple& MatrixAID, const HTuple& MatrixBID, HTuple* MatrixMultID);

// Scale a matrix.
LIntExport void ScaleMatrixMod(const HTuple& MatrixID, const HTuple& Factor);

// Scale a matrix.
LIntExport void ScaleMatrix(const HTuple& MatrixID, const HTuple& Factor, HTuple* MatrixScaledID);

// Subtract two matrices.
LIntExport void SubMatrixMod(const HTuple& MatrixAID, const HTuple& MatrixBID);

// Subtract two matrices.
LIntExport void SubMatrix(const HTuple& MatrixAID, const HTuple& MatrixBID, HTuple* MatrixSubID);

// Add two matrices.
LIntExport void AddMatrixMod(const HTuple& MatrixAID, const HTuple& MatrixBID);

// Add two matrices.
LIntExport void AddMatrix(const HTuple& MatrixAID, const HTuple& MatrixBID, HTuple* MatrixSumID);

// Multiply two matrices.
LIntExport void MultMatrixMod(const HTuple& MatrixAID, const HTuple& MatrixBID, const HTuple& MultType);

// Multiply two matrices.
LIntExport void MultMatrix(const HTuple& MatrixAID, const HTuple& MatrixBID, const HTuple& MultType, HTuple* MatrixMultID);

// Get the size of a matrix.
LIntExport void GetSizeMatrix(const HTuple& MatrixID, HTuple* Rows, HTuple* Columns);

// Repeat a matrix.
LIntExport void RepeatMatrix(const HTuple& MatrixID, const HTuple& Rows, const HTuple& Columns, HTuple* MatrixRepeatedID);

// Copy a matrix.
LIntExport void CopyMatrix(const HTuple& MatrixID, HTuple* MatrixCopyID);

// Set the diagonal elements of a matrix.
LIntExport void SetDiagonalMatrix(const HTuple& MatrixID, const HTuple& VectorID, const HTuple& Diagonal);

// Get the diagonal elements of a matrix.
LIntExport void GetDiagonalMatrix(const HTuple& MatrixID, const HTuple& Diagonal, HTuple* VectorID);

// Set a sub-matrix of a matrix.
LIntExport void SetSubMatrix(const HTuple& MatrixID, const HTuple& MatrixSubID, const HTuple& Row, const HTuple& Column);

// Get a sub-matrix of a matrix.
LIntExport void GetSubMatrix(const HTuple& MatrixID, const HTuple& Row, const HTuple& Column, const HTuple& RowsSub, const HTuple& ColumnsSub, HTuple* MatrixSubID);

// Set all values of a matrix.
LIntExport void SetFullMatrix(const HTuple& MatrixID, const HTuple& Values);

// Return all values of a matrix.
LIntExport void GetFullMatrix(const HTuple& MatrixID, HTuple* Values);

// Set one or more elements of a matrix.
LIntExport void SetValueMatrix(const HTuple& MatrixID, const HTuple& Row, const HTuple& Column, const HTuple& Value);

// Return one ore more elements of a matrix.
LIntExport void GetValueMatrix(const HTuple& MatrixID, const HTuple& Row, const HTuple& Column, HTuple* Value);

// Clear all matrices from memory.
LIntExport void ClearAllMatrices();

// Free the memory of a matrix.
LIntExport void ClearMatrix(const HTuple& MatrixID);

// Create a matrix.
LIntExport void CreateMatrix(const HTuple& Rows, const HTuple& Columns, const HTuple& Value, HTuple* MatrixID);

// Free the memory of all sample identifiers.
LIntExport void ClearAllSampleIdentifiers();

// Free the memory of a sample identifier.
LIntExport void ClearSampleIdentifier(const HTuple& SampleIdentifier);

// Deserialize a serialized sample identifier.
LIntExport void DeserializeSampleIdentifier(const HTuple& SerializedItemHandle, HTuple* SampleIdentifier);

// Read a sample identifier from a file.
LIntExport void ReadSampleIdentifier(const HTuple& FileName, HTuple* SampleIdentifier);

// Serialize a sample identifier.
LIntExport void SerializeSampleIdentifier(const HTuple& SampleIdentifier, HTuple* SerializedItemHandle);

// Write a sample identifier to a file.
LIntExport void WriteSampleIdentifier(const HTuple& SampleIdentifier, const HTuple& FileName);

// Identify objects with a sample identifier. 
LIntExport void ApplySampleIdentifier(const HObject& Image, const HTuple& SampleIdentifier, const HTuple& NumResults, const HTuple& RatingThreshold, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* ObjectIdx, HTuple* Rating);

// Get selected parameters of a sample identifier.
LIntExport void GetSampleIdentifierParam(const HTuple& SampleIdentifier, const HTuple& ParamName, HTuple* ParamValue);

// Set selected parameters of a sample identifier.
LIntExport void SetSampleIdentifierParam(const HTuple& SampleIdentifier, const HTuple& ParamName, const HTuple& ParamValue);

// Retrieve information about an object of a sample identifier.
LIntExport void GetSampleIdentifierObjectInfo(const HTuple& SampleIdentifier, const HTuple& ObjectIdx, const HTuple& InfoName, HTuple* InfoValue);

// Define a name or a description for an object of a sample identifier.
LIntExport void SetSampleIdentifierObjectInfo(const HTuple& SampleIdentifier, const HTuple& ObjectIdx, const HTuple& InfoName, const HTuple& InfoValue);

// Remove training data from a sample identifier.  
LIntExport void RemoveSampleIdentifierTrainingData(const HTuple& SampleIdentifier, const HTuple& ObjectIdx, const HTuple& ObjectSampleIdx);

// Remove preparation data from a sample identifier.  
LIntExport void RemoveSampleIdentifierPreparationData(const HTuple& SampleIdentifier, const HTuple& ObjectIdx, const HTuple& ObjectSampleIdx);

// Train a sample identifier.  
LIntExport void TrainSampleIdentifier(const HTuple& SampleIdentifier, const HTuple& ParamName, const HTuple& ParamValue);

// Add training data to an existing sample identifier. 
LIntExport void AddSampleIdentifierTrainingData(const HObject& SampleImage, const HTuple& SampleIdentifier, const HTuple& ObjectIdx, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* ObjectSampleIdx);

// Adapt the internal data structure of a sample identifier to the objects to be identified.  
LIntExport void PrepareSampleIdentifier(const HTuple& SampleIdentifier, const HTuple& RemovePreparationData, const HTuple& GenParamName, const HTuple& GenParamValue);

// Add preparation data to an existing sample identifier. 
LIntExport void AddSampleIdentifierPreparationData(const HObject& SampleImage, const HTuple& SampleIdentifier, const HTuple& ObjectIdx, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* ObjectSampleIdx);

// Create a new sample identifier.
LIntExport void CreateSampleIdentifier(const HTuple& ParamName, const HTuple& ParamValue, HTuple* SampleIdentifier);

// Deserialize a serialized shape model.
LIntExport void DeserializeShapeModel(const HTuple& SerializedItemHandle, HTuple* ModelID);

// Read a shape model from a file.
LIntExport void ReadShapeModel(const HTuple& FileName, HTuple* ModelID);

// Serialize a shape model.
LIntExport void SerializeShapeModel(const HTuple& ModelID, HTuple* SerializedItemHandle);

// Write a shape model to a file.
LIntExport void WriteShapeModel(const HTuple& ModelID, const HTuple& FileName);

// Free the memory of all shape models.
LIntExport void ClearAllShapeModels();

// Free the memory of a shape model.
LIntExport void ClearShapeModel(const HTuple& ModelID);

// Return the contour representation of a shape model.
LIntExport void GetShapeModelContours(HObject* ModelContours, const HTuple& ModelID, const HTuple& Level);

// Determine the parameters of a shape model.
LIntExport void DetermineShapeModelParams(const HObject& Template, const HTuple& NumLevels, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& ScaleMin, const HTuple& ScaleMax, const HTuple& Optimization, const HTuple& Metric, const HTuple& Contrast, const HTuple& MinContrast, const HTuple& Parameters, HTuple* ParameterName, HTuple* ParameterValue);

// Return the parameters of a shape model.
LIntExport void GetShapeModelParams(const HTuple& ModelID, HTuple* NumLevels, HTuple* AngleStart, HTuple* AngleExtent, HTuple* AngleStep, HTuple* ScaleMin, HTuple* ScaleMax, HTuple* ScaleStep, HTuple* Metric, HTuple* MinContrast);

// Return the origin (reference point) of a shape model.
LIntExport void GetShapeModelOrigin(const HTuple& ModelID, HTuple* Row, HTuple* Column);

// Set the origin (reference point) of a shape model.
LIntExport void SetShapeModelOrigin(const HTuple& ModelID, const HTuple& Row, const HTuple& Column);

// Find the best matches of multiple anisotropic scale invariant shape models.
LIntExport void FindAnisoShapeModels(const HObject& Image, const HTuple& ModelIDs, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& ScaleRMin, const HTuple& ScaleRMax, const HTuple& ScaleCMin, const HTuple& ScaleCMax, const HTuple& MinScore, const HTuple& NumMatches, const HTuple& MaxOverlap, const HTuple& SubPixel, const HTuple& NumLevels, const HTuple& Greediness, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* ScaleR, HTuple* ScaleC, HTuple* Score, HTuple* Model);

// Find the best matches of multiple scale invariant shape models.
LIntExport void FindScaledShapeModels(const HObject& Image, const HTuple& ModelIDs, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& ScaleMin, const HTuple& ScaleMax, const HTuple& MinScore, const HTuple& NumMatches, const HTuple& MaxOverlap, const HTuple& SubPixel, const HTuple& NumLevels, const HTuple& Greediness, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* Scale, HTuple* Score, HTuple* Model);

// Find the best matches of multiple shape models.
LIntExport void FindShapeModels(const HObject& Image, const HTuple& ModelIDs, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& MinScore, const HTuple& NumMatches, const HTuple& MaxOverlap, const HTuple& SubPixel, const HTuple& NumLevels, const HTuple& Greediness, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* Score, HTuple* Model);

// Find the best matches of an anisotropic scale invariant shape model in an image.
LIntExport void FindAnisoShapeModel(const HObject& Image, const HTuple& ModelID, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& ScaleRMin, const HTuple& ScaleRMax, const HTuple& ScaleCMin, const HTuple& ScaleCMax, const HTuple& MinScore, const HTuple& NumMatches, const HTuple& MaxOverlap, const HTuple& SubPixel, const HTuple& NumLevels, const HTuple& Greediness, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* ScaleR, HTuple* ScaleC, HTuple* Score);

// Find the best matches of a scale invariant shape model in an image.
LIntExport void FindScaledShapeModel(const HObject& Image, const HTuple& ModelID, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& ScaleMin, const HTuple& ScaleMax, const HTuple& MinScore, const HTuple& NumMatches, const HTuple& MaxOverlap, const HTuple& SubPixel, const HTuple& NumLevels, const HTuple& Greediness, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* Scale, HTuple* Score);

// Find the best matches of a shape model in an image.
LIntExport void FindShapeModel(const HObject& Image, const HTuple& ModelID, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& MinScore, const HTuple& NumMatches, const HTuple& MaxOverlap, const HTuple& SubPixel, const HTuple& NumLevels, const HTuple& Greediness, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* Score);

// Set the metric of a shape model that was created from XLD contours.
LIntExport void SetShapeModelMetric(const HObject& Image, const HTuple& ModelID, const HTuple& HomMat2D, const HTuple& Metric);

// Set selected parameters of the shape model.
LIntExport void SetShapeModelParam(const HTuple& ModelID, const HTuple& GenParamNames, const HTuple& GenParamValues);

// Prepare a shape model for anisotropic scale invariant matching from XLD contours.
LIntExport void CreateAnisoShapeModelXld(const HObject& Contours, const HTuple& NumLevels, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& AngleStep, const HTuple& ScaleRMin, const HTuple& ScaleRMax, const HTuple& ScaleRStep, const HTuple& ScaleCMin, const HTuple& ScaleCMax, const HTuple& ScaleCStep, const HTuple& Optimization, const HTuple& Metric, const HTuple& MinContrast, HTuple* ModelID);

// Prepare a shape model for scale invariant matching from XLD contours.
LIntExport void CreateScaledShapeModelXld(const HObject& Contours, const HTuple& NumLevels, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& AngleStep, const HTuple& ScaleMin, const HTuple& ScaleMax, const HTuple& ScaleStep, const HTuple& Optimization, const HTuple& Metric, const HTuple& MinContrast, HTuple* ModelID);

// Prepare a shape model for matching from XLD contours.
LIntExport void CreateShapeModelXld(const HObject& Contours, const HTuple& NumLevels, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& AngleStep, const HTuple& Optimization, const HTuple& Metric, const HTuple& MinContrast, HTuple* ModelID);

// Prepare a shape model for anisotropic scale invariant matching.
LIntExport void CreateAnisoShapeModel(const HObject& Template, const HTuple& NumLevels, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& AngleStep, const HTuple& ScaleRMin, const HTuple& ScaleRMax, const HTuple& ScaleRStep, const HTuple& ScaleCMin, const HTuple& ScaleCMax, const HTuple& ScaleCStep, const HTuple& Optimization, const HTuple& Metric, const HTuple& Contrast, const HTuple& MinContrast, HTuple* ModelID);

// Prepare a shape model for scale invariant matching.
LIntExport void CreateScaledShapeModel(const HObject& Template, const HTuple& NumLevels, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& AngleStep, const HTuple& ScaleMin, const HTuple& ScaleMax, const HTuple& ScaleStep, const HTuple& Optimization, const HTuple& Metric, const HTuple& Contrast, const HTuple& MinContrast, HTuple* ModelID);

// Prepare a shape model for matching.
LIntExport void CreateShapeModel(const HObject& Template, const HTuple& NumLevels, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& AngleStep, const HTuple& Optimization, const HTuple& Metric, const HTuple& Contrast, const HTuple& MinContrast, HTuple* ModelID);

// Create the representation of a shape model.
LIntExport void InspectShapeModel(const HObject& Image, HObject* ModelImages, HObject* ModelRegions, const HTuple& NumLevels, const HTuple& Contrast);

// Free the memory of all descriptor models in RAM.
LIntExport void ClearAllDescriptorModels();

// Free the memory of a descriptor model.
LIntExport void ClearDescriptorModel(const HTuple& ModelID);

// Deserialize a descriptor model.
LIntExport void DeserializeDescriptorModel(const HTuple& SerializedItemHandle, HTuple* ModelID);

// Serialize a descriptor model.
LIntExport void SerializeDescriptorModel(const HTuple& ModelID, HTuple* SerializedItemHandle);

// Read a descriptor model from a file.
LIntExport void ReadDescriptorModel(const HTuple& FileName, HTuple* ModelID);

// Write a descriptor model to a file.
LIntExport void WriteDescriptorModel(const HTuple& ModelID, const HTuple& FileName);

// Find the best matches of a calibrated descriptor model in an image and return their 3D pose.
LIntExport void FindCalibDescriptorModel(const HObject& Image, const HTuple& ModelID, const HTuple& DetectorParamName, const HTuple& DetectorParamValue, const HTuple& DescriptorParamName, const HTuple& DescriptorParamValue, const HTuple& MinScore, const HTuple& NumMatches, const HTuple& CamParam, const HTuple& ScoreType, HTuple* Pose, HTuple* Score);

// Find the best matches of a descriptor model in an image.
LIntExport void FindUncalibDescriptorModel(const HObject& Image, const HTuple& ModelID, const HTuple& DetectorParamName, const HTuple& DetectorParamValue, const HTuple& DescriptorParamName, const HTuple& DescriptorParamValue, const HTuple& MinScore, const HTuple& NumMatches, const HTuple& ScoreType, HTuple* HomMat2D, HTuple* Score);

// Query the interest points of the descriptor model or the last processed search image.
LIntExport void GetDescriptorModelPoints(const HTuple& ModelID, const HTuple& Set, const HTuple& Subset, HTuple* Row, HTuple* Column);

// Return the parameters of a descriptor model.
LIntExport void GetDescriptorModelParams(const HTuple& ModelID, HTuple* DetectorType, HTuple* DetectorParamName, HTuple* DetectorParamValue, HTuple* DescriptorParamName, HTuple* DescriptorParamValue);

// Create a descriptor model for calibrated perspective matching.
LIntExport void CreateCalibDescriptorModel(const HObject& Template, const HTuple& CamParam, const HTuple& ReferencePose, const HTuple& DetectorType, const HTuple& DetectorParamName, const HTuple& DetectorParamValue, const HTuple& DescriptorParamName, const HTuple& DescriptorParamValue, const HTuple& Seed, HTuple* ModelID);

// Prepare a descriptor model for interest point matching.
LIntExport void CreateUncalibDescriptorModel(const HObject& Template, const HTuple& DetectorType, const HTuple& DetectorParamName, const HTuple& DetectorParamValue, const HTuple& DescriptorParamName, const HTuple& DescriptorParamValue, const HTuple& Seed, HTuple* ModelID);

// Query alphanumerical results that were accumulated during descriptor-based matching.
LIntExport void GetDescriptorModelResults(const HTuple& ModelID, const HTuple& ObjectID, const HTuple& ResultNames, HTuple* Results);

// Return the origin of a descriptor model.
LIntExport void GetDescriptorModelOrigin(const HTuple& ModelID, HTuple* Row, HTuple* Column);

// Sets the origin of a descriptor model.
LIntExport void SetDescriptorModelOrigin(const HTuple& ModelID, const HTuple& Row, const HTuple& Column);

// Return the origin (reference point) of a deformable model.
LIntExport void GetDeformableModelOrigin(const HTuple& ModelID, HTuple* Row, HTuple* Column);

// Set the origin (reference point) of a deformable model.
LIntExport void SetDeformableModelOrigin(const HTuple& ModelID, const HTuple& Row, const HTuple& Column);

// Set selected parameters of the deformable model.
LIntExport void SetDeformableModelParam(const HTuple& ModelID, const HTuple& GenParamNames, const HTuple& GenParamValues);

// Return the parameters of a deformable model.
LIntExport void GetDeformableModelParams(const HTuple& ModelID, const HTuple& GenParamNames, HTuple* GenParamValues);

// Return the contour representation of a deformable model.
LIntExport void GetDeformableModelContours(HObject* ModelContours, const HTuple& ModelID, const HTuple& Level);

// Determine the parameters of a deformable model.
LIntExport void DetermineDeformableModelParams(const HObject& Template, const HTuple& NumLevels, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& ScaleMin, const HTuple& ScaleMax, const HTuple& Optimization, const HTuple& Metric, const HTuple& Contrast, const HTuple& MinContrast, const HTuple& ParamName, const HTuple& ParamValue, const HTuple& Parameters, HTuple* ParameterName, HTuple* ParameterValue);

// Deserialize a deformable model.
LIntExport void DeserializeDeformableModel(const HTuple& SerializedItemHandle, HTuple* ModelID);

// Serialize a deformable model.
LIntExport void SerializeDeformableModel(const HTuple& ModelID, HTuple* SerializedItemHandle);

// Read a deformable model from a file.
LIntExport void ReadDeformableModel(const HTuple& FileName, HTuple* ModelID);

// Write a deformable model to a file.
LIntExport void WriteDeformableModel(const HTuple& ModelID, const HTuple& FileName);

// Free the memory of all deformable models.
LIntExport void ClearAllDeformableModels();

// Free the memory of a deformable model.
LIntExport void ClearDeformableModel(const HTuple& ModelID);

// Find the best matches of a local deformable model in an image.
LIntExport void FindLocalDeformableModel(const HObject& Image, HObject* ImageRectified, HObject* VectorField, HObject* DeformedContours, const HTuple& ModelID, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& ScaleRMin, const HTuple& ScaleRMax, const HTuple& ScaleCMin, const HTuple& ScaleCMax, const HTuple& MinScore, const HTuple& NumMatches, const HTuple& MaxOverlap, const HTuple& NumLevels, const HTuple& Greediness, const HTuple& ResultType, const HTuple& ParamName, const HTuple& ParamValue, HTuple* Score, HTuple* Row, HTuple* Column);

// Find the best matches of a calibrated deformable model in an image and return their 3D pose.
LIntExport void FindPlanarCalibDeformableModel(const HObject& Image, const HTuple& ModelID, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& ScaleRMin, const HTuple& ScaleRMax, const HTuple& ScaleCMin, const HTuple& ScaleCMax, const HTuple& MinScore, const HTuple& NumMatches, const HTuple& MaxOverlap, const HTuple& NumLevels, const HTuple& Greediness, const HTuple& ParamName, const HTuple& ParamValue, HTuple* Pose, HTuple* CovPose, HTuple* Score);

// Find the best matches of a planar projective invariant deformable model in an image.
LIntExport void FindPlanarUncalibDeformableModel(const HObject& Image, const HTuple& ModelID, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& ScaleRMin, const HTuple& ScaleRMax, const HTuple& ScaleCMin, const HTuple& ScaleCMax, const HTuple& MinScore, const HTuple& NumMatches, const HTuple& MaxOverlap, const HTuple& NumLevels, const HTuple& Greediness, const HTuple& ParamName, const HTuple& ParamValue, HTuple* HomMat2D, HTuple* Score);

// Set the metric of a local deformable model that was created from XLD contours.
LIntExport void SetLocalDeformableModelMetric(const HObject& Image, const HObject& VectorField, const HTuple& ModelID, const HTuple& Metric);

// Set the metric of a planar calibrated deformable model that was created from XLD contours.
LIntExport void SetPlanarCalibDeformableModelMetric(const HObject& Image, const HTuple& ModelID, const HTuple& Pose, const HTuple& Metric);

// Set the metric of a planar uncalibrated deformable model that was created from XLD contours.
LIntExport void SetPlanarUncalibDeformableModelMetric(const HObject& Image, const HTuple& ModelID, const HTuple& HomMat2D, const HTuple& Metric);

// Prepare a deformable model for local deformable matching from XLD contours.
LIntExport void CreateLocalDeformableModelXld(const HObject& Contours, const HTuple& NumLevels, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& AngleStep, const HTuple& ScaleRMin, const HTuple& ScaleRMax, const HTuple& ScaleRStep, const HTuple& ScaleCMin, const HTuple& ScaleCMax, const HTuple& ScaleCStep, const HTuple& Optimization, const HTuple& Metric, const HTuple& MinContrast, const HTuple& ParamName, const HTuple& ParamValue, HTuple* ModelID);

// Prepare a deformable model for planar calibrated matching from XLD contours.
LIntExport void CreatePlanarCalibDeformableModelXld(const HObject& Contours, const HTuple& CamParam, const HTuple& ReferencePose, const HTuple& NumLevels, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& AngleStep, const HTuple& ScaleRMin, const HTuple& ScaleRMax, const HTuple& ScaleRStep, const HTuple& ScaleCMin, const HTuple& ScaleCMax, const HTuple& ScaleCStep, const HTuple& Optimization, const HTuple& Metric, const HTuple& MinContrast, const HTuple& ParamName, const HTuple& ParamValue, HTuple* ModelID);

// Prepare a deformable model for planar uncalibrated matching from XLD contours.
LIntExport void CreatePlanarUncalibDeformableModelXld(const HObject& Contours, const HTuple& NumLevels, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& AngleStep, const HTuple& ScaleRMin, const HTuple& ScaleRMax, const HTuple& ScaleRStep, const HTuple& ScaleCMin, const HTuple& ScaleCMax, const HTuple& ScaleCStep, const HTuple& Optimization, const HTuple& Metric, const HTuple& MinContrast, const HTuple& ParamName, const HTuple& ParamValue, HTuple* ModelID);

// Creates a deformable model for local, deformable matching.
LIntExport void CreateLocalDeformableModel(const HObject& Template, const HTuple& NumLevels, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& AngleStep, const HTuple& ScaleRMin, const HTuple& ScaleRMax, const HTuple& ScaleRStep, const HTuple& ScaleCMin, const HTuple& ScaleCMax, const HTuple& ScaleCStep, const HTuple& Optimization, const HTuple& Metric, const HTuple& Contrast, const HTuple& MinContrast, const HTuple& ParamName, const HTuple& ParamValue, HTuple* ModelID);

// Create a deformable model for calibrated perspective matching.
LIntExport void CreatePlanarCalibDeformableModel(const HObject& Template, const HTuple& CamParam, const HTuple& ReferencePose, const HTuple& NumLevels, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& AngleStep, const HTuple& ScaleRMin, const HTuple& ScaleRMax, const HTuple& ScaleRStep, const HTuple& ScaleCMin, const HTuple& ScaleCMax, const HTuple& ScaleCStep, const HTuple& Optimization, const HTuple& Metric, const HTuple& Contrast, const HTuple& MinContrast, const HTuple& ParamName, const HTuple& ParamValue, HTuple* ModelID);

// Creates a deformable model for uncalibrated, perspective matching.
LIntExport void CreatePlanarUncalibDeformableModel(const HObject& Template, const HTuple& NumLevels, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& AngleStep, const HTuple& ScaleRMin, const HTuple& ScaleRMax, const HTuple& ScaleRStep, const HTuple& ScaleCMin, const HTuple& ScaleCMax, const HTuple& ScaleCStep, const HTuple& Optimization, const HTuple& Metric, const HTuple& Contrast, const HTuple& MinContrast, const HTuple& ParamName, const HTuple& ParamValue, HTuple* ModelID);

// Free the memory of all NCC models.
LIntExport void ClearAllNccModels();

// Free the memory of an NCC model.
LIntExport void ClearNccModel(const HTuple& ModelID);

// Deserialize an NCC model.
LIntExport void DeserializeNccModel(const HTuple& SerializedItemHandle, HTuple* ModelID);

// Serialize an NCC model.
LIntExport void SerializeNccModel(const HTuple& ModelID, HTuple* SerializedItemHandle);

// Read an NCC model from a file.
LIntExport void ReadNccModel(const HTuple& FileName, HTuple* ModelID);

// Write an NCC model to a file.
LIntExport void WriteNccModel(const HTuple& ModelID, const HTuple& FileName);

// Determine the parameters of an NCC model.
LIntExport void DetermineNccModelParams(const HObject& Template, const HTuple& NumLevels, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& Metric, const HTuple& Parameters, HTuple* ParameterName, HTuple* ParameterValue);

// Return the parameters of an NCC model.
LIntExport void GetNccModelParams(const HTuple& ModelID, HTuple* NumLevels, HTuple* AngleStart, HTuple* AngleExtent, HTuple* AngleStep, HTuple* Metric);

// Return the origin (reference point) of an NCC model.
LIntExport void GetNccModelOrigin(const HTuple& ModelID, HTuple* Row, HTuple* Column);

// Set the origin (reference point) of an NCC model.
LIntExport void SetNccModelOrigin(const HTuple& ModelID, const HTuple& Row, const HTuple& Column);

// Find the best matches of an NCC model in an image.
LIntExport void FindNccModel(const HObject& Image, const HTuple& ModelID, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& MinScore, const HTuple& NumMatches, const HTuple& MaxOverlap, const HTuple& SubPixel, const HTuple& NumLevels, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* Score);

// Set selected parameters of the NCC model.
LIntExport void SetNccModelParam(const HTuple& ModelID, const HTuple& GenParamNames, const HTuple& GenParamValues);

// Prepare an NCC model for matching.
LIntExport void CreateNccModel(const HObject& Template, const HTuple& NumLevels, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& AngleStep, const HTuple& Metric, HTuple* ModelID);

// Return the components of a found instance of a component model.
LIntExport void GetFoundComponentModel(HObject* FoundComponents, const HTuple& ComponentModelID, const HTuple& ModelStart, const HTuple& ModelEnd, const HTuple& RowComp, const HTuple& ColumnComp, const HTuple& AngleComp, const HTuple& ScoreComp, const HTuple& ModelComp, const HTuple& ModelMatch, const HTuple& MarkOrientation, HTuple* RowCompInst, HTuple* ColumnCompInst, HTuple* AngleCompInst, HTuple* ScoreCompInst);

// Find the best matches of a component model in an image.
LIntExport void FindComponentModel(const HObject& Image, const HTuple& ComponentModelID, const HTuple& RootComponent, const HTuple& AngleStartRoot, const HTuple& AngleExtentRoot, const HTuple& MinScore, const HTuple& NumMatches, const HTuple& MaxOverlap, const HTuple& IfRootNotFound, const HTuple& IfComponentNotFound, const HTuple& PosePrediction, const HTuple& MinScoreComp, const HTuple& SubPixelComp, const HTuple& NumLevelsComp, const HTuple& GreedinessComp, HTuple* ModelStart, HTuple* ModelEnd, HTuple* Score, HTuple* RowComp, HTuple* ColumnComp, HTuple* AngleComp, HTuple* ScoreComp, HTuple* ModelComp);

// Free the memory of all component models.
LIntExport void ClearAllComponentModels();

// Free the memory of a component model.
LIntExport void ClearComponentModel(const HTuple& ComponentModelID);

// Return the search tree of a component model.
LIntExport void GetComponentModelTree(HObject* Tree, HObject* Relations, const HTuple& ComponentModelID, const HTuple& RootComponent, const HTuple& Image, HTuple* StartNode, HTuple* EndNode, HTuple* Row, HTuple* Column, HTuple* Phi, HTuple* Length1, HTuple* Length2, HTuple* AngleStart, HTuple* AngleExtent);

// Return the parameters of a component model.
LIntExport void GetComponentModelParams(const HTuple& ComponentModelID, HTuple* MinScoreComp, HTuple* RootRanking, HTuple* ShapeModelIDs);

// Deserialize a serialized component model.
LIntExport void DeserializeComponentModel(const HTuple& SerializedItemHandle, HTuple* ComponentModelID);

// Serialize a component model.
LIntExport void SerializeComponentModel(const HTuple& ComponentModelID, HTuple* SerializedItemHandle);

// Read a component model from a file.
LIntExport void ReadComponentModel(const HTuple& FileName, HTuple* ComponentModelID);

// Write a component model to a file.
LIntExport void WriteComponentModel(const HTuple& ComponentModelID, const HTuple& FileName);

// Prepare a component model for matching based on explicitly specified components and relations.
LIntExport void CreateComponentModel(const HObject& ModelImage, const HObject& ComponentRegions, const HTuple& VariationRow, const HTuple& VariationColumn, const HTuple& VariationAngle, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& ContrastLowComp, const HTuple& ContrastHighComp, const HTuple& MinSizeComp, const HTuple& MinContrastComp, const HTuple& MinScoreComp, const HTuple& NumLevelsComp, const HTuple& AngleStepComp, const HTuple& OptimizationComp, const HTuple& MetricComp, const HTuple& PregenerationComp, HTuple* ComponentModelID, HTuple* RootRanking);

// Prepare a component model for matching based on trained components.
LIntExport void CreateTrainedComponentModel(const HTuple& ComponentTrainingID, const HTuple& AngleStart, const HTuple& AngleExtent, const HTuple& MinContrastComp, const HTuple& MinScoreComp, const HTuple& NumLevelsComp, const HTuple& AngleStepComp, const HTuple& OptimizationComp, const HTuple& MetricComp, const HTuple& PregenerationComp, HTuple* ComponentModelID, HTuple* RootRanking);

// Free the memory of all component training results.
LIntExport void ClearAllTrainingComponents();

// Free the memory of a component training result.
LIntExport void ClearTrainingComponents(const HTuple& ComponentTrainingID);

// Return the relations between the model components that are contained in a training result.
LIntExport void GetComponentRelations(HObject* Relations, const HTuple& ComponentTrainingID, const HTuple& ReferenceComponent, const HTuple& Image, HTuple* Row, HTuple* Column, HTuple* Phi, HTuple* Length1, HTuple* Length2, HTuple* AngleStart, HTuple* AngleExtent);

// Return the initial or model components in a certain image.
LIntExport void GetTrainingComponents(HObject* TrainingComponents, const HTuple& ComponentTrainingID, const HTuple& Components, const HTuple& Image, const HTuple& MarkOrientation, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* Score);

// Modify the relations within a training result.
LIntExport void ModifyComponentRelations(const HTuple& ComponentTrainingID, const HTuple& ReferenceComponent, const HTuple& ToleranceComponent, const HTuple& PositionTolerance, const HTuple& AngleTolerance);

// Deserialize a component training result.
LIntExport void DeserializeTrainingComponents(const HTuple& SerializedItemHandle, HTuple* ComponentTrainingID);

// Serialize a component training result.
LIntExport void SerializeTrainingComponents(const HTuple& ComponentTrainingID, HTuple* SerializedItemHandle);

// Read a component training result from a file.
LIntExport void ReadTrainingComponents(const HTuple& FileName, HTuple* ComponentTrainingID);

// Write a component training result to a file.
LIntExport void WriteTrainingComponents(const HTuple& ComponentTrainingID, const HTuple& FileName);

// Adopt new parameters that are used to create the model components into the training result.
LIntExport void ClusterModelComponents(const HObject& TrainingImages, HObject* ModelComponents, const HTuple& ComponentTrainingID, const HTuple& AmbiguityCriterion, const HTuple& MaxContourOverlap, const HTuple& ClusterThreshold);

// Inspect the rigid model components obtained from the training.
LIntExport void InspectClusteredComponents(HObject* ModelComponents, const HTuple& ComponentTrainingID, const HTuple& AmbiguityCriterion, const HTuple& MaxContourOverlap, const HTuple& ClusterThreshold);

// Train components and relations for the component-based matching.
LIntExport void TrainModelComponents(const HObject& ModelImage, const HObject& InitialComponents, const HObject& TrainingImages, HObject* ModelComponents, const HTuple& ContrastLow, const HTuple& ContrastHigh, const HTuple& MinSize, const HTuple& MinScore, const HTuple& SearchRowTol, const HTuple& SearchColumnTol, const HTuple& SearchAngleTol, const HTuple& TrainingEmphasis, const HTuple& AmbiguityCriterion, const HTuple& MaxContourOverlap, const HTuple& ClusterThreshold, HTuple* ComponentTrainingID);

// Extract the initial components of a component model.
LIntExport void GenInitialComponents(const HObject& ModelImage, HObject* InitialComponents, const HTuple& ContrastLow, const HTuple& ContrastHigh, const HTuple& MinSize, const HTuple& Mode, const HTuple& GenericName, const HTuple& GenericValue);

// Get details of a result from deformable surface based matching.
LIntExport void GetDeformableSurfaceMatchingResult(const HTuple& DeformableSurfaceMatchingResult, const HTuple& ResultName, const HTuple& ResultIndex, HTuple* ResultValue);

// Free the memory of a deformable surface matching result.
LIntExport void ClearDeformableSurfaceMatchingResult(const HTuple& DeformableSurfaceMatchingResult);

// Free the memory of a deformable surface model.
LIntExport void ClearDeformableSurfaceModel(const HTuple& DeformableSurfaceModel);

// Deserialize a deformable surface model.
LIntExport void DeserializeDeformableSurfaceModel(const HTuple& SerializedItemHandle, HTuple* DeformableSurfaceModel);

// Serialize a deformable surface_model.
LIntExport void SerializeDeformableSurfaceModel(const HTuple& DeformableSurfaceModel, HTuple* SerializedItemHandle);

// Read a deformable surface model from a file.
LIntExport void ReadDeformableSurfaceModel(const HTuple& FileName, HTuple* DeformableSurfaceModel);

// Write a deformable surface model to a file.
LIntExport void WriteDeformableSurfaceModel(const HTuple& DeformableSurfaceModel, const HTuple& FileName);

// Refine the position and deformation of a deformable surface model in a 3D scene.
LIntExport void RefineDeformableSurfaceModel(const HTuple& DeformableSurfaceModel, const HTuple& ObjectModel3D, const HTuple& RelSamplingDistance, const HTuple& InitialDeformationObjectModel3D, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* Score, HTuple* DeformableSurfaceMatchingResult);

// Find the best match of a deformable surface model in a 3D scene.
LIntExport void FindDeformableSurfaceModel(const HTuple& DeformableSurfaceModel, const HTuple& ObjectModel3D, const HTuple& RelSamplingDistance, const HTuple& MinScore, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* Score, HTuple* DeformableSurfaceMatchingResult);

// Return the parameters and properties of a deformable surface model.
LIntExport void GetDeformableSurfaceModelParam(const HTuple& DeformableSurfaceModel, const HTuple& ParamName, HTuple* ParamValue);

// Add a reference point to a deformable surface model.
LIntExport void AddDeformableSurfaceModelReferencePoint(const HTuple& DeformableSurfaceModel, const HTuple& ReferencePointX, const HTuple& ReferencePointY, const HTuple& ReferencePointZ, HTuple* ReferencePointIndex);

// Add a sample deformation to a deformable surface model
LIntExport void AddDeformableSurfaceModelSample(const HTuple& DeformableSurfaceModel, const HTuple& ObjectModel3D);

// Create the data structure needed to perform deformable surface-based matching.
LIntExport void CreateDeformableSurfaceModel(const HTuple& ObjectModel3D, const HTuple& RelSamplingDistance, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* DeformableSurfaceModel);

// Get details of a result from surface based matching.
LIntExport void GetSurfaceMatchingResult(const HTuple& SurfaceMatchingResultID, const HTuple& ResultName, const HTuple& ResultIndex, HTuple* ResultValue);

// Free the memory of all surface matching results.
LIntExport void ClearAllSurfaceMatchingResults();

// Free the memory of a surface matching result.
LIntExport void ClearSurfaceMatchingResult(const HTuple& SurfaceMatchingResultID);

// Free the memory of all surface models.
LIntExport void ClearAllSurfaceModels();

// Free the memory of a surface model.
LIntExport void ClearSurfaceModel(const HTuple& SurfaceModelID);

// Deserialize a surface model.
LIntExport void DeserializeSurfaceModel(const HTuple& SerializedItemHandle, HTuple* SurfaceModelID);

// Serialize a surface_model.
LIntExport void SerializeSurfaceModel(const HTuple& SurfaceModelID, HTuple* SerializedItemHandle);

// Read a surface model from a file.
LIntExport void ReadSurfaceModel(const HTuple& FileName, HTuple* SurfaceModelID);

// Write a surface model to a file.
LIntExport void WriteSurfaceModel(const HTuple& SurfaceModelID, const HTuple& FileName);

// Refine the pose of a surface model in a 3D scene.
LIntExport void RefineSurfaceModelPose(const HTuple& SurfaceModelID, const HTuple& ObjectModel3D, const HTuple& InitialPose, const HTuple& MinScore, const HTuple& ReturnResultHandle, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* Pose, HTuple* Score, HTuple* SurfaceMatchingResultID);

// Find the best matches of a surface model in a 3D scene.
LIntExport void FindSurfaceModel(const HTuple& SurfaceModelID, const HTuple& ObjectModel3D, const HTuple& RelSamplingDistance, const HTuple& KeyPointFraction, const HTuple& MinScore, const HTuple& ReturnResultHandle, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* Pose, HTuple* Score, HTuple* SurfaceMatchingResultID);

// Return the parameters and properties of a surface model.
LIntExport void GetSurfaceModelParam(const HTuple& SurfaceModelID, const HTuple& ParamName, HTuple* ParamValue);

// Create the data structure needed to perform surface-based matching.
LIntExport void CreateSurfaceModel(const HTuple& ObjectModel3D, const HTuple& RelSamplingDistance, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* SurfaceModelID);

// Create a 3D camera pose from camera center and viewing direction.
LIntExport void CreateCamPoseLookAtPoint(const HTuple& CamPosX, const HTuple& CamPosY, const HTuple& CamPosZ, const HTuple& LookAtX, const HTuple& LookAtY, const HTuple& LookAtZ, const HTuple& RefPlaneNormal, const HTuple& CamRoll, HTuple* CamPose);

// Convert spherical coordinates of a 3D point to Cartesian coordinates.
LIntExport void ConvertPoint3dSpherToCart(const HTuple& Longitude, const HTuple& Latitude, const HTuple& Radius, const HTuple& EquatPlaneNormal, const HTuple& ZeroMeridian, HTuple* X, HTuple* Y, HTuple* Z);

// Convert Cartesian coordinates of a 3D point to spherical coordinates.
LIntExport void ConvertPoint3dCartToSpher(const HTuple& X, const HTuple& Y, const HTuple& Z, const HTuple& EquatPlaneNormal, const HTuple& ZeroMeridian, HTuple* Longitude, HTuple* Latitude, HTuple* Radius);

// Free the memory of all 3D shape models.
LIntExport void ClearAllShapeModel3d();

// Free the memory of a 3D shape model.
LIntExport void ClearShapeModel3d(const HTuple& ShapeModel3DID);

// Deserialize a serialized 3D shape model.
LIntExport void DeserializeShapeModel3d(const HTuple& SerializedItemHandle, HTuple* ShapeModel3DID);

// Serialize a 3D shape model.
LIntExport void SerializeShapeModel3d(const HTuple& ShapeModel3DID, HTuple* SerializedItemHandle);

// Read a 3D shape model from a file.
LIntExport void ReadShapeModel3d(const HTuple& FileName, HTuple* ShapeModel3DID);

// Write a 3D shape model to a file.
LIntExport void WriteShapeModel3d(const HTuple& ShapeModel3DID, const HTuple& FileName);

// Transform a pose that refers to the coordinate system of a 3D object model to a pose that refers to the reference coordinate system of a 3D shape model and vice versa.
LIntExport void TransPoseShapeModel3d(const HTuple& ShapeModel3DID, const HTuple& PoseIn, const HTuple& Transformation, HTuple* PoseOut);

// Project the edges of a 3D shape model into image coordinates.
LIntExport void ProjectShapeModel3d(HObject* ModelContours, const HTuple& ShapeModel3DID, const HTuple& CamParam, const HTuple& Pose, const HTuple& HiddenSurfaceRemoval, const HTuple& MinFaceAngle);

// Return the contour representation of a 3D shape model view.
LIntExport void GetShapeModel3dContours(HObject* ModelContours, const HTuple& ShapeModel3DID, const HTuple& Level, const HTuple& View, HTuple* ViewPose);

// Return the parameters of a 3D shape model.
LIntExport void GetShapeModel3dParams(const HTuple& ShapeModel3DID, const HTuple& GenParamNames, HTuple* GenParamValues);

// Find the best matches of a 3D shape model in an image.
LIntExport void FindShapeModel3d(const HObject& Image, const HTuple& ShapeModel3DID, const HTuple& MinScore, const HTuple& Greediness, const HTuple& NumLevels, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* Pose, HTuple* CovPose, HTuple* Score);

// Prepare a 3D object model for matching.
LIntExport void CreateShapeModel3d(const HTuple& ObjectModel3D, const HTuple& CamParam, const HTuple& RefRotX, const HTuple& RefRotY, const HTuple& RefRotZ, const HTuple& OrderOfRotation, const HTuple& LongitudeMin, const HTuple& LongitudeMax, const HTuple& LatitudeMin, const HTuple& LatitudeMax, const HTuple& CamRollMin, const HTuple& CamRollMax, const HTuple& DistMin, const HTuple& DistMax, const HTuple& MinContrast, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* ShapeModel3DID);

// Simplify a triangulated 3D object model.
LIntExport void SimplifyObjectModel3d(const HTuple& ObjectModel3D, const HTuple& Method, const HTuple& Amount, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* SimplifiedObjectModel3D);

// Compute the distances of the points of one 3D object model to another 3D object model.
LIntExport void DistanceObjectModel3d(const HTuple& ObjectModel3DFrom, const HTuple& ObjectModel3DTo, const HTuple& Pose, const HTuple& MaxDistance, const HTuple& GenParamNames, const HTuple& GenParamValues);

// Combine several 3D object models to a new 3D object model.
LIntExport void UnionObjectModel3d(const HTuple& ObjectModels3D, const HTuple& Method, HTuple* UnionObjectModel3D);

// Set attributes of a 3D object model.
LIntExport void SetObjectModel3dAttribMod(const HTuple& ObjectModel3D, const HTuple& AttribName, const HTuple& AttachExtAttribTo, const HTuple& AttribValues);

// Set attributes of a 3D object model.
LIntExport void SetObjectModel3dAttrib(const HTuple& ObjectModel3D, const HTuple& AttribName, const HTuple& AttachExtAttribTo, const HTuple& AttribValues, HTuple* ObjectModel3DOut);

// Create an empty 3D object model.
LIntExport void GenEmptyObjectModel3d(HTuple* EmptyObjectModel3D);

// Sample a 3D object model.
LIntExport void SampleObjectModel3d(const HTuple& ObjectModel3D, const HTuple& Method, const HTuple& SampleDistance, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* SampledObjectModel3D);

// Improve the relative transformations between 3D object models based on  their overlaps.
LIntExport void RegisterObjectModel3dGlobal(const HTuple& ObjectModels3D, const HTuple& HomMats3D, const HTuple& From, const HTuple& To, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* HomMats3DOut, HTuple* Scores);

// Search for a transformation between two 3D object models.
LIntExport void RegisterObjectModel3dPair(const HTuple& ObjectModel3D1, const HTuple& ObjectModel3D2, const HTuple& Method, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* Pose, HTuple* Score);

// Create a 3D object model that represents a point cloud from a set of 3D points.
LIntExport void GenObjectModel3dFromPoints(const HTuple& X, const HTuple& Y, const HTuple& Z, HTuple* ObjectModel3D);

// Create a 3D object model that represents a box.
LIntExport void GenBoxObjectModel3d(const HTuple& Pose, const HTuple& LengthX, const HTuple& LengthY, const HTuple& LengthZ, HTuple* ObjectModel3D);

// Create a 3D object model that represents a plane.
LIntExport void GenPlaneObjectModel3d(const HTuple& Pose, const HTuple& XExtent, const HTuple& YExtent, HTuple* ObjectModel3D);

// Create a 3D object model that represents a sphere from x,y,z coordinates.
LIntExport void GenSphereObjectModel3dCenter(const HTuple& X, const HTuple& Y, const HTuple& Z, const HTuple& Radius, HTuple* ObjectModel3D);

// Create a 3D object model that represents a sphere.
LIntExport void GenSphereObjectModel3d(const HTuple& Pose, const HTuple& Radius, HTuple* ObjectModel3D);

// Create a 3D object model that represents a cylinder.
LIntExport void GenCylinderObjectModel3d(const HTuple& Pose, const HTuple& Radius, const HTuple& MinExtent, const HTuple& MaxExtent, HTuple* ObjectModel3D);

// Calculate the smallest bounding box around the points of a  3D object model.
LIntExport void SmallestBoundingBoxObjectModel3d(const HTuple& ObjectModel3D, const HTuple& Type, HTuple* Pose, HTuple* Length1, HTuple* Length2, HTuple* Length3);

// Calculate the smallest sphere around the points of a 3D object model.
LIntExport void SmallestSphereObjectModel3d(const HTuple& ObjectModel3D, HTuple* CenterPoint, HTuple* Radius);

// Intersect a 3D object model with a plane.
LIntExport void IntersectPlaneObjectModel3d(const HTuple& ObjectModel3D, const HTuple& Plane, HTuple* ObjectModel3DIntersection);

// Calculate the convex hull of a 3D object model. 
LIntExport void ConvexHullObjectModel3d(const HTuple& ObjectModel3D, HTuple* ObjectModel3DConvexHull);

// Select 3D object models from an array of 3D object models according  to global features.
LIntExport void SelectObjectModel3d(const HTuple& ObjectModel3D, const HTuple& Feature, const HTuple& Operation, const HTuple& MinValue, const HTuple& MaxValue, HTuple* ObjectModel3DSelected);

// Calculate the area of all faces of a 3D object model.
LIntExport void AreaObjectModel3d(const HTuple& ObjectModel3D, HTuple* Area);

// Calculate the maximal diameter of a 3D object model.
LIntExport void MaxDiameterObjectModel3d(const HTuple& ObjectModel3D, HTuple* Diameter);

// Calculates the mean or the central moment of second order for a 3D object  model.
LIntExport void MomentsObjectModel3d(const HTuple& ObjectModel3D, const HTuple& MomentsToCalculate, HTuple* Moments);

// Calculate the volume of a 3D object model relative to a plane.
LIntExport void VolumeObjectModel3dRelativeToPlane(const HTuple& ObjectModel3D, const HTuple& Plane, const HTuple& Mode, const HTuple& UseFaceOrientation, HTuple* Volume);

// Remove points from a 3D object model by projecting it to a virtual view  and removing all points outside of a given region.
LIntExport void ReduceObjectModel3dByView(const HObject& Region, const HTuple& ObjectModel3D, const HTuple& CamParam, const HTuple& Pose, HTuple* ObjectModel3DReduced);

// Determine the connected components of the 3D object model.
LIntExport void ConnectionObjectModel3d(const HTuple& ObjectModel3D, const HTuple& Feature, const HTuple& Value, HTuple* ObjectModel3DConnected);

// Apply a threshold to an attribute of 3D object models.
LIntExport void SelectPointsObjectModel3d(const HTuple& ObjectModel3D, const HTuple& Attrib, const HTuple& MinValue, const HTuple& MaxValue, HTuple* ObjectModel3DThresholded);

// Get the depth or the index of a displayed 3D object model.
LIntExport void GetDispObjectModel3dInfo(const HTuple& WindowHandle, const HTuple& Row, const HTuple& Column, const HTuple& Information, HTuple* Value);

// Render 3D object models to get an image.
LIntExport void RenderObjectModel3d(HObject* Image, const HTuple& ObjectModel3D, const HTuple& CamParam, const HTuple& Pose, const HTuple& GenParamName, const HTuple& GenParamValue);

// Display 3D object models.
LIntExport void DispObjectModel3d(const HTuple& WindowHandle, const HTuple& ObjectModel3D, const HTuple& CamParam, const HTuple& Pose, const HTuple& GenParamName, const HTuple& GenParamValue);

// Copy a 3D object model.
LIntExport void CopyObjectModel3d(const HTuple& ObjectModel3D, const HTuple& Attributes, HTuple* CopiedObjectModel3D);

// Prepare a 3D object model for a certain operation.
LIntExport void PrepareObjectModel3d(const HTuple& ObjectModel3D, const HTuple& Purpose, const HTuple& OverwriteData, const HTuple& GenParamName, const HTuple& GenParamValue);

// Transform 3D points from a 3D object model to images.
LIntExport void ObjectModel3dToXyz(HObject* X, HObject* Y, HObject* Z, const HTuple& ObjectModel3D, const HTuple& Type, const HTuple& CamParam, const HTuple& Pose);

// Transform 3D points from images to a 3D object model.
LIntExport void XyzToObjectModel3d(const HObject& X, const HObject& Y, const HObject& Z, HTuple* ObjectModel3D);

// Return attributes of 3D object models.
LIntExport void GetObjectModel3dParams(const HTuple& ObjectModel3D, const HTuple& ParamName, HTuple* ParamValue);

// Project a 3D object model into image coordinates.
LIntExport void ProjectObjectModel3d(HObject* ModelContours, const HTuple& ObjectModel3D, const HTuple& CamParam, const HTuple& Pose, const HTuple& GenParamName, const HTuple& GenParamValue);

// Apply a rigid 3D transformation to 3D object models.
LIntExport void RigidTransObjectModel3d(const HTuple& ObjectModel3D, const HTuple& Pose, HTuple* ObjectModel3DRigidTrans);

// Apply an arbitrary projective 3D transformation to 3D object models.
LIntExport void ProjectiveTransObjectModel3d(const HTuple& ObjectModel3D, const HTuple& HomMat3D, HTuple* ObjectModel3DProjectiveTrans);

// Apply an arbitrary affine 3D transformation to 3D object models.
LIntExport void AffineTransObjectModel3d(const HTuple& ObjectModel3D, const HTuple& HomMat3D, HTuple* ObjectModel3DAffineTrans);

// Free the memory of all 3D object models.
LIntExport void ClearAllObjectModel3d();

// Free the memory of a 3D object model.
LIntExport void ClearObjectModel3d(const HTuple& ObjectModel3D);

// Serialize a 3D object model.
LIntExport void SerializeObjectModel3d(const HTuple& ObjectModel3D, HTuple* SerializedItemHandle);

// Deserialize a serialized 3D object model.
LIntExport void DeserializeObjectModel3d(const HTuple& SerializedItemHandle, HTuple* ObjectModel3D);

// Writes a 3D object model to a file.
LIntExport void WriteObjectModel3d(const HTuple& ObjectModel3D, const HTuple& FileType, const HTuple& FileName, const HTuple& GenParamName, const HTuple& GenParamValue);

// Read a 3D object model from a file.
LIntExport void ReadObjectModel3d(const HTuple& FileName, const HTuple& Scale, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* ObjectModel3D, HTuple* Status);

// Read a 3D object model from a DXF file.
LIntExport void ReadObjectModel3dDxf(const HTuple& FileName, const HTuple& Scale, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* ObjectModel3D, HTuple* DxfStatus);

// Read the description file of a Kalman filter.
LIntExport void ReadKalman(const HTuple& FileName, HTuple* Dimension, HTuple* Model, HTuple* Measurement, HTuple* Prediction);

// Read an update file of a Kalman filter.
LIntExport void UpdateKalman(const HTuple& FileName, const HTuple& DimensionIn, const HTuple& ModelIn, const HTuple& MeasurementIn, HTuple* DimensionOut, HTuple* ModelOut, HTuple* MeasurementOut);

// Estimate the current state of a system with the help of the Kalman filtering.
LIntExport void FilterKalman(const HTuple& Dimension, const HTuple& Model, const HTuple& Measurement, const HTuple& PredictionIn, HTuple* PredictionOut, HTuple* Estimate);

// Query slots concerning information with relation to the operator get_operator_info.
LIntExport void QueryOperatorInfo(HTuple* Slots);

// Query slots of the online-information concerning the operator get_param_info.
LIntExport void QueryParamInfo(HTuple* Slots);

// Get operators with the given string as a substring of their name.
LIntExport void GetOperatorName(const HTuple& Pattern, HTuple* OperatorNames);

// Get default data type for the control parameters of a HALCON-operator.
LIntExport void GetParamTypes(const HTuple& OperatorName, HTuple* InpCtrlParType, HTuple* OutpCtrlParType);

// Get number of the different parameter classes of a HALCON-operator.
LIntExport void GetParamNum(const HTuple& OperatorName, HTuple* CName, HTuple* InpObjPar, HTuple* OutpObjPar, HTuple* InpCtrlPar, HTuple* OutpCtrlPar, HTuple* Type);

// Get the names of the parameters of a HALCON-operator.
LIntExport void GetParamNames(const HTuple& OperatorName, HTuple* InpObjPar, HTuple* OutpObjPar, HTuple* InpCtrlPar, HTuple* OutpCtrlPar);

// Get information concerning a HALCON-operator.
LIntExport void GetOperatorInfo(const HTuple& OperatorName, const HTuple& Slot, HTuple* Information);

// Get information concerning the operator parameters.
LIntExport void GetParamInfo(const HTuple& OperatorName, const HTuple& ParamName, const HTuple& Slot, HTuple* Information);

// Search names of all operators assigned to one keyword.
LIntExport void SearchOperator(const HTuple& Keyword, HTuple* OperatorNames);

// Get keywords which are assigned to operators.
LIntExport void GetKeywords(const HTuple& OperatorName, HTuple* Keywords);

// Get information concerning the chapters on operators.
LIntExport void GetChapterInfo(const HTuple& Chapter, HTuple* Info);

// Convert one-channel images into a multichannel image
LIntExport void ChannelsToImage(const HObject& Images, HObject* MultiChannelImage);

// Convert a multichannel image into One-channel images
LIntExport void ImageToChannels(const HObject& MultiChannelImage, HObject* Images);

// Convert 7 images into a seven-channel image.
LIntExport void Compose7(const HObject& Image1, const HObject& Image2, const HObject& Image3, const HObject& Image4, const HObject& Image5, const HObject& Image6, const HObject& Image7, HObject* MultiChannelImage);

// Convert 6 images into a six-channel image.
LIntExport void Compose6(const HObject& Image1, const HObject& Image2, const HObject& Image3, const HObject& Image4, const HObject& Image5, const HObject& Image6, HObject* MultiChannelImage);

// Convert 5 images into a five-channel image.
LIntExport void Compose5(const HObject& Image1, const HObject& Image2, const HObject& Image3, const HObject& Image4, const HObject& Image5, HObject* MultiChannelImage);

// Convert 4 images into a four-channel image.
LIntExport void Compose4(const HObject& Image1, const HObject& Image2, const HObject& Image3, const HObject& Image4, HObject* MultiChannelImage);

// Convert 3 images into a three-channel image.
LIntExport void Compose3(const HObject& Image1, const HObject& Image2, const HObject& Image3, HObject* MultiChannelImage);

// Convert two images into a two-channel image.
LIntExport void Compose2(const HObject& Image1, const HObject& Image2, HObject* MultiChannelImage);

// Convert a seven-channel image into seven images.
LIntExport void Decompose7(const HObject& MultiChannelImage, HObject* Image1, HObject* Image2, HObject* Image3, HObject* Image4, HObject* Image5, HObject* Image6, HObject* Image7);

// Convert a six-channel image into six images.
LIntExport void Decompose6(const HObject& MultiChannelImage, HObject* Image1, HObject* Image2, HObject* Image3, HObject* Image4, HObject* Image5, HObject* Image6);

// Convert a five-channel image into five images.
LIntExport void Decompose5(const HObject& MultiChannelImage, HObject* Image1, HObject* Image2, HObject* Image3, HObject* Image4, HObject* Image5);

// Convert a four-channel image into four images.
LIntExport void Decompose4(const HObject& MultiChannelImage, HObject* Image1, HObject* Image2, HObject* Image3, HObject* Image4);

// Convert a three-channel image into three images.
LIntExport void Decompose3(const HObject& MultiChannelImage, HObject* Image1, HObject* Image2, HObject* Image3);

// Convert a two-channel image into two images.
LIntExport void Decompose2(const HObject& MultiChannelImage, HObject* Image1, HObject* Image2);

// Count channels of image.
LIntExport void CountChannels(const HObject& MultiChannelImage, HTuple* Channels);

// Append additional matrices (channels) to the image.
LIntExport void AppendChannel(const HObject& MultiChannelImage, const HObject& Image, HObject* ImageExtended);

// Access a channel of a multichannel image.
LIntExport void AccessChannel(const HObject& MultiChannelImage, HObject* Image, const HTuple& Channel);

// Tile multiple image objects into a large image with explicit positioning information.
LIntExport void TileImagesOffset(const HObject& Images, HObject* TiledImage, const HTuple& OffsetRow, const HTuple& OffsetCol, const HTuple& Row1, const HTuple& Col1, const HTuple& Row2, const HTuple& Col2, const HTuple& Width, const HTuple& Height);

// Tile multiple image objects into a large image.
LIntExport void TileImages(const HObject& Images, HObject* TiledImage, const HTuple& NumColumns, const HTuple& TileOrder);

// Tile multiple images into a large image.
LIntExport void TileChannels(const HObject& Image, HObject* TiledImage, const HTuple& NumColumns, const HTuple& TileOrder);

// Cut out of defined gray values.
LIntExport void CropDomain(const HObject& Image, HObject* ImagePart);

// Cut out one or more rectangular image areas.
LIntExport void CropRectangle1(const HObject& Image, HObject* ImagePart, const HTuple& Row1, const HTuple& Column1, const HTuple& Row2, const HTuple& Column2);

// Cut out one or more rectangular image areas.
LIntExport void CropPart(const HObject& Image, HObject* ImagePart, const HTuple& Row, const HTuple& Column, const HTuple& Width, const HTuple& Height);

// Change image size.
LIntExport void ChangeFormat(const HObject& Image, HObject* ImagePart, const HTuple& Width, const HTuple& Height);

// Change definition domain of an image.
LIntExport void ChangeDomain(const HObject& Image, const HObject& NewDomain, HObject* ImageNew);

// Add gray values to regions.
LIntExport void AddChannels(const HObject& Regions, const HObject& Image, HObject* GrayRegions);

// Reduce the domain of an image to a rectangle.
LIntExport void Rectangle1Domain(const HObject& Image, HObject* ImageReduced, const HTuple& Row1, const HTuple& Column1, const HTuple& Row2, const HTuple& Column2);

// Reduce the domain of an image.
LIntExport void ReduceDomain(const HObject& Image, const HObject& Region, HObject* ImageReduced);

// Expand the domain of an image to maximum.
LIntExport void FullDomain(const HObject& Image, HObject* ImageFull);

// Get the domain of an image.
LIntExport void GetDomain(const HObject& Image, HObject* Domain);

// Centres of circles for a specific radius.
LIntExport void HoughCircles(const HObject& RegionIn, HObject* RegionOut, const HTuple& Radius, const HTuple& Percent, const HTuple& Mode);

// Return the Hough-Transform for circles with a given radius.
LIntExport void HoughCircleTrans(const HObject& Region, HObject* HoughImage, const HTuple& Radius);

// Detect lines in edge images with the help of the Hough transform using local gradient direction and return them in normal form.
LIntExport void HoughLinesDir(const HObject& ImageDir, HObject* HoughImage, HObject* Lines, const HTuple& DirectionUncertainty, const HTuple& AngleResolution, const HTuple& Smoothing, const HTuple& FilterSize, const HTuple& Threshold, const HTuple& AngleGap, const HTuple& DistGap, const HTuple& GenLines, HTuple* Angle, HTuple* Dist);

// Compute the Hough transform for lines using local gradient direction.
LIntExport void HoughLineTransDir(const HObject& ImageDir, HObject* HoughImage, const HTuple& DirectionUncertainty, const HTuple& AngleResolution);

// Detect lines in edge images with the help of the Hough transform and returns it in HNF.
LIntExport void HoughLines(const HObject& RegionIn, const HTuple& AngleResolution, const HTuple& Threshold, const HTuple& AngleGap, const HTuple& DistGap, HTuple* Angle, HTuple* Dist);

// Produce the Hough transform for lines within regions.
LIntExport void HoughLineTrans(const HObject& Region, HObject* HoughImage, const HTuple& AngleResolution);

// Select those lines from a set of lines (in HNF) which fit best into a region.
LIntExport void SelectMatchingLines(const HObject& RegionIn, HObject* RegionLines, const HTuple& AngleIn, const HTuple& DistIn, const HTuple& LineWidth, const HTuple& Thresh, HTuple* AngleOut, HTuple* DistOut);

// Segment the rectification grid region in the image.
LIntExport void FindRectificationGrid(const HObject& Image, HObject* GridRegion, const HTuple& MinContrast, const HTuple& Radius);

// Generate a PostScript file, which describes the rectification grid.
LIntExport void CreateRectificationGrid(const HTuple& Width, const HTuple& NumSquares, const HTuple& GridFile);

// Establish connections between the grid points of the rectification grid.
LIntExport void ConnectGridPoints(const HObject& Image, HObject* ConnectingLines, const HTuple& Row, const HTuple& Column, const HTuple& Sigma, const HTuple& MaxDist);

// Compute the mapping between the distorted image and the rectified image based upon the points of a regular grid.
LIntExport void GenGridRectificationMap(const HObject& Image, const HObject& ConnectingLines, HObject* Map, HObject* Meshes, const HTuple& GridSpacing, const HTuple& Rotation, const HTuple& Row, const HTuple& Column, const HTuple& MapType);

// Generate a projection map that describes the mapping between an arbitrarily distorted image and the rectified image.
LIntExport void GenArbitraryDistortionMap(HObject* Map, const HTuple& GridSpacing, const HTuple& Row, const HTuple& Column, const HTuple& GridWidth, const HTuple& ImageWidth, const HTuple& ImageHeight, const HTuple& MapType);

// Gets a copy of the background image of the HALCON window.
LIntExport void GetWindowBackgroundImage(HObject* BackgroundImage, const HTuple& WindowHandle);

// Add a callback function to a drawing object.
LIntExport void SetDrawingObjectCallback(const HTuple& DrawID, const HTuple& DrawObjectEvent, const HTuple& CallbackFunction);

// Detach the background image from a HALCON window.
LIntExport void DetachBackgroundFromWindow(const HTuple& WindowHandle);

// Attach a background image to a HALCON window.
LIntExport void AttachBackgroundToWindow(const HObject& Image, const HTuple& WindowHandle);

// Detach an existing drawing object from a HALCON window.
LIntExport void DetachDrawingObjectFromWindow(const HTuple& WindowHandle, const HTuple& DrawID);

// Attach an existing drawing object to a HALCON window.
LIntExport void AttachDrawingObjectToWindow(const HTuple& WindowHandle, const HTuple& DrawID);

// Modify the pose of a 3D plot.
LIntExport void UpdateWindowPose(const HTuple& WindowHandle, const HTuple& LastRow, const HTuple& LastCol, const HTuple& CurrentRow, const HTuple& CurrentCol, const HTuple& Mode);

// Calculates image coordinates for a point in a 3D plot window.
LIntExport void UnprojectCoordinates(const HObject& Image, const HTuple& WindowHandle, const HTuple& Row, const HTuple& Column, HTuple* ImageRow, HTuple* ImageColumn, HTuple* Height);

// Get the operating system window handle.
LIntExport void GetOsWindowHandle(const HTuple& WindowHandle, HTuple* OSWindowHandle, HTuple* OSDisplayHandle);

// Set the device context of a virtual graphics window (Windows NT).
LIntExport void SetWindowDc(const HTuple& WindowHandle, const HTuple& WINHDC);

// Create a virtual graphics window under Windows.
LIntExport void NewExternWindow(const HTuple& WINHWnd, const HTuple& Row, const HTuple& Column, const HTuple& Width, const HTuple& Height, HTuple* WindowHandle);

// Interactive output from two window buffers.
LIntExport void SlideImage(const HTuple& WindowHandleSource1, const HTuple& WindowHandleSource2, const HTuple& WindowHandle);

// Specify a window type.
LIntExport void SetWindowType(const HTuple& WindowType);

// Modify position and size of a window.
LIntExport void SetWindowExtents(const HTuple& WindowHandle, const HTuple& Row, const HTuple& Column, const HTuple& Width, const HTuple& Height);

// Get window characteristics.
LIntExport void GetWindowAttr(const HTuple& AttributeName, HTuple* AttributeValue);

// Set window characteristics.
LIntExport void SetWindowAttr(const HTuple& AttributeName, const HTuple& AttributeValue);

// Query all available window types.
LIntExport void QueryWindowType(HTuple* WindowTypes);

// Open a graphics window.
LIntExport void OpenWindow(const HTuple& Row, const HTuple& Column, const HTuple& Width, const HTuple& Height, const HTuple& FatherWindow, const HTuple& Mode, const HTuple& Machine, HTuple* WindowHandle);

// Open a textual window.
LIntExport void OpenTextwindow(const HTuple& Row, const HTuple& Column, const HTuple& Width, const HTuple& Height, const HTuple& BorderWidth, const HTuple& BorderColor, const HTuple& BackgroundColor, const HTuple& FatherWindow, const HTuple& Mode, const HTuple& Machine, HTuple* WindowHandle);

// Copy inside an output window.
LIntExport void MoveRectangle(const HTuple& WindowHandle, const HTuple& Row1, const HTuple& Column1, const HTuple& Row2, const HTuple& Column2, const HTuple& DestRow, const HTuple& DestColumn);

// Get the window type.
LIntExport void GetWindowType(const HTuple& WindowHandle, HTuple* WindowType);

// Access to a window's pixel data.
LIntExport void GetWindowPointer3(const HTuple& WindowHandle, HTuple* ImageRed, HTuple* ImageGreen, HTuple* ImageBlue, HTuple* Width, HTuple* Height);

// Information about a window's size and position.
LIntExport void GetWindowExtents(const HTuple& WindowHandle, HTuple* Row, HTuple* Column, HTuple* Width, HTuple* Height);

// Write the window content in an image object.
LIntExport void DumpWindowImage(HObject* Image, const HTuple& WindowHandle);

// Write the window content to a file.
LIntExport void DumpWindow(const HTuple& WindowHandle, const HTuple& Device, const HTuple& FileName);

// Copy all pixels within rectangles between output windows.
LIntExport void CopyRectangle(const HTuple& WindowHandleSource, const HTuple& WindowHandleDestination, const HTuple& Row1, const HTuple& Column1, const HTuple& Row2, const HTuple& Column2, const HTuple& DestRow, const HTuple& DestColumn);

// Close an output window.
LIntExport void CloseWindow(const HTuple& WindowHandle);

// Delete the contents of an output window.
LIntExport void ClearWindow(const HTuple& WindowHandle);

// Delete a rectangle on the output window.
LIntExport void ClearRectangle(const HTuple& WindowHandle, const HTuple& Row1, const HTuple& Column1, const HTuple& Row2, const HTuple& Column2);

// Print text in a window.
LIntExport void WriteString(const HTuple& WindowHandle, const HTuple& String);

// Set the shape of the text cursor.
LIntExport void SetTshape(const HTuple& WindowHandle, const HTuple& TextCursor);

// Set the position of the text cursor.
LIntExport void SetTposition(const HTuple& WindowHandle, const HTuple& Row, const HTuple& Column);

// Read a string in a text window.
LIntExport void ReadString(const HTuple& WindowHandle, const HTuple& InString, const HTuple& Length, HTuple* OutString);

// Read a character from a text window.
LIntExport void ReadChar(const HTuple& WindowHandle, HTuple* Char, HTuple* Code);

// Set the position of the text cursor to the beginning of the next line.
LIntExport void NewLine(const HTuple& WindowHandle);

// Get the shape of the text cursor.
LIntExport void GetTshape(const HTuple& WindowHandle, HTuple* TextCursor);

// Get cursor position.
LIntExport void GetTposition(const HTuple& WindowHandle, HTuple* Row, HTuple* Column);

// Get the maximum size of all characters of a font.
LIntExport void GetFontExtents(const HTuple& WindowHandle, HTuple* MaxAscent, HTuple* MaxDescent, HTuple* MaxWidth, HTuple* MaxHeight);

// Get the spatial size of a string.
LIntExport void GetStringExtents(const HTuple& WindowHandle, const HTuple& Values, HTuple* Ascent, HTuple* Descent, HTuple* Width, HTuple* Height);

// Query the available fonts.
LIntExport void QueryFont(const HTuple& WindowHandle, HTuple* Font);

// Query all shapes available for text cursors.
LIntExport void QueryTshape(const HTuple& WindowHandle, HTuple* TextCursor);

// Set the font used for text output.
LIntExport void SetFont(const HTuple& WindowHandle, const HTuple& Font);

// Get the current font.
LIntExport void GetFont(const HTuple& WindowHandle, HTuple* Font);

// Get the depth or the index of instances in a displayed 3D scene.
LIntExport void GetDisplayScene3dInfo(const HTuple& WindowHandle, const HTuple& Scene3D, const HTuple& Row, const HTuple& Column, const HTuple& Information, HTuple* Value);

// Set the pose of a 3D scene.
LIntExport void SetScene3dToWorldPose(const HTuple& Scene3D, const HTuple& ToWorldPose);

// Set parameters of a 3D scene.
LIntExport void SetScene3dParam(const HTuple& Scene3D, const HTuple& GenParamName, const HTuple& GenParamValue);

// Set parameters of a light in a 3D scene.
LIntExport void SetScene3dLightParam(const HTuple& Scene3D, const HTuple& LightIndex, const HTuple& GenParamName, const HTuple& GenParamValue);

// Set the pose of an instance in a 3D scene.
LIntExport void SetScene3dInstancePose(const HTuple& Scene3D, const HTuple& InstanceIndex, const HTuple& Pose);

// Set parameters of an instance in a 3D scene.
LIntExport void SetScene3dInstanceParam(const HTuple& Scene3D, const HTuple& InstanceIndex, const HTuple& GenParamName, const HTuple& GenParamValue);

// Set the pose of a camera in a 3D scene.
LIntExport void SetScene3dCameraPose(const HTuple& Scene3D, const HTuple& CameraIndex, const HTuple& Pose);

// Render an image of a 3D scene.
LIntExport void RenderScene3d(HObject* Image, const HTuple& Scene3D, const HTuple& CameraIndex);

// Remove a light from a 3D scene.
LIntExport void RemoveScene3dLight(const HTuple& Scene3D, const HTuple& LightIndex);

// Remove an object instance from a 3D scene.
LIntExport void RemoveScene3dInstance(const HTuple& Scene3D, const HTuple& InstanceIndex);

// Remove a camera from a 3D scene.
LIntExport void RemoveScene3dCamera(const HTuple& Scene3D, const HTuple& CameraIndex);

// Display a 3D scene.
LIntExport void DisplayScene3d(const HTuple& WindowHandle, const HTuple& Scene3D, const HTuple& CameraIndex);

// Add a light source to a 3D scene.
LIntExport void AddScene3dLight(const HTuple& Scene3D, const HTuple& LightPosition, const HTuple& LightKind, HTuple* LightIndex);

// Add an instance of a 3D object model to a 3D scene.
LIntExport void AddScene3dInstance(const HTuple& Scene3D, const HTuple& ObjectModel3D, const HTuple& Pose, HTuple* InstanceIndex);

// Add a camera to a 3D scene.
LIntExport void AddScene3dCamera(const HTuple& Scene3D, const HTuple& CameraParam, HTuple* CameraIndex);

// Delete a 3D scene and free all allocated memory.
LIntExport void ClearScene3d(const HTuple& Scene3D);

// Create the data structure that is needed to visualize collections of 3D objects.
LIntExport void CreateScene3d(HTuple* Scene3D);

// Get window parameters.
LIntExport void GetWindowParam(const HTuple& WindowHandle, const HTuple& Param, HTuple* Value);

// Set window parameters.
LIntExport void SetWindowParam(const HTuple& WindowHandle, const HTuple& Param, const HTuple& Value);

// Define the region output shape.
LIntExport void SetShape(const HTuple& WindowHandle, const HTuple& Shape);

// Set the color definition via RGB values.
LIntExport void SetRgb(const HTuple& WindowHandle, const HTuple& Red, const HTuple& Green, const HTuple& Blue);

// Define a color lookup table index.
LIntExport void SetPixel(const HTuple& WindowHandle, const HTuple& Pixel);

// Define an interpolation method for gray value output. 
LIntExport void SetPartStyle(const HTuple& WindowHandle, const HTuple& Style);

// Modify the displayed image part.
LIntExport void SetPart(const HTuple& WindowHandle, const HTuple& Row1, const HTuple& Column1, const HTuple& Row2, const HTuple& Column2);

// Define the gray value output mode.
LIntExport void SetPaint(const HTuple& WindowHandle, const HTuple& Mode);

// Define the line width for region contour output.
LIntExport void SetLineWidth(const HTuple& WindowHandle, const HTuple& Width);

// Define a contour output pattern.
LIntExport void SetLineStyle(const HTuple& WindowHandle, const HTuple& Style);

// Define the approximation error for contour display.
LIntExport void SetLineApprox(const HTuple& WindowHandle, const HTuple& Approximation);

// Define the pixel output function.
LIntExport void SetInsert(const HTuple& WindowHandle, const HTuple& Mode);

// Define output colors (HSI-coded).
LIntExport void SetHsi(const HTuple& WindowHandle, const HTuple& Hue, const HTuple& Saturation, const HTuple& Intensity);

// Define gray values for region output.
LIntExport void SetGray(const HTuple& WindowHandle, const HTuple& GrayValues);

// Define the region fill mode.
LIntExport void SetDraw(const HTuple& WindowHandle, const HTuple& Mode);

// Define the image matrix output clipping.
LIntExport void SetComprise(const HTuple& WindowHandle, const HTuple& Mode);

// Set multiple output colors.
LIntExport void SetColored(const HTuple& WindowHandle, const HTuple& NumberOfColors);

// Set output color.
LIntExport void SetColor(const HTuple& WindowHandle, const HTuple& Color);

// Get the current region output shape.
LIntExport void GetShape(const HTuple& WindowHandle, HTuple* DisplayShape);

// Get the current color in RGB-coding.
LIntExport void GetRgb(const HTuple& WindowHandle, HTuple* Red, HTuple* Green, HTuple* Blue);

// Get the current color lookup table index.
LIntExport void GetPixel(const HTuple& WindowHandle, HTuple* Pixel);

// Get the current interpolation mode for gray value display.
LIntExport void GetPartStyle(const HTuple& WindowHandle, HTuple* Style);

// Get the image part.
LIntExport void GetPart(const HTuple& WindowHandle, HTuple* Row1, HTuple* Column1, HTuple* Row2, HTuple* Column2);

// Get the current display mode for gray values.
LIntExport void GetPaint(const HTuple& WindowHandle, HTuple* Mode);

// Get the current line width for contour display.
LIntExport void GetLineWidth(const HTuple& WindowHandle, HTuple* Width);

// Get the current graphic mode for contours.
LIntExport void GetLineStyle(const HTuple& WindowHandle, HTuple* Style);

// Get the current approximation error for contour display.
LIntExport void GetLineApprox(const HTuple& WindowHandle, HTuple* Approximation);

// Get the current display mode.
LIntExport void GetInsert(const HTuple& WindowHandle, HTuple* Mode);

// Get the HSI coding of the current color.
LIntExport void GetHsi(const HTuple& WindowHandle, HTuple* Hue, HTuple* Saturation, HTuple* Intensity);

// Get the current region fill mode.
LIntExport void GetDraw(const HTuple& WindowHandle, HTuple* Mode);

// Get the output treatment of an image matrix.
LIntExport void GetComprise(const HTuple& WindowHandle, HTuple* Mode);

// Query the region display modes.
LIntExport void QueryShape(HTuple* DisplayShape);

// Query the gray value display modes.
LIntExport void QueryPaint(const HTuple& WindowHandle, HTuple* Mode);

// Query the possible line widths.
LIntExport void QueryLineWidth(HTuple* Min, HTuple* Max);

// Query the possible graphic modes.
LIntExport void QueryInsert(const HTuple& WindowHandle, HTuple* Mode);

// Query the displayable gray values.
LIntExport void QueryGray(const HTuple& WindowHandle, HTuple* Grayval);

// Query the number of colors for color output.
LIntExport void QueryColored(HTuple* PossibleNumberOfColors);

// Query all color names.
LIntExport void QueryAllColors(const HTuple& WindowHandle, HTuple* Colors);

// Query all color names displayable in the window.
LIntExport void QueryColor(const HTuple& WindowHandle, HTuple* Colors);

// Query the icon for region output
LIntExport void GetIcon(HObject* Icon, const HTuple& WindowHandle);

// Icon definition for region output.
LIntExport void SetIcon(const HObject& Icon, const HTuple& WindowHandle);

// Displays regions in a window.
LIntExport void DispRegion(const HObject& DispRegions, const HTuple& WindowHandle);

// Displays arbitrarily oriented rectangles.
LIntExport void DispRectangle2(const HTuple& WindowHandle, const HTuple& CenterRow, const HTuple& CenterCol, const HTuple& Phi, const HTuple& Length1, const HTuple& Length2);

// Display of rectangles aligned to the coordinate axes.
LIntExport void DispRectangle1(const HTuple& WindowHandle, const HTuple& Row1, const HTuple& Column1, const HTuple& Row2, const HTuple& Column2);

// Displays a polyline.
LIntExport void DispPolygon(const HTuple& WindowHandle, const HTuple& Row, const HTuple& Column);

// Draws lines in a window.
LIntExport void DispLine(const HTuple& WindowHandle, const HTuple& Row1, const HTuple& Column1, const HTuple& Row2, const HTuple& Column2);

// Displays crosses in a window.
LIntExport void DispCross(const HTuple& WindowHandle, const HTuple& Row, const HTuple& Column, const HTuple& Size, const HTuple& Angle);

// Displays gray value images.
LIntExport void DispImage(const HObject& Image, const HTuple& WindowHandle);

// Displays images with several channels.
LIntExport void DispChannel(const HObject& MultichannelImage, const HTuple& WindowHandle, const HTuple& Channel);

// Displays a color (RGB) image
LIntExport void DispColor(const HObject& ColorImage, const HTuple& WindowHandle);

// Displays ellipses.
LIntExport void DispEllipse(const HTuple& WindowHandle, const HTuple& CenterRow, const HTuple& CenterCol, const HTuple& Phi, const HTuple& Radius1, const HTuple& Radius2);

// Displays a noise distribution.
LIntExport void DispDistribution(const HTuple& WindowHandle, const HTuple& Distribution, const HTuple& Row, const HTuple& Column, const HTuple& Scale);

// Displays circles in a window.
LIntExport void DispCircle(const HTuple& WindowHandle, const HTuple& Row, const HTuple& Column, const HTuple& Radius);

// Displays arrows in a window.
LIntExport void DispArrow(const HTuple& WindowHandle, const HTuple& Row1, const HTuple& Column1, const HTuple& Row2, const HTuple& Column2, const HTuple& Size);

// Displays circular arcs in a window.
LIntExport void DispArc(const HTuple& WindowHandle, const HTuple& CenterRow, const HTuple& CenterCol, const HTuple& Angle, const HTuple& BeginRow, const HTuple& BeginCol);

// Displays image objects (image, region, XLD).
LIntExport void DispObj(const HObject& Object, const HTuple& WindowHandle);

// Set the current mouse pointer shape.
LIntExport void SetMshape(const HTuple& WindowHandle, const HTuple& Cursor);

// Query the current mouse pointer shape.
LIntExport void GetMshape(const HTuple& WindowHandle, HTuple* Cursor);

// Query all available mouse pointer shapes.
LIntExport void QueryMshape(const HTuple& WindowHandle, HTuple* ShapeNames);

// Query the subpixel mouse position.
LIntExport void GetMpositionSubPix(const HTuple& WindowHandle, HTuple* Row, HTuple* Column, HTuple* Button);

// Query the mouse position.
LIntExport void GetMposition(const HTuple& WindowHandle, HTuple* Row, HTuple* Column, HTuple* Button);

// Wait until a mouse button is pressed and get the subpixel mouse position.
LIntExport void GetMbuttonSubPix(const HTuple& WindowHandle, HTuple* Row, HTuple* Column, HTuple* Button);

// Wait until a mouse button is pressed.
LIntExport void GetMbutton(const HTuple& WindowHandle, HTuple* Row, HTuple* Column, HTuple* Button);

// Write look-up-table (lut) as file.
LIntExport void WriteLut(const HTuple& WindowHandle, const HTuple& FileName);

// Graphical view of the look-up-table (lut).
LIntExport void DispLut(const HTuple& WindowHandle, const HTuple& Row, const HTuple& Column, const HTuple& Scale);

// Query all available look-up-tables (lut).
LIntExport void QueryLut(const HTuple& WindowHandle, HTuple* LookUpTable);

// Manipulate look-up-table (lut) interactively.
LIntExport void DrawLut(const HTuple& WindowHandle);

// Get modification parameters of look-up-table (lut).
LIntExport void GetLutStyle(const HTuple& WindowHandle, HTuple* Hue, HTuple* Saturation, HTuple* Intensity);

// Changing the look-up-table (lut).
LIntExport void SetLutStyle(const HTuple& WindowHandle, const HTuple& Hue, const HTuple& Saturation, const HTuple& Intensity);

// Get current look-up-table (lut).
LIntExport void GetLut(const HTuple& WindowHandle, HTuple* LookUpTable);

// Set "`look-up-table"' (lut).
LIntExport void SetLut(const HTuple& WindowHandle, const HTuple& LookUpTable);

// Get mode of fixing of current look-up-table (lut).
LIntExport void GetFix(const HTuple& WindowHandle, HTuple* Mode);

// Set fixing of "`look-up-table"' (lut)
LIntExport void SetFix(const HTuple& WindowHandle, const HTuple& Mode);

// Get fixing of "`look-up-table"' (lut) for "`real color images"'
LIntExport void GetFixedLut(const HTuple& WindowHandle, HTuple* Mode);

// Fix "`look-up-table"' (lut) for "`real color images"'.
LIntExport void SetFixedLut(const HTuple& WindowHandle, const HTuple& Mode);

// Plot a function using gnuplot.
LIntExport void GnuplotPlotFunct1d(const HTuple& GnuplotFileID, const HTuple& Function);

// Plot control values using gnuplot.
LIntExport void GnuplotPlotCtrl(const HTuple& GnuplotFileID, const HTuple& Values);

// Visualize images using gnuplot.
LIntExport void GnuplotPlotImage(const HObject& Image, const HTuple& GnuplotFileID, const HTuple& SamplesX, const HTuple& SamplesY, const HTuple& ViewRotX, const HTuple& ViewRotZ, const HTuple& Hidden3D);

// Close all open gnuplot files or terminate an active gnuplot sub-process.
LIntExport void GnuplotClose(const HTuple& GnuplotFileID);

// Open a gnuplot file for visualization of images and control values.
LIntExport void GnuplotOpenFile(const HTuple& FileName, HTuple* GnuplotFileID);

// Open a pipe to a gnuplot process for visualization of images and control values.
LIntExport void GnuplotOpenPipe(HTuple* GnuplotFileID);

// Create a text object which can be moved interactively.
LIntExport void CreateDrawingObjectText(const HTuple& Row, const HTuple& Column, const HTuple& String, HTuple* DrawID);

// Return the iconic object of a drawing object.
LIntExport void GetDrawingObjectIconic(HObject* Object, const HTuple& DrawID);

// Delete drawing object.
LIntExport void ClearDrawingObject(const HTuple& DrawID);

// Set the parameters of a drawing object.
LIntExport void SetDrawingObjectParams(const HTuple& DrawID, const HTuple& ParamNames, const HTuple& ParamValues);

// Get the parameters of a drawing object.
LIntExport void GetDrawingObjectParams(const HTuple& DrawID, const HTuple& ParamNames, HTuple* ParamValues);

// Set the contour of an interactive draw XLD.
LIntExport void SetDrawingObjectXld(const HObject& Contour, const HTuple& DrawID);

// Create a XLD contour which can be modified interactively.
LIntExport void CreateDrawingObjectXld(const HTuple& Row, const HTuple& Column, HTuple* DrawID);

// Create a circle sector which can be modified interactively.
LIntExport void CreateDrawingObjectCircleSector(const HTuple& Row, const HTuple& Column, const HTuple& Radius, const HTuple& StartAngle, const HTuple& EndAngle, HTuple* DrawID);

// Create an elliptic sector which can be modified interactively.
LIntExport void CreateDrawingObjectEllipseSector(const HTuple& Row, const HTuple& Column, const HTuple& Phi, const HTuple& Radius1, const HTuple& Radius2, const HTuple& StartAngle, const HTuple& EndAngle, HTuple* DrawID);

// Create a line which can be modified interactively.
LIntExport void CreateDrawingObjectLine(const HTuple& Row1, const HTuple& Column1, const HTuple& Row2, const HTuple& Column2, HTuple* DrawID);

// Create a circle which can be modified interactively.
LIntExport void CreateDrawingObjectCircle(const HTuple& Row, const HTuple& Column, const HTuple& Radius, HTuple* DrawID);

// Create an ellipse which can be modified interactively.
LIntExport void CreateDrawingObjectEllipse(const HTuple& Row, const HTuple& Column, const HTuple& Phi, const HTuple& Radius1, const HTuple& Radius2, HTuple* DrawID);

// Create a rectangle of any orientation which can be modified interactively.
LIntExport void CreateDrawingObjectRectangle2(const HTuple& Row, const HTuple& Column, const HTuple& Phi, const HTuple& Length1, const HTuple& Length2, HTuple* DrawID);

// Create a rectangle parallel to the coordinate axis which can be modified interactively.
LIntExport void CreateDrawingObjectRectangle1(const HTuple& Row1, const HTuple& Column1, const HTuple& Row2, const HTuple& Column2, HTuple* DrawID);

// Interactive movement of a region with restriction of positions.
LIntExport void DragRegion3(const HObject& SourceRegion, const HObject& MaskRegion, HObject* DestinationRegion, const HTuple& WindowHandle, const HTuple& Row, const HTuple& Column);

// Interactive movement of a region with fixpoint specification.
LIntExport void DragRegion2(const HObject& SourceRegion, HObject* DestinationRegion, const HTuple& WindowHandle, const HTuple& Row, const HTuple& Column);

// Interactive moving of a region.
LIntExport void DragRegion1(const HObject& SourceRegion, HObject* DestinationRegion, const HTuple& WindowHandle);

// Interactive modification of a NURBS curve using interpolation.
LIntExport void DrawNurbsInterpMod(HObject* ContOut, const HTuple& WindowHandle, const HTuple& Rotate, const HTuple& Move, const HTuple& Scale, const HTuple& KeepRatio, const HTuple& Edit, const HTuple& Degree, const HTuple& RowsIn, const HTuple& ColsIn, const HTuple& TangentsIn, HTuple* ControlRows, HTuple* ControlCols, HTuple* Knots, HTuple* Rows, HTuple* Cols, HTuple* Tangents);

// Interactive drawing of a NURBS curve using interpolation.
LIntExport void DrawNurbsInterp(HObject* ContOut, const HTuple& WindowHandle, const HTuple& Rotate, const HTuple& Move, const HTuple& Scale, const HTuple& KeepRatio, const HTuple& Degree, HTuple* ControlRows, HTuple* ControlCols, HTuple* Knots, HTuple* Rows, HTuple* Cols, HTuple* Tangents);

// Interactive modification of a NURBS curve.
LIntExport void DrawNurbsMod(HObject* ContOut, const HTuple& WindowHandle, const HTuple& Rotate, const HTuple& Move, const HTuple& Scale, const HTuple& KeepRatio, const HTuple& Edit, const HTuple& Degree, const HTuple& RowsIn, const HTuple& ColsIn, const HTuple& WeightsIn, HTuple* Rows, HTuple* Cols, HTuple* Weights);

// Interactive drawing of a NURBS curve.
LIntExport void DrawNurbs(HObject* ContOut, const HTuple& WindowHandle, const HTuple& Rotate, const HTuple& Move, const HTuple& Scale, const HTuple& KeepRatio, const HTuple& Degree, HTuple* Rows, HTuple* Cols, HTuple* Weights);

// Interactive modification of a contour.
LIntExport void DrawXldMod(const HObject& ContIn, HObject* ContOut, const HTuple& WindowHandle, const HTuple& Rotate, const HTuple& Move, const HTuple& Scale, const HTuple& KeepRatio, const HTuple& Edit);

// Interactive drawing of a contour.
LIntExport void DrawXld(HObject* ContOut, const HTuple& WindowHandle, const HTuple& Rotate, const HTuple& Move, const HTuple& Scale, const HTuple& KeepRatio);

// Interactive drawing of any orientated rectangle.
LIntExport void DrawRectangle2Mod(const HTuple& WindowHandle, const HTuple& RowIn, const HTuple& ColumnIn, const HTuple& PhiIn, const HTuple& Length1In, const HTuple& Length2In, HTuple* Row, HTuple* Column, HTuple* Phi, HTuple* Length1, HTuple* Length2);

// Interactive drawing of any orientated rectangle.
LIntExport void DrawRectangle2(const HTuple& WindowHandle, HTuple* Row, HTuple* Column, HTuple* Phi, HTuple* Length1, HTuple* Length2);

// Draw a rectangle parallel to the coordinate axis.
LIntExport void DrawRectangle1Mod(const HTuple& WindowHandle, const HTuple& Row1In, const HTuple& Column1In, const HTuple& Row2In, const HTuple& Column2In, HTuple* Row1, HTuple* Column1, HTuple* Row2, HTuple* Column2);

// Draw a rectangle parallel to the coordinate axis.
LIntExport void DrawRectangle1(const HTuple& WindowHandle, HTuple* Row1, HTuple* Column1, HTuple* Row2, HTuple* Column2);

// Draw a point.
LIntExport void DrawPointMod(const HTuple& WindowHandle, const HTuple& RowIn, const HTuple& ColumnIn, HTuple* Row, HTuple* Column);

// Draw a point.
LIntExport void DrawPoint(const HTuple& WindowHandle, HTuple* Row, HTuple* Column);

// Draw a line.
LIntExport void DrawLineMod(const HTuple& WindowHandle, const HTuple& Row1In, const HTuple& Column1In, const HTuple& Row2In, const HTuple& Column2In, HTuple* Row1, HTuple* Column1, HTuple* Row2, HTuple* Column2);

// Draw a line.
LIntExport void DrawLine(const HTuple& WindowHandle, HTuple* Row1, HTuple* Column1, HTuple* Row2, HTuple* Column2);

// Interactive drawing of an ellipse.
LIntExport void DrawEllipseMod(const HTuple& WindowHandle, const HTuple& RowIn, const HTuple& ColumnIn, const HTuple& PhiIn, const HTuple& Radius1In, const HTuple& Radius2In, HTuple* Row, HTuple* Column, HTuple* Phi, HTuple* Radius1, HTuple* Radius2);

// Interactive drawing of an ellipse.
LIntExport void DrawEllipse(const HTuple& WindowHandle, HTuple* Row, HTuple* Column, HTuple* Phi, HTuple* Radius1, HTuple* Radius2);

// Interactive drawing of a circle.
LIntExport void DrawCircleMod(const HTuple& WindowHandle, const HTuple& RowIn, const HTuple& ColumnIn, const HTuple& RadiusIn, HTuple* Row, HTuple* Column, HTuple* Radius);

// Interactive drawing of a circle.
LIntExport void DrawCircle(const HTuple& WindowHandle, HTuple* Row, HTuple* Column, HTuple* Radius);

// Interactive drawing of a closed region.
LIntExport void DrawRegion(HObject* Region, const HTuple& WindowHandle);

// Interactive drawing of a polygon row.
LIntExport void DrawPolygon(HObject* PolygonRegion, const HTuple& WindowHandle);

// Calculate the projection of a point onto a line.
LIntExport void ProjectionPl(const HTuple& Row, const HTuple& Column, const HTuple& Row1, const HTuple& Column1, const HTuple& Row2, const HTuple& Column2, HTuple* RowProj, HTuple* ColProj);

// Calculate a point of an ellipse corresponding to a specific angle.
LIntExport void GetPointsEllipse(const HTuple& Angle, const HTuple& Row, const HTuple& Column, const HTuple& Phi, const HTuple& Radius1, const HTuple& Radius2, HTuple* RowPoint, HTuple* ColPoint);

// Calculate the intersection point of two lines.
LIntExport void IntersectionLl(const HTuple& RowA1, const HTuple& ColumnA1, const HTuple& RowA2, const HTuple& ColumnA2, const HTuple& RowB1, const HTuple& ColumnB1, const HTuple& RowB2, const HTuple& ColumnB2, HTuple* Row, HTuple* Column, HTuple* IsParallel);

// Calculate the intersection points of two XLD contours 
LIntExport void IntersectionContoursXld(const HObject& Contour1, const HObject& Contour2, const HTuple& IntersectionType, HTuple* Row, HTuple* Column, HTuple* IsOverlapping);

// Calculate the intersection points of a circle or circular arc and an XLD contour 
LIntExport void IntersectionCircleContourXld(const HObject& Contour, const HTuple& CircleRow, const HTuple& CircleColumn, const HTuple& CircleRadius, const HTuple& CircleStartPhi, const HTuple& CircleEndPhi, const HTuple& CirclePointOrder, HTuple* Row, HTuple* Column);

// Calculate the intersection points of two circles or circular arcs 
LIntExport void IntersectionCircles(const HTuple& Circle1Row, const HTuple& Circle1Column, const HTuple& Circle1Radius, const HTuple& Circle1StartPhi, const HTuple& Circle1EndPhi, const HTuple& Circle1PointOrder, const HTuple& Circle2Row, const HTuple& Circle2Column, const HTuple& Circle2Radius, const HTuple& Circle2StartPhi, const HTuple& Circle2EndPhi, const HTuple& Circle2PointOrder, HTuple* Row, HTuple* Column, HTuple* IsOverlapping);

// Calculate the intersection points of a line and an XLD contour 
LIntExport void IntersectionLineContourXld(const HObject& Contour, const HTuple& LineRow1, const HTuple& LineColumn1, const HTuple& LineRow2, const HTuple& LineColumn2, HTuple* Row, HTuple* Column, HTuple* IsOverlapping);

// Calculate the intersection points of a line and a circle or circular arc 
LIntExport void IntersectionLineCircle(const HTuple& LineRow1, const HTuple& LineColumn1, const HTuple& LineRow2, const HTuple& LineColumn2, const HTuple& CircleRow, const HTuple& CircleColumn, const HTuple& CircleRadius, const HTuple& CircleStartPhi, const HTuple& CircleEndPhi, const HTuple& CirclePointOrder, HTuple* Row, HTuple* Column);

// Calculate the intersection point of two lines 
LIntExport void IntersectionLines(const HTuple& Line1Row1, const HTuple& Line1Column1, const HTuple& Line1Row2, const HTuple& Line1Column2, const HTuple& Line2Row1, const HTuple& Line2Column1, const HTuple& Line2Row2, const HTuple& Line2Column2, HTuple* Row, HTuple* Column, HTuple* IsOverlapping);

// Calculate the intersection points of a segment and an XLD contour 
LIntExport void IntersectionSegmentContourXld(const HObject& Contour, const HTuple& SegmentRow1, const HTuple& SegmentColumn1, const HTuple& SegmentRow2, const HTuple& SegmentColumn2, HTuple* Row, HTuple* Column, HTuple* IsOverlapping);

// Calculate the intersection points of a segment and a circle or circular arc 
LIntExport void IntersectionSegmentCircle(const HTuple& SegmentRow1, const HTuple& SegmentColumn1, const HTuple& SegmentRow2, const HTuple& SegmentColumn2, const HTuple& CircleRow, const HTuple& CircleColumn, const HTuple& CircleRadius, const HTuple& CircleStartPhi, const HTuple& CircleEndPhi, const HTuple& CirclePointOrder, HTuple* Row, HTuple* Column);

// Calculate the intersection point of a segment and a line 
LIntExport void IntersectionSegmentLine(const HTuple& SegmentRow1, const HTuple& SegmentColumn1, const HTuple& SegmentRow2, const HTuple& SegmentColumn2, const HTuple& LineRow1, const HTuple& LineColumn1, const HTuple& LineRow2, const HTuple& LineColumn2, HTuple* Row, HTuple* Column, HTuple* IsOverlapping);

// Calculate the intersection point of two line segments 
LIntExport void IntersectionSegments(const HTuple& Segment1Row1, const HTuple& Segment1Column1, const HTuple& Segment1Row2, const HTuple& Segment1Column2, const HTuple& Segment2Row1, const HTuple& Segment2Column1, const HTuple& Segment2Row2, const HTuple& Segment2Column2, HTuple* Row, HTuple* Column, HTuple* IsOverlapping);

// Clear a XLD distance transform.
LIntExport void ClearDistanceTransformXld(const HTuple& DistanceTransformID);

// Determine the pointwise distance of two contours using an XLD distance transform.
LIntExport void ApplyDistanceTransformXld(const HObject& Contour, HObject* ContourOut, const HTuple& DistanceTransformID);

// Read an XLD distance transform from a file.
LIntExport void ReadDistanceTransformXld(const HTuple& FileName, HTuple* DistanceTransformID);

// Deserialize an XLD distance transform.
LIntExport void DeserializeDistanceTransformXld(const HTuple& SerializedItemHandle, HTuple* DistanceTransformID);

// Serialize an XLD distance transform.
LIntExport void SerializeDistanceTransformXld(const HTuple& DistanceTransformID, HTuple* SerializedItemHandle);

// Write an XLD distance transform into a file.
LIntExport void WriteDistanceTransformXld(const HTuple& DistanceTransformID, const HTuple& FileName);

// Set new parameters for an XLD distance transform.
LIntExport void SetDistanceTransformXldParam(const HTuple& DistanceTransformID, const HTuple& GenParamName, const HTuple& GenParamValue);

// Get the parameters used to build an XLD distance transform.
LIntExport void GetDistanceTransformXldParam(const HTuple& DistanceTransformID, const HTuple& GenParamName, HTuple* GenParamValue);

// Get the reference contour used to build the XLD distance transform.
LIntExport void GetDistanceTransformXldContour(HObject* Contour, const HTuple& DistanceTransformID);

// Create the XLD distance transform.
LIntExport void CreateDistanceTransformXld(const HObject& Contour, const HTuple& Mode, const HTuple& MaxDistance, HTuple* DistanceTransformID);

// Calculate the pointwise distance from one contour to another.
LIntExport void DistanceContoursXld(const HObject& ContourFrom, const HObject& ContourTo, HObject* ContourOut, const HTuple& Mode);

// Calculate the minimum distance between two contours.
LIntExport void DistanceCcMin(const HObject& Contour1, const HObject& Contour2, const HTuple& Mode, HTuple* DistanceMin);

// Calculate the distance between two contours.
LIntExport void DistanceCc(const HObject& Contour1, const HObject& Contour2, const HTuple& Mode, HTuple* DistanceMin, HTuple* DistanceMax);

// Calculate the distance between a line segment and one contour.
LIntExport void DistanceSc(const HObject& Contour, const HTuple& Row1, const HTuple& Column1, const HTuple& Row2, const HTuple& Column2, HTuple* DistanceMin, HTuple* DistanceMax);

// Calculate the distance between a line and one contour.
LIntExport void DistanceLc(const HObject& Contour, const HTuple& Row1, const HTuple& Column1, const HTuple& Row2, const HTuple& Column2, HTuple* DistanceMin, HTuple* DistanceMax);

// Calculate the distance between a point and one contour.
LIntExport void DistancePc(const HObject& Contour, const HTuple& Row, const HTuple& Column, HTuple* DistanceMin, HTuple* DistanceMax);

// Calculate the distance between a line segment and one region.
LIntExport void DistanceSr(const HObject& Region, const HTuple& Row1, const HTuple& Column1, const HTuple& Row2, const HTuple& Column2, HTuple* DistanceMin, HTuple* DistanceMax);

// Calculate the distance between a line and a region.
LIntExport void DistanceLr(const HObject& Region, const HTuple& Row1, const HTuple& Column1, const HTuple& Row2, const HTuple& Column2, HTuple* DistanceMin, HTuple* DistanceMax);

// Calculate the distance between a point and a region.
LIntExport void DistancePr(const HObject& Region, const HTuple& Row, const HTuple& Column, HTuple* DistanceMin, HTuple* DistanceMax);

// Calculate the angle between one line and the horizontal axis.
LIntExport void AngleLx(const HTuple& Row1, const HTuple& Column1, const HTuple& Row2, const HTuple& Column2, HTuple* Angle);

// Calculate the angle between two lines.
LIntExport void AngleLl(const HTuple& RowA1, const HTuple& ColumnA1, const HTuple& RowA2, const HTuple& ColumnA2, const HTuple& RowB1, const HTuple& ColumnB1, const HTuple& RowB2, const HTuple& ColumnB2, HTuple* Angle);

// Calculate the distances between a line segment and a line.
LIntExport void DistanceSl(const HTuple& RowA1, const HTuple& ColumnA1, const HTuple& RowA2, const HTuple& ColumnA2, const HTuple& RowB1, const HTuple& ColumnB1, const HTuple& RowB2, const HTuple& ColumnB2, HTuple* DistanceMin, HTuple* DistanceMax);

// Calculate the distances between two line segments.
LIntExport void DistanceSs(const HTuple& RowA1, const HTuple& ColumnA1, const HTuple& RowA2, const HTuple& ColumnA2, const HTuple& RowB1, const HTuple& ColumnB1, const HTuple& RowB2, const HTuple& ColumnB2, HTuple* DistanceMin, HTuple* DistanceMax);

// Calculate the distances between a point and a line segment.
LIntExport void DistancePs(const HTuple& Row, const HTuple& Column, const HTuple& Row1, const HTuple& Column1, const HTuple& Row2, const HTuple& Column2, HTuple* DistanceMin, HTuple* DistanceMax);

// Calculate the distance between one point and one line.
LIntExport void DistancePl(const HTuple& Row, const HTuple& Column, const HTuple& Row1, const HTuple& Column1, const HTuple& Row2, const HTuple& Column2, HTuple* Distance);

// Calculate the distance between two points.
LIntExport void DistancePp(const HTuple& Row1, const HTuple& Column1, const HTuple& Row2, const HTuple& Column2, HTuple* Distance);

// Compose two functions.
LIntExport void ComposeFunct1d(const HTuple& Function1, const HTuple& Function2, const HTuple& Border, HTuple* ComposedFunction);

// Calculate the inverse of a function.
LIntExport void InvertFunct1d(const HTuple& Function, HTuple* InverseFunction);

// Calculate the derivatives of a function.
LIntExport void DerivateFunct1d(const HTuple& Function, const HTuple& Mode, HTuple* Derivative);

// Calculate the local minimum and maximum points of a function.
LIntExport void LocalMinMaxFunct1d(const HTuple& Function, const HTuple& Mode, const HTuple& Interpolation, HTuple* Min, HTuple* Max);

// Calculate the zero crossings of a function.
LIntExport void ZeroCrossingsFunct1d(const HTuple& Function, HTuple* ZeroCrossings);

// Multiplication and addition of the y values.
LIntExport void ScaleYFunct1d(const HTuple& Function, const HTuple& Mult, const HTuple& Add, HTuple* FunctionScaled);

// Negation of the y values.
LIntExport void NegateFunct1d(const HTuple& Function, HTuple* FunctionInverted);

// Absolute value of the y values.
LIntExport void AbsFunct1d(const HTuple& Function, HTuple* FunctionAbsolute);

// Return the value of a function at an arbitrary position.
LIntExport void GetYValueFunct1d(const HTuple& Function, const HTuple& X, const HTuple& Border, HTuple* Y);

// Access a function value using the index of the control points.
LIntExport void GetPairFunct1d(const HTuple& Function, const HTuple& Index, HTuple* X, HTuple* Y);

// Number of control points of the function.
LIntExport void NumPointsFunct1d(const HTuple& Function, HTuple* Length);

// Smallest and largest y value of the function.
LIntExport void YRangeFunct1d(const HTuple& Function, HTuple* YMin, HTuple* YMax);

// Smallest and largest x value of the function.
LIntExport void XRangeFunct1d(const HTuple& Function, HTuple* XMin, HTuple* XMax);

// Access to the x/y values of a function.
LIntExport void Funct1dToPairs(const HTuple& Function, HTuple* XValues, HTuple* YValues);

// Sample a function equidistantly in an interval.
LIntExport void SampleFunct1d(const HTuple& Function, const HTuple& XMin, const HTuple& XMax, const HTuple& XDist, const HTuple& Border, HTuple* SampledFunction);

// Transform a function using given transformation parameters.
LIntExport void TransformFunct1d(const HTuple& Function, const HTuple& Params, HTuple* TransformedFunction);

// Calculate transformation parameters between two functions.
LIntExport void MatchFunct1dTrans(const HTuple& Function1, const HTuple& Function2, const HTuple& Border, const HTuple& ParamsConst, const HTuple& UseParams, HTuple* Params, HTuple* ChiSquare, HTuple* Covar);

// Compute the distance of two functions.
LIntExport void DistanceFunct1d(const HTuple& Function1, const HTuple& Function2, const HTuple& Mode, const HTuple& Sigma, HTuple* Distance);

// Smooth an equidistant 1D function with a Gaussian function.
LIntExport void SmoothFunct1dGauss(const HTuple& Function, const HTuple& Sigma, HTuple* SmoothedFunction);

// Compute the positive and negative areas of a function.
LIntExport void IntegrateFunct1d(const HTuple& Function, HTuple* Positive, HTuple* Negative);

// Read a function from a file.
LIntExport void ReadFunct1d(const HTuple& FileName, HTuple* Function);

// Write a function to a file.
LIntExport void WriteFunct1d(const HTuple& Function, const HTuple& FileName);

// Create a function from a sequence of y-values.
LIntExport void CreateFunct1dArray(const HTuple& YValues, HTuple* Function);

// Create a function from a set of (x,y) pairs.
LIntExport void CreateFunct1dPairs(const HTuple& XValues, const HTuple& YValues, HTuple* Function);

// Smooth an equidistant 1D function by averaging its values.
LIntExport void SmoothFunct1dMean(const HTuple& Function, const HTuple& SmoothSize, const HTuple& Iterations, HTuple* SmoothedFunction);

// Similarity of two contours.
LIntExport void MatchFourierCoeff(const HTuple& RealCoef1, const HTuple& ImaginaryCoef1, const HTuple& RealCoef2, const HTuple& ImaginaryCoef2, const HTuple& MaxCoef, const HTuple& Damping, HTuple* Distance);

// One dimensional Fourier synthesis (inverse Fourier transform).
LIntExport void Fourier1dimInv(const HTuple& RealCoef, const HTuple& ImaginaryCoef, const HTuple& MaxCoef, HTuple* Rows, HTuple* Columns);

// Normalizing of the Fourier coefficients with respect to the displacment of the starting point. 
LIntExport void AbsInvarFourierCoeff(const HTuple& RealInvar, const HTuple& ImaginaryInvar, const HTuple& CoefP, const HTuple& CoefQ, const HTuple& AZInvar, HTuple* RealAbsInvar, HTuple* ImaginaryAbsInvar);

// Normalize the Fourier coefficients.
LIntExport void InvarFourierCoeff(const HTuple& RealCoef, const HTuple& ImaginaryCoef, const HTuple& NormPar, const HTuple& InvarType, HTuple* RealInvar, HTuple* ImaginaryInvar);

// Calculate the Fourier coefficients of a parameterized contour.
LIntExport void Fourier1dim(const HTuple& Rows, const HTuple& Columns, const HTuple& ParContour, const HTuple& MaxCoef, HTuple* RealCoef, HTuple* ImaginaryCoef);

// Parameterize the passed contour.
LIntExport void PrepContourFourier(const HTuple& Rows, const HTuple& Columns, const HTuple& TransMode, HTuple* ParContour);

// Transformation of the origin into the centre of gravity.
LIntExport void MoveContourOrig(const HTuple& Rows, const HTuple& Columns, HTuple* RowsMoved, HTuple* ColumnsMoved);

// Filter an image using a Laws texture filter.
LIntExport void TextureLaws(const HObject& Image, HObject* ImageTexture, const HTuple& FilterTypes, const HTuple& Shift, const HTuple& FilterSize);

// Calculate the standard deviation of gray values within rectangular windows.
LIntExport void DeviationImage(const HObject& Image, HObject* ImageDeviation, const HTuple& Width, const HTuple& Height);

// Calculate the entropy of gray values within a rectangular window.
LIntExport void EntropyImage(const HObject& Image, HObject* ImageEntropy, const HTuple& Width, const HTuple& Height);

// Perform an isotropic diffusion of an image.
LIntExport void IsotropicDiffusion(const HObject& Image, HObject* SmoothedImage, const HTuple& Sigma, const HTuple& Iterations);

// Perform an anisotropic diffusion of an image.
LIntExport void AnisotropicDiffusion(const HObject& Image, HObject* ImageAniso, const HTuple& Mode, const HTuple& Contrast, const HTuple& Theta, const HTuple& Iterations);

// Smooth an image using various filters.
LIntExport void SmoothImage(const HObject& Image, HObject* ImageSmooth, const HTuple& Filter, const HTuple& Alpha);

// Non-linear smoothing with the sigma filter.
LIntExport void SigmaImage(const HObject& Image, HObject* ImageSigma, const HTuple& MaskHeight, const HTuple& MaskWidth, const HTuple& Sigma);

// Calculate the average of maximum and minimum inside any mask.
LIntExport void MidrangeImage(const HObject& Image, const HObject& Mask, HObject* ImageMidrange, const HTuple& Margin);

// Smooth an image with an arbitrary rank mask.
LIntExport void TrimmedMean(const HObject& Image, const HObject& Mask, HObject* ImageTMean, const HTuple& Number, const HTuple& Margin);

// Separated median filtering with rectangle masks.
LIntExport void MedianSeparate(const HObject& Image, HObject* ImageSMedian, const HTuple& MaskWidth, const HTuple& MaskHeight, const HTuple& Margin);

// Compute a median filter with rectangular masks.
LIntExport void MedianRect(const HObject& Image, HObject* ImageMedian, const HTuple& MaskWidth, const HTuple& MaskHeight);

// Compute a median filter with various masks.
LIntExport void MedianImage(const HObject& Image, HObject* ImageMedian, const HTuple& MaskType, const HTuple& Radius, const HTuple& Margin);

// Weighted median filtering with different rank masks.
LIntExport void MedianWeighted(const HObject& Image, HObject* ImageWMedian, const HTuple& MaskType, const HTuple& MaskSize);

// Compute a rank filter with rectangular masks.
LIntExport void RankRect(const HObject& Image, HObject* ImageRank, const HTuple& MaskWidth, const HTuple& MaskHeight, const HTuple& Rank);

// Compute a rank filter with arbitrary masks.
LIntExport void RankImage(const HObject& Image, const HObject& Mask, HObject* ImageRank, const HTuple& Rank, const HTuple& Margin);

// Opening, Median and Closing with circle or rectangle mask.
LIntExport void DualRank(const HObject& Image, HObject* ImageRank, const HTuple& MaskType, const HTuple& Radius, const HTuple& ModePercent, const HTuple& Margin);

// Smooth by averaging.
LIntExport void MeanImage(const HObject& Image, HObject* ImageMean, const HTuple& MaskWidth, const HTuple& MaskHeight);

// Information on smoothing filter smooth_image.
LIntExport void InfoSmooth(const HTuple& Filter, const HTuple& Alpha, HTuple* Size, HTuple* Coeffs);

// Smooth an image using the binomial filter.
LIntExport void BinomialFilter(const HObject& Image, HObject* ImageBinomial, const HTuple& MaskWidth, const HTuple& MaskHeight);

// Smooth an image using discrete Gaussian functions.
LIntExport void GaussImage(const HObject& Image, HObject* ImageGauss, const HTuple& Size);

// Smooth using discrete gauss functions.
LIntExport void GaussFilter(const HObject& Image, HObject* ImageGauss, const HTuple& Size);

// Smooth an image in the spatial domain to suppress noise.
LIntExport void EliminateMinMax(const HObject& Image, HObject* FilteredImage, const HTuple& MaskWidth, const HTuple& MaskHeight, const HTuple& Gap, const HTuple& Mode);

// Smooth an image by edge-preserving anisotropic diffusion.
LIntExport void AnisotropeDiff(const HObject& Image, HObject* ImageAniso, const HTuple& Percent, const HTuple& Mode, const HTuple& Iteration, const HTuple& NeighborhoodType);

// Interpolate 2 video half images.
LIntExport void FillInterlace(const HObject& ImageCamera, HObject* ImageFilled, const HTuple& Mode);

// Return gray values with given rank from multiple channels.
LIntExport void RankN(const HObject& Image, HObject* RankImage, const HTuple& RankIndex);

// Average gray values over several channels.
LIntExport void MeanN(const HObject& Image, HObject* ImageMean);

// Replace values outside of thresholds with average value.
LIntExport void EliminateSp(const HObject& Image, HObject* ImageFillSP, const HTuple& MaskWidth, const HTuple& MaskHeight, const HTuple& MinThresh, const HTuple& MaxThresh);

// Suppress salt and pepper noise.
LIntExport void MeanSp(const HObject& Image, HObject* ImageSPMean, const HTuple& MaskWidth, const HTuple& MaskHeight, const HTuple& MinThresh, const HTuple& MaxThresh);

// Find corners using the Sojka operator.
LIntExport void PointsSojka(const HObject& Image, const HTuple& MaskSize, const HTuple& SigmaW, const HTuple& SigmaD, const HTuple& MinGrad, const HTuple& MinApparentness, const HTuple& MinAngle, const HTuple& Subpix, HTuple* Row, HTuple* Column);

// Enhance circular dots in an image.
LIntExport void DotsImage(const HObject& Image, HObject* DotImage, const HTuple& Diameter, const HTuple& FilterType, const HTuple& PixelShift);

// Subpixel precise detection of local minima in an image.
LIntExport void LocalMinSubPix(const HObject& Image, const HTuple& Filter, const HTuple& Sigma, const HTuple& Threshold, HTuple* Row, HTuple* Column);

// Subpixel precise detection of local maxima in an image.
LIntExport void LocalMaxSubPix(const HObject& Image, const HTuple& Filter, const HTuple& Sigma, const HTuple& Threshold, HTuple* Row, HTuple* Column);

// Subpixel precise detection of saddle points in an image.
LIntExport void SaddlePointsSubPix(const HObject& Image, const HTuple& Filter, const HTuple& Sigma, const HTuple& Threshold, HTuple* Row, HTuple* Column);

// Subpixel precise detection of critical points in an image.
LIntExport void CriticalPointsSubPix(const HObject& Image, const HTuple& Filter, const HTuple& Sigma, const HTuple& Threshold, HTuple* RowMin, HTuple* ColumnMin, HTuple* RowMax, HTuple* ColumnMax, HTuple* RowSaddle, HTuple* ColumnSaddle);

// Detect points of interest using the Harris operator.
LIntExport void PointsHarris(const HObject& Image, const HTuple& SigmaGrad, const HTuple& SigmaSmooth, const HTuple& Alpha, const HTuple& Threshold, HTuple* Row, HTuple* Column);

// Detect points of interest using the binomial approximation of the Harris operator.
LIntExport void PointsHarrisBinomial(const HObject& Image, const HTuple& MaskSizeGrad, const HTuple& MaskSizeSmooth, const HTuple& Alpha, const HTuple& Threshold, const HTuple& Subpix, HTuple* Row, HTuple* Column);

// Detect points of interest using the Lepetit operator.
LIntExport void PointsLepetit(const HObject& Image, const HTuple& Radius, const HTuple& CheckNeighbor, const HTuple& MinCheckNeighborDiff, const HTuple& MinScore, const HTuple& Subpix, HTuple* Row, HTuple* Column);

// Detect points of interest using the Foerstner operator.
LIntExport void PointsFoerstner(const HObject& Image, const HTuple& SigmaGrad, const HTuple& SigmaInt, const HTuple& SigmaPoints, const HTuple& ThreshInhom, const HTuple& ThreshShape, const HTuple& Smoothing, const HTuple& EliminateDoublets, HTuple* RowJunctions, HTuple* ColumnJunctions, HTuple* CoRRJunctions, HTuple* CoRCJunctions, HTuple* CoCCJunctions, HTuple* RowArea, HTuple* ColumnArea, HTuple* CoRRArea, HTuple* CoRCArea, HTuple* CoCCArea);

// Estimate the image noise from a single image.
LIntExport void EstimateNoise(const HObject& Image, const HTuple& Method, const HTuple& Percent, HTuple* Sigma);

// Determine the noise distribution of an image.
LIntExport void NoiseDistributionMean(const HObject& ConstRegion, const HObject& Image, const HTuple& FilterSize, HTuple* Distribution);

// Add noise to an image.
LIntExport void AddNoiseWhite(const HObject& Image, HObject* ImageNoise, const HTuple& Amp);

// Add noise to an image.
LIntExport void AddNoiseDistribution(const HObject& Image, HObject* ImageNoise, const HTuple& Distribution);

// Generate a Gaussian noise distribution.
LIntExport void GaussDistribution(const HTuple& Sigma, HTuple* Distribution);

// Generate a salt-and-pepper noise distribution.
LIntExport void SpDistribution(const HTuple& PercentSalt, const HTuple& PercentPepper, HTuple* Distribution);

// Calculate standard deviation over several channels.
LIntExport void DeviationN(const HObject& Image, HObject* ImageDeviation);

// Perform an inpainting by texture propagation.
LIntExport void InpaintingTexture(const HObject& Image, const HObject& Region, HObject* InpaintedImage, const HTuple& MaskSize, const HTuple& SearchSize, const HTuple& Anisotropy, const HTuple& PostIteration, const HTuple& Smoothness);

// Perform an inpainting by coherence transport.
LIntExport void InpaintingCt(const HObject& Image, const HObject& Region, HObject* InpaintedImage, const HTuple& Epsilon, const HTuple& Kappa, const HTuple& Sigma, const HTuple& Rho, const HTuple& ChannelCoefficients);

// Perform an inpainting by smoothing of level lines.
LIntExport void InpaintingMcf(const HObject& Image, const HObject& Region, HObject* InpaintedImage, const HTuple& Sigma, const HTuple& Theta, const HTuple& Iterations);

// Perform an inpainting by coherence enhancing diffusion.
LIntExport void InpaintingCed(const HObject& Image, const HObject& Region, HObject* InpaintedImage, const HTuple& Sigma, const HTuple& Rho, const HTuple& Theta, const HTuple& Iterations);

// Perform an inpainting by anisotropic diffusion.
LIntExport void InpaintingAniso(const HObject& Image, const HObject& Region, HObject* InpaintedImage, const HTuple& Mode, const HTuple& Contrast, const HTuple& Theta, const HTuple& Iterations, const HTuple& Rho);

// Perform a harmonic interpolation on an image region.
LIntExport void HarmonicInterpolation(const HObject& Image, const HObject& Region, HObject* InpaintedImage, const HTuple& Precision);

// Expand the domain of an image and set the gray values in the expanded domain.
LIntExport void ExpandDomainGray(const HObject& InputImage, HObject* ExpandedImage, const HTuple& ExpansionRange);

// Compute the topographic primal sketch of an image.
LIntExport void TopographicSketch(const HObject& Image, HObject* Sketch);

// Compute an affine transformation of the color values of a multichannel image.
LIntExport void LinearTransColor(const HObject& Image, HObject* ImageTrans, const HTuple& TransMat);

// Compute the transformation matrix of the principal component analysis of multichannel images.
LIntExport void GenPrincipalCompTrans(const HObject& MultichannelImage, HTuple* Trans, HTuple* TransInv, HTuple* Mean, HTuple* Cov, HTuple* InfoPerComp);

// Compute the principal components of multichannel images.
LIntExport void PrincipalComp(const HObject& MultichannelImage, HObject* PCAImage, HTuple* InfoPerComp);

// Determine the fuzzy entropy of regions.
LIntExport void FuzzyEntropy(const HObject& Regions, const HObject& Image, const HTuple& Apar, const HTuple& Cpar, HTuple* Entropy);

// Calculate the fuzzy perimeter of a region.
LIntExport void FuzzyPerimeter(const HObject& Regions, const HObject& Image, const HTuple& Apar, const HTuple& Cpar, HTuple* Perimeter);

// Perform a grayvalue closing with a selected mask.
LIntExport void GrayClosingShape(const HObject& Image, HObject* ImageClosing, const HTuple& MaskHeight, const HTuple& MaskWidth, const HTuple& MaskShape);

// Perform a gray value opening with a selected mask.
LIntExport void GrayOpeningShape(const HObject& Image, HObject* ImageOpening, const HTuple& MaskHeight, const HTuple& MaskWidth, const HTuple& MaskShape);

// Determine the minimum gray value within a selected mask.
LIntExport void GrayErosionShape(const HObject& Image, HObject* ImageMin, const HTuple& MaskHeight, const HTuple& MaskWidth, const HTuple& MaskShape);

// Determine the maximum gray value within a selected mask.
LIntExport void GrayDilationShape(const HObject& Image, HObject* ImageMax, const HTuple& MaskHeight, const HTuple& MaskWidth, const HTuple& MaskShape);

// Determine the gray value range within a rectangle.
LIntExport void GrayRangeRect(const HObject& Image, HObject* ImageResult, const HTuple& MaskHeight, const HTuple& MaskWidth);

// Perform a gray value closing with a rectangular mask.
LIntExport void GrayClosingRect(const HObject& Image, HObject* ImageClosing, const HTuple& MaskHeight, const HTuple& MaskWidth);

// Perform a gray value opening with a rectangular mask.
LIntExport void GrayOpeningRect(const HObject& Image, HObject* ImageOpening, const HTuple& MaskHeight, const HTuple& MaskWidth);

// Determine the minimum gray value within a rectangle.
LIntExport void GrayErosionRect(const HObject& Image, HObject* ImageMin, const HTuple& MaskHeight, const HTuple& MaskWidth);

// Determine the maximum gray value within a rectangle.
LIntExport void GrayDilationRect(const HObject& Image, HObject* ImageMax, const HTuple& MaskHeight, const HTuple& MaskWidth);

// Thinning of gray value images.
LIntExport void GraySkeleton(const HObject& Image, HObject* GraySkeleton);

// Transform an image with a gray-value look-up-table
LIntExport void LutTrans(const HObject& Image, HObject* ImageResult, const HTuple& Lut);

// Calculate the correlation between an image and an arbitrary filter mask
LIntExport void ConvolImage(const HObject& Image, HObject* ImageResult, const HTuple& FilterMask, const HTuple& Margin);

// Convert the type of an image.
LIntExport void ConvertImageType(const HObject& Image, HObject* ImageConverted, const HTuple& NewType);

// Convert two real-valued images into a vector field image.
LIntExport void RealToVectorField(const HObject& Row, const HObject& Col, HObject* VectorField, const HTuple& Type);

// Convert a vector field image into two real-valued images.
LIntExport void VectorFieldToReal(const HObject& VectorField, HObject* Row, HObject* Col);

// Convert two real images into a complex image.
LIntExport void RealToComplex(const HObject& ImageReal, const HObject& ImageImaginary, HObject* ImageComplex);

// Convert a complex image into two real images.
LIntExport void ComplexToReal(const HObject& ImageComplex, HObject* ImageReal, HObject* ImageImaginary);

// Paint regions with their average gray value.
LIntExport void RegionToMean(const HObject& Regions, const HObject& Image, HObject* ImageMean);

// Calculate the lowest possible gray value on an arbitrary path to the image border for each point in the image.
LIntExport void GrayInside(const HObject& Image, HObject* ImageDist);

// Symmetry of gray values along a row.
LIntExport void Symmetry(const HObject& Image, HObject* ImageSymmetry, const HTuple& MaskSize, const HTuple& Direction, const HTuple& Exponent);

// Selection of gray values of a multi-channel image using an index image.
LIntExport void SelectGrayvaluesFromChannels(const HObject& MultichannelImage, const HObject& IndexImage, HObject* Selected);

// Extract depth using mutiple focus levels.
LIntExport void DepthFromFocus(const HObject& MultiFocusImage, HObject* Depth, HObject* Confidence, const HTuple& Filter, const HTuple& Selection);

// Compute the calibrated scene flow between two stereo image pairs.
LIntExport void SceneFlowCalib(const HObject& ImageRect1T1, const HObject& ImageRect2T1, const HObject& ImageRect1T2, const HObject& ImageRect2T2, const HObject& Disparity, const HTuple& SmoothingFlow, const HTuple& SmoothingDisparity, const HTuple& GenParamName, const HTuple& GenParamValue, const HTuple& CamParamRect1, const HTuple& CamParamRect2, const HTuple& RelPoseRect, HTuple* ObjectModel3D);

// Compute the uncalibrated scene flow between two stereo image pairs.
LIntExport void SceneFlowUncalib(const HObject& ImageRect1T1, const HObject& ImageRect2T1, const HObject& ImageRect1T2, const HObject& ImageRect2T2, const HObject& Disparity, HObject* OpticalFlow, HObject* DisparityChange, const HTuple& SmoothingFlow, const HTuple& SmoothingDisparity, const HTuple& GenParamName, const HTuple& GenParamValue);

// Unwarp an image using a vector field.
LIntExport void UnwarpImageVectorField(const HObject& Image, const HObject& VectorField, HObject* ImageUnwarped);

// Convolve a vector field with derivatives of the Gaussian.
LIntExport void DerivateVectorField(const HObject& VectorField, HObject* Result, const HTuple& Sigma, const HTuple& Component);

// Compute the length of the vectors of a vector field.
LIntExport void VectorFieldLength(const HObject& VectorField, HObject* Length, const HTuple& Mode);

// Compute the optical flow between two images.
LIntExport void OpticalFlowMg(const HObject& ImageT1, const HObject& ImageT2, HObject* VectorField, const HTuple& Algorithm, const HTuple& SmoothingSigma, const HTuple& IntegrationSigma, const HTuple& FlowSmoothness, const HTuple& GradientConstancy, const HTuple& MGParamName, const HTuple& MGParamValue);

// Matching a template and an image in a resolution pyramid.
LIntExport void ExhaustiveMatchMg(const HObject& Image, const HObject& ImageTemplate, HObject* ImageMatch, const HTuple& Mode, const HTuple& Level, const HTuple& Threshold);

// Preparing a pattern for template matching with rotation.
LIntExport void CreateTemplateRot(const HObject& Template, const HTuple& NumLevel, const HTuple& AngleStart, const HTuple& AngleExtend, const HTuple& AngleStep, const HTuple& Optimize, const HTuple& GrayValues, HTuple* TemplateID);

// Preparing a pattern for template matching.
LIntExport void CreateTemplate(const HObject& Template, const HTuple& FirstError, const HTuple& NumLevel, const HTuple& Optimize, const HTuple& GrayValues, HTuple* TemplateID);

// Serialize a template.
LIntExport void SerializeTemplate(const HTuple& TemplateID, HTuple* SerializedItemHandle);

// Deserialize a serialized template.
LIntExport void DeserializeTemplate(const HTuple& SerializedItemHandle, HTuple* TemplateID);

// Writing a template to file.
LIntExport void WriteTemplate(const HTuple& TemplateID, const HTuple& FileName);

// Reading a template from file.
LIntExport void ReadTemplate(const HTuple& FileName, HTuple* TemplateID);

// Deallocation of the memory of all templates.
LIntExport void ClearAllTemplates();

// Deallocation of the memory of a template.
LIntExport void ClearTemplate(const HTuple& TemplateID);

// Gray value offset for template.
LIntExport void SetOffsetTemplate(const HTuple& TemplateID, const HTuple& GrayOffset);

// Define reference position for a matching template.
LIntExport void SetReferenceTemplate(const HTuple& TemplateID, const HTuple& Row, const HTuple& Column);

// Adapting a template to the size of an image.
LIntExport void AdaptTemplate(const HObject& Image, const HTuple& TemplateID);

// Searching all good grayvalue matches in a pyramid.
LIntExport void FastMatchMg(const HObject& Image, HObject* Matches, const HTuple& TemplateID, const HTuple& MaxError, const HTuple& NumLevel);

// Searching the best grayvalue matches in a pre generated pyramid.
LIntExport void BestMatchPreMg(const HObject& ImagePyramid, const HTuple& TemplateID, const HTuple& MaxError, const HTuple& SubPixel, const HTuple& NumLevels, const HTuple& WhichLevels, HTuple* Row, HTuple* Column, HTuple* Error);

// Searching the best grayvalue matches in a pyramid.
LIntExport void BestMatchMg(const HObject& Image, const HTuple& TemplateID, const HTuple& MaxError, const HTuple& SubPixel, const HTuple& NumLevels, const HTuple& WhichLevels, HTuple* Row, HTuple* Column, HTuple* Error);

// Searching all good matches of a template and an image.
LIntExport void FastMatch(const HObject& Image, HObject* Matches, const HTuple& TemplateID, const HTuple& MaxError);

// Searching the best matching of a template and a pyramid with rotation.
LIntExport void BestMatchRotMg(const HObject& Image, const HTuple& TemplateID, const HTuple& AngleStart, const HTuple& AngleExtend, const HTuple& MaxError, const HTuple& SubPixel, const HTuple& NumLevels, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* Error);

// Searching the best matching of a template and an image with rotation.
LIntExport void BestMatchRot(const HObject& Image, const HTuple& TemplateID, const HTuple& AngleStart, const HTuple& AngleExtend, const HTuple& MaxError, const HTuple& SubPixel, HTuple* Row, HTuple* Column, HTuple* Angle, HTuple* Error);

// Searching the best matching of a template and an image.
LIntExport void BestMatch(const HObject& Image, const HTuple& TemplateID, const HTuple& MaxError, const HTuple& SubPixel, HTuple* Row, HTuple* Column, HTuple* Error);

// Matching of a template and an image.
LIntExport void ExhaustiveMatch(const HObject& Image, const HObject& RegionOfInterest, const HObject& ImageTemplate, HObject* ImageMatch, const HTuple& Mode);

// Searching corners in images.
LIntExport void CornerResponse(const HObject& Image, HObject* ImageCorner, const HTuple& Size, const HTuple& Weight);

// Calculating a Gauss pyramid.
LIntExport void GenGaussPyramid(const HObject& Image, HObject* ImagePyramid, const HTuple& Mode, const HTuple& Scale);

// Calculating the monotony operation.
LIntExport void Monotony(const HObject& Image, HObject* ImageMonotony);

// Edge extraction using bandpass filters.
LIntExport void BandpassImage(const HObject& Image, HObject* ImageBandpass, const HTuple& FilterType);

// Detect color lines and their width.
LIntExport void LinesColor(const HObject& Image, HObject* Lines, const HTuple& Sigma, const HTuple& Low, const HTuple& High, const HTuple& ExtractWidth, const HTuple& CompleteJunctions);

// Detect lines and their width.
LIntExport void LinesGauss(const HObject& Image, HObject* Lines, const HTuple& Sigma, const HTuple& Low, const HTuple& High, const HTuple& LightDark, const HTuple& ExtractWidth, const HTuple& LineModel, const HTuple& CompleteJunctions);

// Detection of lines using the facet model.
LIntExport void LinesFacet(const HObject& Image, HObject* Lines, const HTuple& MaskSize, const HTuple& Low, const HTuple& High, const HTuple& LightDark);

// Store a filter mask in the spatial domain as a real-image.
LIntExport void GenFilterMask(HObject* ImageFilter, const HTuple& FilterMask, const HTuple& Scale, const HTuple& Width, const HTuple& Height);

// Generate a mean filter in the frequency domain.
LIntExport void GenMeanFilter(HObject* ImageMean, const HTuple& MaskShape, const HTuple& Diameter1, const HTuple& Diameter2, const HTuple& Phi, const HTuple& Norm, const HTuple& Mode, const HTuple& Width, const HTuple& Height);

// Generate a Gaussian filter in the frequency domain.
LIntExport void GenGaussFilter(HObject* ImageGauss, const HTuple& Sigma1, const HTuple& Sigma2, const HTuple& Phi, const HTuple& Norm, const HTuple& Mode, const HTuple& Width, const HTuple& Height);

// Generate a derivative filter in the frequency domain.
LIntExport void GenDerivativeFilter(HObject* ImageDerivative, const HTuple& Derivative, const HTuple& Exponent, const HTuple& Norm, const HTuple& Mode, const HTuple& Width, const HTuple& Height);

// Generate a bandpass filter with Gaussian or sinusoidal shape.
LIntExport void GenStdBandpass(HObject* ImageFilter, const HTuple& Frequency, const HTuple& Sigma, const HTuple& Type, const HTuple& Norm, const HTuple& Mode, const HTuple& Width, const HTuple& Height);

// Generate a bandpass filter with sinusoidal shape.
LIntExport void GenSinBandpass(HObject* ImageFilter, const HTuple& Frequency, const HTuple& Norm, const HTuple& Mode, const HTuple& Width, const HTuple& Height);

// Generate an ideal band filter.
LIntExport void GenBandfilter(HObject* ImageFilter, const HTuple& MinFrequency, const HTuple& MaxFrequency, const HTuple& Norm, const HTuple& Mode, const HTuple& Width, const HTuple& Height);

// Generate an ideal bandpass filter.
LIntExport void GenBandpass(HObject* ImageBandpass, const HTuple& MinFrequency, const HTuple& MaxFrequency, const HTuple& Norm, const HTuple& Mode, const HTuple& Width, const HTuple& Height);

// Generate an ideal lowpass filter.
LIntExport void GenLowpass(HObject* ImageLowpass, const HTuple& Frequency, const HTuple& Norm, const HTuple& Mode, const HTuple& Width, const HTuple& Height);

// Generate an ideal highpass filter.
LIntExport void GenHighpass(HObject* ImageHighpass, const HTuple& Frequency, const HTuple& Norm, const HTuple& Mode, const HTuple& Width, const HTuple& Height);

// Return the power spectrum of a complex image.
LIntExport void PowerLn(const HObject& Image, HObject* ImageResult);

// Return the power spectrum of a complex image.
LIntExport void PowerReal(const HObject& Image, HObject* ImageResult);

// Return the power spectrum of a complex image.
LIntExport void PowerByte(const HObject& Image, HObject* PowerByte);

// Return the phase of a complex image in degrees.
LIntExport void PhaseDeg(const HObject& ImageComplex, HObject* ImagePhase);

// Return the phase of a complex image in radians.
LIntExport void PhaseRad(const HObject& ImageComplex, HObject* ImagePhase);

// Calculate the energy of a two-channel image.
LIntExport void EnergyGabor(const HObject& ImageGabor, const HObject& ImageHilbert, HObject* Energy);

// Convolve an image with a Gabor filter in the frequency domain.
LIntExport void ConvolGabor(const HObject& ImageFFT, const HObject& GaborFilter, HObject* ImageResultGabor, HObject* ImageResultHilbert);

// Generate a Gabor filter.
LIntExport void GenGabor(HObject* ImageFilter, const HTuple& Angle, const HTuple& Frequency, const HTuple& Bandwidth, const HTuple& Orientation, const HTuple& Norm, const HTuple& Mode, const HTuple& Width, const HTuple& Height);

// Compute the phase correlation of two images in the frequency domain.
LIntExport void PhaseCorrelationFft(const HObject& ImageFFT1, const HObject& ImageFFT2, HObject* ImagePhaseCorrelation);

// Compute the correlation of two images in the frequency domain.
LIntExport void CorrelationFft(const HObject& ImageFFT1, const HObject& ImageFFT2, HObject* ImageCorrelation);

// Convolve an image with a filter in the frequency domain.
LIntExport void ConvolFft(const HObject& ImageFFT, const HObject& ImageFilter, HObject* ImageConvol);

// Deserialize FFT speed optimization data.
LIntExport void DeserializeFftOptimizationData(const HTuple& SerializedItemHandle);

// Serialize FFT speed optimization data.
LIntExport void SerializeFftOptimizationData(HTuple* SerializedItemHandle);

// Load FFT speed optimization data from a file.
LIntExport void ReadFftOptimizationData(const HTuple& FileName);

// Store FFT speed optimization data in a file.
LIntExport void WriteFftOptimizationData(const HTuple& FileName);

// Optimize the runtime of the real-valued FFT.
LIntExport void OptimizeRftSpeed(const HTuple& Width, const HTuple& Height, const HTuple& Mode);

// Optimize the runtime of the FFT.
LIntExport void OptimizeFftSpeed(const HTuple& Width, const HTuple& Height, const HTuple& Mode);

// Compute the real-valued fast Fourier transform of an image.
LIntExport void RftGeneric(const HObject& Image, HObject* ImageFFT, const HTuple& Direction, const HTuple& Norm, const HTuple& ResultType, const HTuple& Width);

// Compute the inverse fast Fourier transform of an image.
LIntExport void FftImageInv(const HObject& Image, HObject* ImageFFTInv);

// Compute the fast Fourier transform of an image.
LIntExport void FftImage(const HObject& Image, HObject* ImageFFT);

// Compute the fast Fourier transform of an image.
LIntExport void FftGeneric(const HObject& Image, HObject* ImageFFT, const HTuple& Direction, const HTuple& Exponent, const HTuple& Norm, const HTuple& Mode, const HTuple& ResultType);

// Apply a shock filter to an image.
LIntExport void ShockFilter(const HObject& Image, HObject* SharpenedImage, const HTuple& Theta, const HTuple& Iterations, const HTuple& Mode, const HTuple& Sigma);

// Apply the mean curvature flow to an image.
LIntExport void MeanCurvatureFlow(const HObject& Image, HObject* ImageMCF, const HTuple& Sigma, const HTuple& Theta, const HTuple& Iterations);

// Perform a coherence enhancing diffusion of an image.
LIntExport void CoherenceEnhancingDiff(const HObject& Image, HObject* ImageCED, const HTuple& Sigma, const HTuple& Rho, const HTuple& Theta, const HTuple& Iterations);

// Histogram linearisation of images
LIntExport void EquHistoImage(const HObject& Image, HObject* ImageEquHisto);

// Illuminate image.
LIntExport void Illuminate(const HObject& Image, HObject* ImageIlluminate, const HTuple& MaskWidth, const HTuple& MaskHeight, const HTuple& Factor);

// Enhance contrast of the image.
LIntExport void Emphasize(const HObject& Image, HObject* ImageEmphasize, const HTuple& MaskWidth, const HTuple& MaskHeight, const HTuple& Factor);

// Maximum gray value spreading in the value range 0 to 255.
LIntExport void ScaleImageMax(const HObject& Image, HObject* ImageScaleMax);

// Detect edges (amplitude and direction) using the Robinson operator.
LIntExport void RobinsonDir(const HObject& Image, HObject* ImageEdgeAmp, HObject* ImageEdgeDir);

// Detect edges (amplitude) using the Robinson operator.
LIntExport void RobinsonAmp(const HObject& Image, HObject* ImageEdgeAmp);

// Detect edges (amplitude and direction) using the Kirsch operator.
LIntExport void KirschDir(const HObject& Image, HObject* ImageEdgeAmp, HObject* ImageEdgeDir);

// Detect edges (amplitude) using the Kirsch operator.
LIntExport void KirschAmp(const HObject& Image, HObject* ImageEdgeAmp);

// Detect edges (amplitude and direction) using the Frei-Chen operator.
LIntExport void FreiDir(const HObject& Image, HObject* ImageEdgeAmp, HObject* ImageEdgeDir);

// Detect edges (amplitude) using the Frei-Chen operator.
LIntExport void FreiAmp(const HObject& Image, HObject* ImageEdgeAmp);

// Detect edges (amplitude and direction) using the Prewitt operator.
LIntExport void PrewittDir(const HObject& Image, HObject* ImageEdgeAmp, HObject* ImageEdgeDir);

// Detect edges (amplitude) using the Prewitt operator.
LIntExport void PrewittAmp(const HObject& Image, HObject* ImageEdgeAmp);

// Detect edges (amplitude) using the Sobel operator.
LIntExport void SobelAmp(const HObject& Image, HObject* EdgeAmplitude, const HTuple& FilterType, const HTuple& Size);

// Detect edges (amplitude and direction) using the Sobel operator.
LIntExport void SobelDir(const HObject& Image, HObject* EdgeAmplitude, HObject* EdgeDirection, const HTuple& FilterType, const HTuple& Size);

// Detect edges using the Roberts filter.
LIntExport void Roberts(const HObject& Image, HObject* ImageRoberts, const HTuple& FilterType);

// Calculate the Laplace operator by using finite differences.
LIntExport void Laplace(const HObject& Image, HObject* ImageLaplace, const HTuple& ResultType, const HTuple& MaskSize, const HTuple& FilterMask);

// Extract high frequency components from an image.
LIntExport void HighpassImage(const HObject& Image, HObject* Highpass, const HTuple& Width, const HTuple& Height);

// Estimate the width of a filter in edges_image.
LIntExport void InfoEdges(const HTuple& Filter, const HTuple& Mode, const HTuple& Alpha, HTuple* Size, HTuple* Coeffs);

// Extract subpixel precise color edges using Deriche, Shen, or Canny filters.
LIntExport void EdgesColorSubPix(const HObject& Image, HObject* Edges, const HTuple& Filter, const HTuple& Alpha, const HTuple& Low, const HTuple& High);

// Extract color edges using Canny, Deriche, or Shen filters.
LIntExport void EdgesColor(const HObject& Image, HObject* ImaAmp, HObject* ImaDir, const HTuple& Filter, const HTuple& Alpha, const HTuple& NMS, const HTuple& Low, const HTuple& High);

// Extract sub-pixel precise edges using Deriche, Lanser, Shen, or Canny filters.
LIntExport void EdgesSubPix(const HObject& Image, HObject* Edges, const HTuple& Filter, const HTuple& Alpha, const HTuple& Low, const HTuple& High);

// Extract edges using Deriche, Lanser, Shen, or Canny filters.
LIntExport void EdgesImage(const HObject& Image, HObject* ImaAmp, HObject* ImaDir, const HTuple& Filter, const HTuple& Alpha, const HTuple& NMS, const HTuple& Low, const HTuple& High);

// Convolve an image with derivatives of the Gaussian.
LIntExport void DerivateGauss(const HObject& Image, HObject* DerivGauss, const HTuple& Sigma, const HTuple& Component);

// LoG-Operator (Laplace of Gaussian).
LIntExport void LaplaceOfGauss(const HObject& Image, HObject* ImageLaplace, const HTuple& Sigma);

// Approximate the LoG operator (Laplace of Gaussian).
LIntExport void DiffOfGauss(const HObject& Image, HObject* DiffOfGauss, const HTuple& Sigma, const HTuple& SigFactor);

// Close edge gaps using the edge amplitude image.
LIntExport void CloseEdgesLength(const HObject& Edges, const HObject& Gradient, HObject* ClosedEdges, const HTuple& MinAmplitude, const HTuple& MaxGapLength);

// Close edge gaps using the edge amplitude image.
LIntExport void CloseEdges(const HObject& Edges, const HObject& EdgeImage, HObject* RegionResult, const HTuple& MinAmplitude);

// Detect straight edge segments.
LIntExport void DetectEdgeSegments(const HObject& Image, const HTuple& SobelSize, const HTuple& MinAmplitude, const HTuple& MaxDistance, const HTuple& MinLength, HTuple* BeginRow, HTuple* BeginCol, HTuple* EndRow, HTuple* EndCol);

// Delete all look-up-tables of the color space transformation.
LIntExport void ClearAllColorTransLuts();

// Release the look-up-table needed for color space transformation.
LIntExport void ClearColorTransLut(const HTuple& ColorTransLUTHandle);

// Color space transformation using pre-generated look-up-table.
LIntExport void ApplyColorTransLut(const HObject& Image1, const HObject& Image2, const HObject& Image3, HObject* ImageResult1, HObject* ImageResult2, HObject* ImageResult3, const HTuple& ColorTransLUTHandle);

// Creates the look-up-table for transformation of an image from the RGB color space to an arbitrary color space.
LIntExport void CreateColorTransLut(const HTuple& ColorSpace, const HTuple& TransDirection, const HTuple& NumBits, HTuple* ColorTransLUTHandle);

// Convert a single-channel color filter array image into an RGB image.
LIntExport void CfaToRgb(const HObject& CFAImage, HObject* RGBImage, const HTuple& CFAType, const HTuple& Interpolation);

// Transform an RGB image into a gray scale image.
LIntExport void Rgb1ToGray(const HObject& RGBImage, HObject* GrayImage);

// Transform an RGB image to a gray scale image.
LIntExport void Rgb3ToGray(const HObject& ImageRed, const HObject& ImageGreen, const HObject& ImageBlue, HObject* ImageGray);

// Transform an image from the RGB color space to an arbitrary color space.
LIntExport void TransFromRgb(const HObject& ImageRed, const HObject& ImageGreen, const HObject& ImageBlue, HObject* ImageResult1, HObject* ImageResult2, HObject* ImageResult3, const HTuple& ColorSpace);

// Transform an image from an arbitrary color space to the RGB color space.
LIntExport void TransToRgb(const HObject& ImageInput1, const HObject& ImageInput2, const HObject& ImageInput3, HObject* ImageRed, HObject* ImageGreen, HObject* ImageBlue, const HTuple& ColorSpace);

// Logical "AND" of each pixel using a bit mask.
LIntExport void BitMask(const HObject& Image, HObject* ImageMask, const HTuple& BitMask);

// Extract a bit from the pixels.
LIntExport void BitSlice(const HObject& Image, HObject* ImageSlice, const HTuple& Bit);

// Right shift of all pixels of the image.
LIntExport void BitRshift(const HObject& Image, HObject* ImageRShift, const HTuple& Shift);

// Left shift of all pixels of the image.
LIntExport void BitLshift(const HObject& Image, HObject* ImageLShift, const HTuple& Shift);

// Complement all bits of the pixels.
LIntExport void BitNot(const HObject& Image, HObject* ImageNot);

// Bit-by-bit XOR of all pixels of the input images.
LIntExport void BitXor(const HObject& Image1, const HObject& Image2, HObject* ImageXor);

// Bit-by-bit OR of all pixels of the input images.
LIntExport void BitOr(const HObject& Image1, const HObject& Image2, HObject* ImageOr);

// Bit-by-bit AND of all pixels of the input images.
LIntExport void BitAnd(const HObject& Image1, const HObject& Image2, HObject* ImageAnd);

// Perform a gamma encoding or decoding of an image.
LIntExport void GammaImage(const HObject& Image, HObject* GammaImage, const HTuple& Gamma, const HTuple& Offset, const HTuple& Threshold, const HTuple& MaxGray, const HTuple& Encode);

// Raise an image to a power.
LIntExport void PowImage(const HObject& Image, HObject* PowImage, const HTuple& Exponent);

// Calculate the exponentiation of an image.
LIntExport void ExpImage(const HObject& Image, HObject* ExpImage, const HTuple& Base);

// Calculate the logarithm of an image.
LIntExport void LogImage(const HObject& Image, HObject* LogImage, const HTuple& Base);

// Calculate the arctangent of two images.
LIntExport void Atan2Image(const HObject& ImageY, const HObject& ImageX, HObject* ArctanImage);

// Calculate the arctangent of an image.
LIntExport void AtanImage(const HObject& Image, HObject* ArctanImage);

// Calculate the arccosine of an image.
LIntExport void AcosImage(const HObject& Image, HObject* ArccosImage);

// Calculate the arcsine of an image.
LIntExport void AsinImage(const HObject& Image, HObject* ArcsinImage);

// Calculate the tangent of an image.
LIntExport void TanImage(const HObject& Image, HObject* TanImage);

// Calculate the cosine of an image.
LIntExport void CosImage(const HObject& Image, HObject* CosImage);

// Calculate the sine of an image.
LIntExport void SinImage(const HObject& Image, HObject* SinImage);

// Calculate the absolute difference of two images.
LIntExport void AbsDiffImage(const HObject& Image1, const HObject& Image2, HObject* ImageAbsDiff, const HTuple& Mult);

// Calculate the square root of an image.
LIntExport void SqrtImage(const HObject& Image, HObject* SqrtImage);

// Subtract two images.
LIntExport void SubImage(const HObject& ImageMinuend, const HObject& ImageSubtrahend, HObject* ImageSub, const HTuple& Mult, const HTuple& Add);

// Scale the gray values of an image.
LIntExport void ScaleImage(const HObject& Image, HObject* ImageScaled, const HTuple& Mult, const HTuple& Add);

// Divide two images.
LIntExport void DivImage(const HObject& Image1, const HObject& Image2, HObject* ImageResult, const HTuple& Mult, const HTuple& Add);

// Multiply two images.
LIntExport void MultImage(const HObject& Image1, const HObject& Image2, HObject* ImageResult, const HTuple& Mult, const HTuple& Add);

// Add two images.
LIntExport void AddImage(const HObject& Image1, const HObject& Image2, HObject* ImageResult, const HTuple& Mult, const HTuple& Add);

// Calculate the absolute value (modulus) of an image.
LIntExport void AbsImage(const HObject& Image, HObject* ImageAbs);

// Calculate the minimum of two images pixel by pixel.
LIntExport void MinImage(const HObject& Image1, const HObject& Image2, HObject* ImageMin);

// Calculate the maximum of two images pixel by pixel.
LIntExport void MaxImage(const HObject& Image1, const HObject& Image2, HObject* ImageMax);

// Invert an image.
LIntExport void InvertImage(const HObject& Image, HObject* ImageInvert);

// Apply an automatic color correction to panorama images.
LIntExport void AdjustMosaicImages(const HObject& Images, HObject* CorrectedImages, const HTuple& From, const HTuple& To, const HTuple& ReferenceImage, const HTuple& HomMatrices2D, const HTuple& EstimationMethod, const HTuple& EstimateParameters, const HTuple& OECFModel);

// Create 6 cube map images of a spherical mosaic.
LIntExport void GenCubeMapMosaic(const HObject& Images, HObject* Front, HObject* Rear, HObject* Left, HObject* Right, HObject* Top, HObject* Bottom, const HTuple& CameraMatrices, const HTuple& RotationMatrices, const HTuple& CubeMapDimension, const HTuple& StackingOrder, const HTuple& Interpolation);

// Create a spherical mosaic image.
LIntExport void GenSphericalMosaic(const HObject& Images, HObject* MosaicImage, const HTuple& CameraMatrices, const HTuple& RotationMatrices, const HTuple& LatMin, const HTuple& LatMax, const HTuple& LongMin, const HTuple& LongMax, const HTuple& LatLongStep, const HTuple& StackingOrder, const HTuple& Interpolation);

// Combine multiple images into a mosaic image.
LIntExport void GenBundleAdjustedMosaic(const HObject& Images, HObject* MosaicImage, const HTuple& HomMatrices2D, const HTuple& StackingOrder, const HTuple& TransformDomain, HTuple* TransMat2D);

// Combine multiple images into a mosaic image.
LIntExport void GenProjectiveMosaic(const HObject& Images, HObject* MosaicImage, const HTuple& StartImage, const HTuple& MappingSource, const HTuple& MappingDest, const HTuple& HomMatrices2D, const HTuple& StackingOrder, const HTuple& TransformDomain, HTuple* MosaicMatrices2D);

// Apply a projective transformation to an image and specify the output image size.
LIntExport void ProjectiveTransImageSize(const HObject& Image, HObject* TransImage, const HTuple& HomMat2D, const HTuple& Interpolation, const HTuple& Width, const HTuple& Height, const HTuple& TransformDomain);

// Apply a projective transformation to an image.
LIntExport void ProjectiveTransImage(const HObject& Image, HObject* TransImage, const HTuple& HomMat2D, const HTuple& Interpolation, const HTuple& AdaptImageSize, const HTuple& TransformDomain);

// Apply an arbitrary affine 2D transformation to an image and specify the output image size.
LIntExport void AffineTransImageSize(const HObject& Image, HObject* ImageAffinTrans, const HTuple& HomMat2D, const HTuple& Interpolation, const HTuple& Width, const HTuple& Height);

// Apply an arbitrary affine 2D transformation to images.
LIntExport void AffineTransImage(const HObject& Image, HObject* ImageAffinTrans, const HTuple& HomMat2D, const HTuple& Interpolation, const HTuple& AdaptImageSize);

// Zoom an image by a given factor.
LIntExport void ZoomImageFactor(const HObject& Image, HObject* ImageZoomed, const HTuple& ScaleWidth, const HTuple& ScaleHeight, const HTuple& Interpolation);

// Zoom an image to a given size.
LIntExport void ZoomImageSize(const HObject& Image, HObject* ImageZoom, const HTuple& Width, const HTuple& Height, const HTuple& Interpolation);

// Mirror an image.
LIntExport void MirrorImage(const HObject& Image, HObject* ImageMirror, const HTuple& Mode);

// Rotate an image about its center.
LIntExport void RotateImage(const HObject& Image, HObject* ImageRotate, const HTuple& Phi, const HTuple& Interpolation);

// Transform an image in polar coordinates back to cartesian coordinates
LIntExport void PolarTransImageInv(const HObject& PolarImage, HObject* XYTransImage, const HTuple& Row, const HTuple& Column, const HTuple& AngleStart, const HTuple& AngleEnd, const HTuple& RadiusStart, const HTuple& RadiusEnd, const HTuple& Width, const HTuple& Height, const HTuple& Interpolation);

// Transform an annular arc in an image to polar coordinates.
LIntExport void PolarTransImageExt(const HObject& Image, HObject* PolarTransImage, const HTuple& Row, const HTuple& Column, const HTuple& AngleStart, const HTuple& AngleEnd, const HTuple& RadiusStart, const HTuple& RadiusEnd, const HTuple& Width, const HTuple& Height, const HTuple& Interpolation);

// Transform an image to polar coordinates
LIntExport void PolarTransImage(const HObject& ImageXY, HObject* ImagePolar, const HTuple& Row, const HTuple& Column, const HTuple& Width, const HTuple& Height);

// Approximate an affine map from a displacement vector field.
LIntExport void VectorFieldToHomMat2d(const HObject& VectorField, HTuple* HomMat2D);

// Deserialize a serialized XLD object.
LIntExport void DeserializeXld(HObject* XLD, const HTuple& SerializedItemHandle);

// Serialize an XLD object.
LIntExport void SerializeXld(const HObject& XLD, HTuple* SerializedItemHandle);

// Read XLD polygons from a DXF file.
LIntExport void ReadPolygonXldDxf(HObject* Polygons, const HTuple& FileName, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* DxfStatus);

// Write XLD polygons to a file in DXF format.
LIntExport void WritePolygonXldDxf(const HObject& Polygons, const HTuple& FileName);

// Read XLD contours from a DXF file.
LIntExport void ReadContourXldDxf(HObject* Contours, const HTuple& FileName, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* DxfStatus);

// Write XLD contours to a file in DXF format.
LIntExport void WriteContourXldDxf(const HObject& Contours, const HTuple& FileName);

// Copy a file to a new location.
LIntExport void CopyFile(const HTuple& SourceFile, const HTuple& DestinationFile);

// Set the current working directory.
LIntExport void SetCurrentDir(const HTuple& DirName);

// Get the current working directory.
LIntExport void GetCurrentDir(HTuple* DirName);

// Delete an empty directory.
LIntExport void RemoveDir(const HTuple& DirName);

// Make a directory.
LIntExport void MakeDir(const HTuple& DirName);

// List all files in a directory.
LIntExport void ListFiles(const HTuple& Directory, const HTuple& Options, HTuple* Files);

// Delete a file.
LIntExport void DeleteFile(const HTuple& FileName);

// Check whether file exists.
LIntExport void FileExists(const HTuple& FileName, HTuple* FileExists);

// Read an iconic object.
LIntExport void ReadObject(HObject* Object, const HTuple& FileName);

// Write an iconic object.
LIntExport void WriteObject(const HObject& Object, const HTuple& FileName);

// Deserialize a serialized iconic object.
LIntExport void DeserializeObject(HObject* Object, const HTuple& SerializedItemHandle);

// Serialize an iconic object.
LIntExport void SerializeObject(const HObject& Object, HTuple* SerializedItemHandle);

// Deserialize a serialized image object.
LIntExport void DeserializeImage(HObject* Image, const HTuple& SerializedItemHandle);

// Serialize an image object.
LIntExport void SerializeImage(const HObject& Image, HTuple* SerializedItemHandle);

// Deserialize a serialized region.
LIntExport void DeserializeRegion(HObject* Region, const HTuple& SerializedItemHandle);

// Serialize a region.
LIntExport void SerializeRegion(const HObject& Region, HTuple* SerializedItemHandle);

// Write regions to a file.
LIntExport void WriteRegion(const HObject& Region, const HTuple& FileName);

// Write images in graphic formats.
LIntExport void WriteImage(const HObject& Image, const HTuple& Format, const HTuple& FillColor, const HTuple& FileName);

// Read images.
LIntExport void ReadSequence(HObject* Image, const HTuple& HeaderSize, const HTuple& SourceWidth, const HTuple& SourceHeight, const HTuple& StartRow, const HTuple& StartColumn, const HTuple& DestWidth, const HTuple& DestHeight, const HTuple& PixelType, const HTuple& BitOrder, const HTuple& ByteOrder, const HTuple& Pad, const HTuple& Index, const HTuple& FileName);

// Read binary images or HALCON regions.
LIntExport void ReadRegion(HObject* Region, const HTuple& FileName);

// Read an image with different file formats.
LIntExport void ReadImage(HObject* Image, const HTuple& FileName);

// Open a file in ASCII or a binary format.
LIntExport void OpenFile(const HTuple& FileName, const HTuple& FileType, HTuple* FileHandle);

// Write values in a file.
LIntExport void FwriteString(const HTuple& FileHandle, const HTuple& String);

// Read a line from a file.
LIntExport void FreadLine(const HTuple& FileHandle, HTuple* OutLine, HTuple* IsEOF);

// Read strings from a file.
LIntExport void FreadString(const HTuple& FileHandle, HTuple* OutString, HTuple* IsEOF);

// Read a character from a file.
LIntExport void FreadChar(const HTuple& FileHandle, HTuple* Char);

// Create a line feed.
LIntExport void FnewLine(const HTuple& FileHandle);

// Closing a text file.
LIntExport void CloseFile(const HTuple& FileHandle);

// Close all open files.
LIntExport void CloseAllFiles();

// Test whether contours or polygons are closed.
LIntExport void TestClosedXld(const HObject& XLD, HTuple* IsClosed);

// Return gray values of an image at the positions of an XLD contour.
LIntExport void GetGrayvalContourXld(const HObject& Image, const HObject& Contour, const HTuple& Interpolation, HTuple* Grayval);

// Arbitrary geometric moments of contours or polygons treated as point clouds.
LIntExport void MomentsAnyPointsXld(const HObject& XLD, const HTuple& Mode, const HTuple& Area, const HTuple& CenterRow, const HTuple& CenterCol, const HTuple& P, const HTuple& Q, HTuple* M);

// Anisometry of contours or polygons treated as point clouds.
LIntExport void EccentricityPointsXld(const HObject& XLD, HTuple* Anisometry);

// Parameters of the equivalent ellipse of contours or polygons treated as point clouds.
LIntExport void EllipticAxisPointsXld(const HObject& XLD, HTuple* Ra, HTuple* Rb, HTuple* Phi);

// Orientation of contours or polygons treated as point clouds.
LIntExport void OrientationPointsXld(const HObject& XLD, HTuple* Phi);

// Geometric moments M20@f$M_{20}$, M02@f$M_{02}$, and M11@f$M_{11}$ of contours or polygons treated as point clouds.
LIntExport void MomentsPointsXld(const HObject& XLD, HTuple* M11, HTuple* M20, HTuple* M02);

// Area and center of gravity (centroid) of contours and polygons treated as point clouds.
LIntExport void AreaCenterPointsXld(const HObject& XLD, HTuple* Area, HTuple* Row, HTuple* Column);

// Test XLD contours or polygons for self intersection.
LIntExport void TestSelfIntersectionXld(const HObject& XLD, const HTuple& CloseXLD, HTuple* DoesIntersect);

// Choose all contours or polygons containing a given point.
LIntExport void SelectXldPoint(const HObject& XLDs, HObject* DestXLDs, const HTuple& Row, const HTuple& Column);

// Test whether one or more contours or polygons enclose the given point(s).
LIntExport void TestXldPoint(const HObject& XLD, const HTuple& Row, const HTuple& Column, HTuple* IsInside);

// Select contours or polygons using shape features.
LIntExport void SelectShapeXld(const HObject& XLD, HObject* SelectedXLD, const HTuple& Features, const HTuple& Operation, const HTuple& Min, const HTuple& Max);

// Orientation of contours or polygons.
LIntExport void OrientationXld(const HObject& XLD, HTuple* Phi);

// Shape features derived from the ellipse parameters of contours or polygons.
LIntExport void EccentricityXld(const HObject& XLD, HTuple* Anisometry, HTuple* Bulkiness, HTuple* StructureFactor);

// Shape factor for the compactness of contours or polygons.
LIntExport void CompactnessXld(const HObject& XLD, HTuple* Compactness);

// Maximum distance between two contour or polygon points.
LIntExport void DiameterXld(const HObject& XLD, HTuple* Row1, HTuple* Column1, HTuple* Row2, HTuple* Column2, HTuple* Diameter);

// Shape factor for the convexity of contours or polygons.
LIntExport void ConvexityXld(const HObject& XLD, HTuple* Convexity);

// Shape factor for the circularity (similarity to a circle) of contours or polygons.
LIntExport void CircularityXld(const HObject& XLD, HTuple* Circularity);

// Parameters of the equivalent ellipse of contours or polygons.
LIntExport void EllipticAxisXld(const HObject& XLD, HTuple* Ra, HTuple* Rb, HTuple* Phi);

// Smallest enclosing rectangle with arbitrary orientation of contours or polygons.
LIntExport void SmallestRectangle2Xld(const HObject& XLD, HTuple* Row, HTuple* Column, HTuple* Phi, HTuple* Length1, HTuple* Length2);

// Enclosing rectangle parallel to the coordinate axes of contours or polygons.
LIntExport void SmallestRectangle1Xld(const HObject& XLD, HTuple* Row1, HTuple* Column1, HTuple* Row2, HTuple* Column2);

// Smallest enclosing circle of contours or polygons.
LIntExport void SmallestCircleXld(const HObject& XLD, HTuple* Row, HTuple* Column, HTuple* Radius);

// Transform the shape of contours or polygons.
LIntExport void ShapeTransXld(const HObject& XLD, HObject* XLDTrans, const HTuple& Type);

// Length of contours or polygons.
LIntExport void LengthXld(const HObject& XLD, HTuple* Length);

// Arbitrary geometric moments of contours or polygons.
LIntExport void MomentsAnyXld(const HObject& XLD, const HTuple& Mode, const HTuple& PointOrder, const HTuple& Area, const HTuple& CenterRow, const HTuple& CenterCol, const HTuple& P, const HTuple& Q, HTuple* M);

// Geometric moments M20@f$M_{20}$, M02@f$M_{02}$, and M11@f$M_{11}$ of contours or polygons.
LIntExport void MomentsXld(const HObject& XLD, HTuple* M11, HTuple* M20, HTuple* M02);

// Area and center of gravity (centroid) of contours and polygons.
LIntExport void AreaCenterXld(const HObject& XLD, HTuple* Area, HTuple* Row, HTuple* Column, HTuple* PointOrder);

// Geometric moments of regions.
LIntExport void MomentsRegionCentralInvar(const HObject& Regions, HTuple* PSI1, HTuple* PSI2, HTuple* PSI3, HTuple* PSI4);

// Geometric moments of regions.
LIntExport void MomentsRegionCentral(const HObject& Regions, HTuple* I1, HTuple* I2, HTuple* I3, HTuple* I4);

// Geometric moments of regions.
LIntExport void MomentsRegion3rdInvar(const HObject& Regions, HTuple* M21, HTuple* M12, HTuple* M03, HTuple* M30);

// Geometric moments of regions.
LIntExport void MomentsRegion3rd(const HObject& Regions, HTuple* M21, HTuple* M12, HTuple* M03, HTuple* M30);

// Smallest surrounding rectangle with any orientation.
LIntExport void SmallestRectangle2(const HObject& Regions, HTuple* Row, HTuple* Column, HTuple* Phi, HTuple* Length1, HTuple* Length2);

// Surrounding rectangle parallel to the coordinate axes.
LIntExport void SmallestRectangle1(const HObject& Regions, HTuple* Row1, HTuple* Column1, HTuple* Row2, HTuple* Column2);

// Smallest surrounding circle of a region.
LIntExport void SmallestCircle(const HObject& Regions, HTuple* Row, HTuple* Column, HTuple* Radius);

// Choose regions having a certain relation to each other.
LIntExport void SelectShapeProto(const HObject& Regions, const HObject& Pattern, HObject* SelectedRegions, const HTuple& Feature, const HTuple& Min, const HTuple& Max);

// Calculate shape features of regions.
LIntExport void RegionFeatures(const HObject& Regions, const HTuple& Features, HTuple* Value);

// Choose regions with the aid of shape features.
LIntExport void SelectShape(const HObject& Regions, HObject* SelectedRegions, const HTuple& Features, const HTuple& Operation, const HTuple& Min, const HTuple& Max);

// Characteristic values for runlength coding of regions.
LIntExport void RunlengthFeatures(const HObject& Regions, HTuple* NumRuns, HTuple* KFactor, HTuple* LFactor, HTuple* MeanLength, HTuple* Bytes);

// Search direct neighbors.
LIntExport void FindNeighbors(const HObject& Regions1, const HObject& Regions2, const HTuple& MaxDistance, HTuple* RegionIndex1, HTuple* RegionIndex2);

// Geometric moments of regions.
LIntExport void MomentsRegion2ndRelInvar(const HObject& Regions, HTuple* PHI1, HTuple* PHI2);

// Geometric moments of regions.
LIntExport void MomentsRegion2ndInvar(const HObject& Regions, HTuple* M11, HTuple* M20, HTuple* M02);

// Calculate the geometric moments of regions.
LIntExport void MomentsRegion2nd(const HObject& Regions, HTuple* M11, HTuple* M20, HTuple* M02, HTuple* Ia, HTuple* Ib);

// Minimum distance between the contour pixels of two regions each.
LIntExport void DistanceRrMin(const HObject& Regions1, const HObject& Regions2, HTuple* MinDistance, HTuple* Row1, HTuple* Column1, HTuple* Row2, HTuple* Column2);

// Minimum distance between two regions with the help of dilation.
LIntExport void DistanceRrMinDil(const HObject& Regions1, const HObject& Regions2, HTuple* MinDistance);

// Maximal distance between two boundary points of a region.
LIntExport void DiameterRegion(const HObject& Regions, HTuple* Row1, HTuple* Column1, HTuple* Row2, HTuple* Column2, HTuple* Diameter);

// Test if the region contains a given point.
LIntExport void TestRegionPoint(const HObject& Regions, const HTuple& Row, const HTuple& Column, HTuple* IsInside);

// Index of all regions containing a given pixel.
LIntExport void GetRegionIndex(const HObject& Regions, const HTuple& Row, const HTuple& Column, HTuple* Index);

// Choose all regions containing a given pixel.
LIntExport void SelectRegionPoint(const HObject& Regions, HObject* DestRegions, const HTuple& Row, const HTuple& Column);

// Select regions of a given shape.
LIntExport void SelectShapeStd(const HObject& Regions, HObject* SelectedRegions, const HTuple& Shape, const HTuple& Percent);

// Hamming distance between two regions using normalization.
LIntExport void HammingDistanceNorm(const HObject& Regions1, const HObject& Regions2, const HTuple& Norm, HTuple* Distance, HTuple* Similarity);

// Hamming distance between two regions.
LIntExport void HammingDistance(const HObject& Regions1, const HObject& Regions2, HTuple* Distance, HTuple* Similarity);

// Shape features derived from the ellipse parameters.
LIntExport void Eccentricity(const HObject& Regions, HTuple* Anisometry, HTuple* Bulkiness, HTuple* StructureFactor);

// Calculate the Euler number.
LIntExport void EulerNumber(const HObject& Regions, HTuple* EulerNumber);

// Orientation of a region.
LIntExport void OrientationRegion(const HObject& Regions, HTuple* Phi);

// Calculate the parameters of the equivalent ellipse.
LIntExport void EllipticAxis(const HObject& Regions, HTuple* Ra, HTuple* Rb, HTuple* Phi);

// Pose relation of regions.
LIntExport void SelectRegionSpatial(const HObject& Regions1, const HObject& Regions2, const HTuple& Direction, HTuple* RegionIndex1, HTuple* RegionIndex2);

// Pose relation of regions with regard to 
LIntExport void SpatialRelation(const HObject& Regions1, const HObject& Regions2, const HTuple& Percent, HTuple* RegionIndex1, HTuple* RegionIndex2, HTuple* Relation1, HTuple* Relation2);

// Shape factor for the convexity of a region.
LIntExport void Convexity(const HObject& Regions, HTuple* Convexity);

// Contour length of a region.
LIntExport void Contlength(const HObject& Regions, HTuple* ContLength);

// Number of connection components and holes
LIntExport void ConnectAndHoles(const HObject& Regions, HTuple* NumConnected, HTuple* NumHoles);

// Shape factor for the rectangularity of a region.
LIntExport void Rectangularity(const HObject& Regions, HTuple* Rectangularity);

// Shape factor for the compactness of a region.
LIntExport void Compactness(const HObject& Regions, HTuple* Compactness);

// Shape factor for the circularity (similarity to a circle) of a region.
LIntExport void Circularity(const HObject& Regions, HTuple* Circularity);

// Compute the area of holes of regions.
LIntExport void AreaHoles(const HObject& Regions, HTuple* Area);

// Area and center of regions.
LIntExport void AreaCenter(const HObject& Regions, HTuple* Area, HTuple* Row, HTuple* Column);

// Distribution of runs needed for runlength encoding of a region.
LIntExport void RunlengthDistribution(const HObject& Region, HTuple* Foreground, HTuple* Background);

// Shape factors from contour.
LIntExport void Roundness(const HObject& Regions, HTuple* Distance, HTuple* Sigma, HTuple* Roundness, HTuple* Sides);

// Largest inner rectangle of a region.
LIntExport void InnerRectangle1(const HObject& Regions, HTuple* Row1, HTuple* Column1, HTuple* Row2, HTuple* Column2);

// Largest inner circle of a region.
LIntExport void InnerCircle(const HObject& Regions, HTuple* Row, HTuple* Column, HTuple* Radius);

// Select the longest input lines.
LIntExport void SelectLinesLongest(const HTuple& RowBeginIn, const HTuple& ColBeginIn, const HTuple& RowEndIn, const HTuple& ColEndIn, const HTuple& Num, HTuple* RowBeginOut, HTuple* ColBeginOut, HTuple* RowEndOut, HTuple* ColEndOut);

// Partition lines according to various criteria.
LIntExport void PartitionLines(const HTuple& RowBeginIn, const HTuple& ColBeginIn, const HTuple& RowEndIn, const HTuple& ColEndIn, const HTuple& Feature, const HTuple& Operation, const HTuple& Min, const HTuple& Max, HTuple* RowBeginOut, HTuple* ColBeginOut, HTuple* RowEndOut, HTuple* ColEndOut, HTuple* FailRowBOut, HTuple* FailColBOut, HTuple* FailRowEOut, HTuple* FailColEOut);

// Select lines according to various criteria.
LIntExport void SelectLines(const HTuple& RowBeginIn, const HTuple& ColBeginIn, const HTuple& RowEndIn, const HTuple& ColEndIn, const HTuple& Feature, const HTuple& Operation, const HTuple& Min, const HTuple& Max, HTuple* RowBeginOut, HTuple* ColBeginOut, HTuple* RowEndOut, HTuple* ColEndOut);

// Calculate the center of gravity, length, and orientation of a line.
LIntExport void LinePosition(const HTuple& RowBegin, const HTuple& ColBegin, const HTuple& RowEnd, const HTuple& ColEnd, HTuple* RowCenter, HTuple* ColCenter, HTuple* Length, HTuple* Phi);

// Calculate the orientation of lines.
LIntExport void LineOrientation(const HTuple& RowBegin, const HTuple& ColBegin, const HTuple& RowEnd, const HTuple& ColEnd, HTuple* Phi);

// Approximate a contour by arcs and lines.
LIntExport void ApproxChainSimple(const HTuple& Row, const HTuple& Column, HTuple* ArcCenterRow, HTuple* ArcCenterCol, HTuple* ArcAngle, HTuple* ArcBeginRow, HTuple* ArcBeginCol, HTuple* LineBeginRow, HTuple* LineBeginCol, HTuple* LineEndRow, HTuple* LineEndCol, HTuple* Order);

// Approximate a contour by arcs and lines.
LIntExport void ApproxChain(const HTuple& Row, const HTuple& Column, const HTuple& MinWidthCoord, const HTuple& MaxWidthCoord, const HTuple& ThreshStart, const HTuple& ThreshEnd, const HTuple& ThreshStep, const HTuple& MinWidthSmooth, const HTuple& MaxWidthSmooth, const HTuple& MinWidthCurve, const HTuple& MaxWidthCurve, const HTuple& Weight1, const HTuple& Weight2, const HTuple& Weight3, HTuple* ArcCenterRow, HTuple* ArcCenterCol, HTuple* ArcAngle, HTuple* ArcBeginRow, HTuple* ArcBeginCol, HTuple* LineBeginRow, HTuple* LineBeginCol, HTuple* LineEndRow, HTuple* LineEndCol, HTuple* Order);

// Calculate gray value moments and approximation by a first order surface (plane).
LIntExport void FitSurfaceFirstOrder(const HObject& Regions, const HObject& Image, const HTuple& Algorithm, const HTuple& Iterations, const HTuple& ClippingFactor, HTuple* Alpha, HTuple* Beta, HTuple* Gamma);

// Calculate gray value moments and approximation by a second order surface.
LIntExport void FitSurfaceSecondOrder(const HObject& Regions, const HObject& Image, const HTuple& Algorithm, const HTuple& Iterations, const HTuple& ClippingFactor, HTuple* Alpha, HTuple* Beta, HTuple* Gamma, HTuple* Delta, HTuple* Epsilon, HTuple* Zeta);

// Create a curved gray surface with second order polynomial.
LIntExport void GenImageSurfaceSecondOrder(HObject* ImageSurface, const HTuple& Type, const HTuple& Alpha, const HTuple& Beta, const HTuple& Gamma, const HTuple& Delta, const HTuple& Epsilon, const HTuple& Zeta, const HTuple& Row, const HTuple& Column, const HTuple& Width, const HTuple& Height);

// Create a tilted gray surface with first order polynomial.
LIntExport void GenImageSurfaceFirstOrder(HObject* ImageSurface, const HTuple& Type, const HTuple& Alpha, const HTuple& Beta, const HTuple& Gamma, const HTuple& Row, const HTuple& Column, const HTuple& Width, const HTuple& Height);

// Determine a histogram of features along all threshold values.
LIntExport void ShapeHistoPoint(const HObject& Region, const HObject& Image, const HTuple& Feature, const HTuple& Row, const HTuple& Column, HTuple* AbsoluteHisto, HTuple* RelativeHisto);

// Determine a histogram of features along all threshold values.
LIntExport void ShapeHistoAll(const HObject& Region, const HObject& Image, const HTuple& Feature, HTuple* AbsoluteHisto, HTuple* RelativeHisto);

// Calculates gray value features for a set of regions.
LIntExport void GrayFeatures(const HObject& Regions, const HObject& Image, const HTuple& Features, HTuple* Value);

// Select regions based on gray value features.
LIntExport void SelectGray(const HObject& Regions, const HObject& Image, HObject* SelectedRegions, const HTuple& Features, const HTuple& Operation, const HTuple& Min, const HTuple& Max);

// Determine the minimum and maximum gray values within regions.
LIntExport void MinMaxGray(const HObject& Regions, const HObject& Image, const HTuple& Percent, HTuple* Min, HTuple* Max, HTuple* Range);

// Calculate the mean and deviation of gray values.
LIntExport void Intensity(const HObject& Regions, const HObject& Image, HTuple* Mean, HTuple* Deviation);

// Calculate the gray value distribution of a single channel image within a certain gray value range.
LIntExport void GrayHistoRange(const HObject& Regions, const HObject& Image, const HTuple& Min, const HTuple& Max, const HTuple& NumBins, HTuple* Histo, HTuple* BinSize);

// Calculate the histogram of two-channel gray value images.
LIntExport void Histo2dim(const HObject& Regions, const HObject& ImageCol, const HObject& ImageRow, HObject* Histo2Dim);

// Calculate the gray value distribution.
LIntExport void GrayHistoAbs(const HObject& Regions, const HObject& Image, const HTuple& Quantization, HTuple* AbsoluteHisto);

// Calculate the gray value distribution.
LIntExport void GrayHisto(const HObject& Regions, const HObject& Image, HTuple* AbsoluteHisto, HTuple* RelativeHisto);

// Determine the entropy and anisotropy of images.
LIntExport void EntropyGray(const HObject& Regions, const HObject& Image, HTuple* Entropy, HTuple* Anisotropy);

// Calculate gray value features from a co-occurrence matrix.
LIntExport void CoocFeatureMatrix(const HObject& CoocMatrix, HTuple* Energy, HTuple* Correlation, HTuple* Homogeneity, HTuple* Contrast);

// Calculate a co-occurrence matrix and derive gray value features thereof.
LIntExport void CoocFeatureImage(const HObject& Regions, const HObject& Image, const HTuple& LdGray, const HTuple& Direction, HTuple* Energy, HTuple* Correlation, HTuple* Homogeneity, HTuple* Contrast);

// Calculate the co-occurrence matrix of a region in an image.
LIntExport void GenCoocMatrix(const HObject& Regions, const HObject& Image, HObject* Matrix, const HTuple& LdGray, const HTuple& Direction);

// Calculate gray value moments and approximation by a plane.
LIntExport void MomentsGrayPlane(const HObject& Regions, const HObject& Image, HTuple* MRow, HTuple* MCol, HTuple* Alpha, HTuple* Beta, HTuple* Mean);

// Calculate the deviation of the gray values from the approximating image plane.
LIntExport void PlaneDeviation(const HObject& Regions, const HObject& Image, HTuple* Deviation);

// Compute the orientation and major axes of a region in a gray value image.
LIntExport void EllipticAxisGray(const HObject& Regions, const HObject& Image, HTuple* Ra, HTuple* Rb, HTuple* Phi);

// Compute the area and center of gravity of a region in a gray value image.
LIntExport void AreaCenterGray(const HObject& Regions, const HObject& Image, HTuple* Area, HTuple* Row, HTuple* Column);

// Calculate horizontal and vertical gray-value projections.
LIntExport void GrayProjections(const HObject& Region, const HObject& Image, const HTuple& Mode, HTuple* HorProjection, HTuple* VertProjection);

// Access iconic objects that were created during the search for 2D data code symbols.
LIntExport void GetDataCode2dObjects(HObject* DataCodeObjects, const HTuple& DataCodeHandle, const HTuple& CandidateHandle, const HTuple& ObjectName);

// Get the alphanumerical results that were accumulated during the search for 2D data code symbols.
LIntExport void GetDataCode2dResults(const HTuple& DataCodeHandle, const HTuple& CandidateHandle, const HTuple& ResultNames, HTuple* ResultValues);

// Detect and read 2D data code symbols in an image or train the 2D data code model.
LIntExport void FindDataCode2d(const HObject& Image, HObject* SymbolXLDs, const HTuple& DataCodeHandle, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* ResultHandles, HTuple* DecodedDataStrings);

// Set selected parameters of the 2D data code model.
LIntExport void SetDataCode2dParam(const HTuple& DataCodeHandle, const HTuple& GenParamNames, const HTuple& GenParamValues);

// Get one or several parameters that describe the 2D data code model.
LIntExport void GetDataCode2dParam(const HTuple& DataCodeHandle, const HTuple& GenParamNames, HTuple* GenParamValues);

// Get for a given 2D data code model the names of the generic parameters or objects that can be used in the other 2D data code operators.
LIntExport void QueryDataCode2dParams(const HTuple& DataCodeHandle, const HTuple& QueryName, HTuple* GenParamNames);

// Deserialize a serialized 2D data code model.
LIntExport void DeserializeDataCode2dModel(const HTuple& SerializedItemHandle, HTuple* DataCodeHandle);

// Serialize a 2D data code model.
LIntExport void SerializeDataCode2dModel(const HTuple& DataCodeHandle, HTuple* SerializedItemHandle);

// Read a 2D data code model from a file and create a new model.
LIntExport void ReadDataCode2dModel(const HTuple& FileName, HTuple* DataCodeHandle);

// Writes a 2D data code model into a file.
LIntExport void WriteDataCode2dModel(const HTuple& DataCodeHandle, const HTuple& FileName);

// Delete all 2D data code models and free the allocated memory.
LIntExport void ClearAllDataCode2dModels();

// Delete a 2D data code model and free the allocated memory.
LIntExport void ClearDataCode2dModel(const HTuple& DataCodeHandle);

// Create a model of a 2D data code class.
LIntExport void CreateDataCode2dModel(const HTuple& SymbolType, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* DataCodeHandle);

// Deserialize serialized training data for classifiers.
LIntExport void DeserializeClassTrainData(const HTuple& SerializedItemHandle, HTuple* ClassTrainDataHandle);

// Serialize training data for classifiers.
LIntExport void SerializeClassTrainData(const HTuple& ClassTrainDataHandle, HTuple* SerializedItemHandle);

// Read the training data for classifiers from a file.
LIntExport void ReadClassTrainData(const HTuple& FileName, HTuple* ClassTrainDataHandle);

// Save the training data for classifiers in a file.
LIntExport void WriteClassTrainData(const HTuple& ClassTrainDataHandle, const HTuple& FileName);

// Select certain features from training data to create  training data containing less features.
LIntExport void SelectSubFeatureClassTrainData(const HTuple& ClassTrainDataHandle, const HTuple& SubFeatureIndices, HTuple* SelectedClassTrainDataHandle);

// Define subfeatures in training data.
LIntExport void SetFeatureLengthsClassTrainData(const HTuple& ClassTrainDataHandle, const HTuple& SubFeatureLength, const HTuple& Names);

// Get the training data of a Gaussian Mixture Model (GMM).
LIntExport void GetClassTrainDataGmm(const HTuple& GMMHandle, HTuple* ClassTrainDataHandle);

// Add training data to a Gaussian Mixture Model (GMM).
LIntExport void AddClassTrainDataGmm(const HTuple& GMMHandle, const HTuple& ClassTrainDataHandle);

// Get the training data of a multilayer perceptron (MLP).
LIntExport void GetClassTrainDataMlp(const HTuple& MLPHandle, HTuple* ClassTrainDataHandle);

// Add training data to a multilayer perceptron (MLP).
LIntExport void AddClassTrainDataMlp(const HTuple& MLPHandle, const HTuple& ClassTrainDataHandle);

// Get the training data of a k-nearest neighbors (k-NN) classifier.
LIntExport void GetClassTrainDataKnn(const HTuple& KNNHandle, HTuple* ClassTrainDataHandle);

// Add training data to a k-nearest neighbors (k-NN) classifier.
LIntExport void AddClassTrainDataKnn(const HTuple& KNNHandle, const HTuple& ClassTrainDataHandle);

// Get the training data of a support vector machine (SVM).
LIntExport void GetClassTrainDataSvm(const HTuple& SVMHandle, HTuple* ClassTrainDataHandle);

// Add training data to a support vector machine (SVM).
LIntExport void AddClassTrainDataSvm(const HTuple& SVMHandle, const HTuple& ClassTrainDataHandle);

// Return the number of training samples stored in the training data.
LIntExport void GetSampleNumClassTrainData(const HTuple& ClassTrainDataHandle, HTuple* NumSamples);

// Return a training sample from training data.
LIntExport void GetSampleClassTrainData(const HTuple& ClassTrainDataHandle, const HTuple& IndexSample, HTuple* Features, HTuple* ClassID);

// Clear all training data for classifiers.
LIntExport void ClearAllClassTrainData();

// Clears training data for classifiers.
LIntExport void ClearClassTrainData(const HTuple& ClassTrainDataHandle);

// Add a training sample to training data.
LIntExport void AddSampleClassTrainData(const HTuple& ClassTrainDataHandle, const HTuple& Order, const HTuple& Features, const HTuple& ClassID);

// Create a handle for training data for classifiers.
LIntExport void CreateClassTrainData(const HTuple& NumDim, HTuple* ClassTrainDataHandle);

// Selects an optimal combination of features to classify the provided data.
LIntExport void SelectFeatureSetMlp(const HTuple& ClassTrainDataHandle, const HTuple& SelectionMethod, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* MLPHandle, HTuple* SelectedFeatureIndices, HTuple* Score);

// Selects an optimal combination of features to classify the provided data.
LIntExport void SelectFeatureSetSvm(const HTuple& ClassTrainDataHandle, const HTuple& SelectionMethod, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* SVMHandle, HTuple* SelectedFeatureIndices, HTuple* Score);

// Selects an optimal combination from a set of features to classify the  provided data.
LIntExport void SelectFeatureSetGmm(const HTuple& ClassTrainDataHandle, const HTuple& SelectionMethod, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* GMMHandle, HTuple* SelectedFeatureIndices, HTuple* Score);

// Selects an optimal subset from a set of features to solve a certain  classification problem.
LIntExport void SelectFeatureSetKnn(const HTuple& ClassTrainDataHandle, const HTuple& SelectionMethod, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* KNNHandle, HTuple* SelectedFeatureIndices, HTuple* Score);

// Clear all k-NN classifiers.
LIntExport void ClearAllClassKnn();

// Clear a k-NN classifier.
LIntExport void ClearClassKnn(const HTuple& KNNHandle);

// Return the number of training samples stored in the training data of a k-nearest neighbors (k-NN) classifier.
LIntExport void GetSampleNumClassKnn(const HTuple& KNNHandle, HTuple* NumSamples);

// Return a training sample from the training data of a k-nearest neighbors  (k-NN) classifier.
LIntExport void GetSampleClassKnn(const HTuple& KNNHandle, const HTuple& IndexSample, HTuple* Features, HTuple* ClassID);

// Deserialize a serialized k-NN classifier.
LIntExport void DeserializeClassKnn(const HTuple& SerializedItemHandle, HTuple* KNNHandle);

// Serialize a k-NN classifier.
LIntExport void SerializeClassKnn(const HTuple& KNNHandle, HTuple* SerializedItemHandle);

// Read the k-NN classifier from a file.
LIntExport void ReadClassKnn(const HTuple& FileName, HTuple* KNNHandle);

// Save the k-NN classifier in a file.
LIntExport void WriteClassKnn(const HTuple& KNNHandle, const HTuple& FileName);

// Get parameters of a k-NN classification.
LIntExport void GetParamsClassKnn(const HTuple& KNNHandle, const HTuple& GenParamNames, HTuple* GenParamValues);

// Set parameters for k-NN classification.
LIntExport void SetParamsClassKnn(const HTuple& KNNHandle, const HTuple& GenParamNames, const HTuple& GenParamValues);

// Search for the next neighbors for a given feature vector.
LIntExport void ClassifyClassKnn(const HTuple& KNNHandle, const HTuple& Features, HTuple* Result, HTuple* Rating);

// Creates the search trees for a k-NN classifier.
LIntExport void TrainClassKnn(const HTuple& KNNHandle, const HTuple& GenParamNames, const HTuple& GenParamValues);

// Add a sample to a  k-nearest neighbors (k-NN) classifier.
LIntExport void AddSampleClassKnn(const HTuple& KNNHandle, const HTuple& Features, const HTuple& ClassID);

// Create a k-nearest neighbors (k-NN) classifier.
LIntExport void CreateClassKnn(const HTuple& NumDim, HTuple* KNNHandle);

// Clear all look-up table classifiers.
LIntExport void ClearAllClassLut();

// Clear a look-up table classifier.
LIntExport void ClearClassLut(const HTuple& ClassLUTHandle);

// Create a look-up table using a k-nearest neighbors classifier (k-NN) to classify byte images.
LIntExport void CreateClassLutKnn(const HTuple& KNNHandle, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* ClassLUTHandle);

// Create a look-up table using a gaussian mixture model to classify byte images.
LIntExport void CreateClassLutGmm(const HTuple& GMMHandle, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* ClassLUTHandle);

// Create a look-up table using a Support-Vector-Machine to classify byte images.
LIntExport void CreateClassLutSvm(const HTuple& SVMHandle, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* ClassLUTHandle);

// Create a look-up table using a multi-layer perceptron to classify byte images.
LIntExport void CreateClassLutMlp(const HTuple& MLPHandle, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* ClassLUTHandle);

// Clear all Gaussian Mixture Models.
LIntExport void ClearAllClassGmm();

// Clear a Gaussian Mixture Model.
LIntExport void ClearClassGmm(const HTuple& GMMHandle);

// Clear the training data of a Gaussian Mixture Model.
LIntExport void ClearSamplesClassGmm(const HTuple& GMMHandle);

// Deserialize a serialized Gaussian Mixture Model.
LIntExport void DeserializeClassGmm(const HTuple& SerializedItemHandle, HTuple* GMMHandle);

// Serialize a Gaussian Mixture Model (GMM).
LIntExport void SerializeClassGmm(const HTuple& GMMHandle, HTuple* SerializedItemHandle);

// Read a Gaussian Mixture Model from a file.
LIntExport void ReadClassGmm(const HTuple& FileName, HTuple* GMMHandle);

// Write a Gaussian Mixture Model to a file.
LIntExport void WriteClassGmm(const HTuple& GMMHandle, const HTuple& FileName);

// Read the training data of a Gaussian Mixture Model from a file.
LIntExport void ReadSamplesClassGmm(const HTuple& GMMHandle, const HTuple& FileName);

// Write the training data of a Gaussian Mixture Model to a file.
LIntExport void WriteSamplesClassGmm(const HTuple& GMMHandle, const HTuple& FileName);

// Calculate the class of a feature vector by a Gaussian Mixture Model.
LIntExport void ClassifyClassGmm(const HTuple& GMMHandle, const HTuple& Features, const HTuple& Num, HTuple* ClassID, HTuple* ClassProb, HTuple* Density, HTuple* KSigmaProb);

// Evaluate a feature vector by a Gaussian Mixture Model.
LIntExport void EvaluateClassGmm(const HTuple& GMMHandle, const HTuple& Features, HTuple* ClassProb, HTuple* Density, HTuple* KSigmaProb);

// Train a Gaussian Mixture Model.
LIntExport void TrainClassGmm(const HTuple& GMMHandle, const HTuple& MaxIter, const HTuple& Threshold, const HTuple& ClassPriors, const HTuple& Regularize, HTuple* Centers, HTuple* Iter);

// Compute the information content of the preprocessed feature vectors of a GMM.
LIntExport void GetPrepInfoClassGmm(const HTuple& GMMHandle, const HTuple& Preprocessing, HTuple* InformationCont, HTuple* CumInformationCont);

// Return the number of training samples stored in the training data of a Gaussian Mixture Model (GMM).
LIntExport void GetSampleNumClassGmm(const HTuple& GMMHandle, HTuple* NumSamples);

// Return a training sample from the training data of a Gaussian Mixture Models (GMM).
LIntExport void GetSampleClassGmm(const HTuple& GMMHandle, const HTuple& NumSample, HTuple* Features, HTuple* ClassID);

// Add a training sample to the training data of a Gaussian Mixture Model.
LIntExport void AddSampleClassGmm(const HTuple& GMMHandle, const HTuple& Features, const HTuple& ClassID, const HTuple& Randomize);

// Return the parameters of a Gaussian Mixture Model.
LIntExport void GetParamsClassGmm(const HTuple& GMMHandle, HTuple* NumDim, HTuple* NumClasses, HTuple* MinCenters, HTuple* MaxCenters, HTuple* CovarType);

// Create a Gaussian Mixture Model for classification
LIntExport void CreateClassGmm(const HTuple& NumDim, const HTuple& NumClasses, const HTuple& NumCenters, const HTuple& CovarType, const HTuple& Preprocessing, const HTuple& NumComponents, const HTuple& RandSeed, HTuple* GMMHandle);

// Clear all support vector machines.
LIntExport void ClearAllClassSvm();

// Clear a support vector machine.
LIntExport void ClearClassSvm(const HTuple& SVMHandle);

// Clear the training data of a support vector machine.
LIntExport void ClearSamplesClassSvm(const HTuple& SVMHandle);

// Deserialize a serialized support vector machine (SVM).
LIntExport void DeserializeClassSvm(const HTuple& SerializedItemHandle, HTuple* SVMHandle);

// Serialize a support vector machine (SVM).
LIntExport void SerializeClassSvm(const HTuple& SVMHandle, HTuple* SerializedItemHandle);

// Read a support vector machine from a file.
LIntExport void ReadClassSvm(const HTuple& FileName, HTuple* SVMHandle);

// Write a support vector machine to a file.
LIntExport void WriteClassSvm(const HTuple& SVMHandle, const HTuple& FileName);

// Read the training data of a support vector machine from a file.
LIntExport void ReadSamplesClassSvm(const HTuple& SVMHandle, const HTuple& FileName);

// Write the training data of a support vector machine to a file.
LIntExport void WriteSamplesClassSvm(const HTuple& SVMHandle, const HTuple& FileName);

// Evaluate a feature vector by a support vector machine.
LIntExport void EvaluateClassSvm(const HTuple& SVMHandle, const HTuple& Features, HTuple* Result);

// Classify a feature vector by a support vector machine.
LIntExport void ClassifyClassSvm(const HTuple& SVMHandle, const HTuple& Features, const HTuple& Num, HTuple* Class);

// Approximate a trained support vector machine by a reduced support vector machine for faster classification.
LIntExport void ReduceClassSvm(const HTuple& SVMHandle, const HTuple& Method, const HTuple& MinRemainingSV, const HTuple& MaxError, HTuple* SVMHandleReduced);

// Train a support vector machine.
LIntExport void TrainClassSvm(const HTuple& SVMHandle, const HTuple& Epsilon, const HTuple& TrainMode);

// Compute the information content of the preprocessed feature vectors of a support vector machine
LIntExport void GetPrepInfoClassSvm(const HTuple& SVMHandle, const HTuple& Preprocessing, HTuple* InformationCont, HTuple* CumInformationCont);

// Return the number of support vectors of a support vector machine.
LIntExport void GetSupportVectorNumClassSvm(const HTuple& SVMHandle, HTuple* NumSupportVectors, HTuple* NumSVPerSVM);

// Return the index of a support vector from a trained support vector machine.
LIntExport void GetSupportVectorClassSvm(const HTuple& SVMHandle, const HTuple& IndexSupportVector, HTuple* Index);

// Return the number of training samples stored in the training data of a support vector machine.
LIntExport void GetSampleNumClassSvm(const HTuple& SVMHandle, HTuple* NumSamples);

// Return a training sample from the training data of a support vector machine.
LIntExport void GetSampleClassSvm(const HTuple& SVMHandle, const HTuple& IndexSample, HTuple* Features, HTuple* Target);

// Add a training sample to the training data of a support vector machine.
LIntExport void AddSampleClassSvm(const HTuple& SVMHandle, const HTuple& Features, const HTuple& Class);

// Return the parameters of a support vector machine.
LIntExport void GetParamsClassSvm(const HTuple& SVMHandle, HTuple* NumFeatures, HTuple* KernelType, HTuple* KernelParam, HTuple* Nu, HTuple* NumClasses, HTuple* Mode, HTuple* Preprocessing, HTuple* NumComponents);

// Create a support vector machine for pattern classification.
LIntExport void CreateClassSvm(const HTuple& NumFeatures, const HTuple& KernelType, const HTuple& KernelParam, const HTuple& Nu, const HTuple& NumClasses, const HTuple& Mode, const HTuple& Preprocessing, const HTuple& NumComponents, HTuple* SVMHandle);

// Clear all multilayer perceptrons.
LIntExport void ClearAllClassMlp();

// Clear a multilayer perceptron.
LIntExport void ClearClassMlp(const HTuple& MLPHandle);

// Clear the training data of a multilayer perceptron.
LIntExport void ClearSamplesClassMlp(const HTuple& MLPHandle);

// Deserialize a serialized multilayer perceptron.
LIntExport void DeserializeClassMlp(const HTuple& SerializedItemHandle, HTuple* MLPHandle);

// Serialize a multilayer perceptron (MLP).
LIntExport void SerializeClassMlp(const HTuple& MLPHandle, HTuple* SerializedItemHandle);

// Read a multilayer perceptron from a file.
LIntExport void ReadClassMlp(const HTuple& FileName, HTuple* MLPHandle);

// Write a multilayer perceptron to a file.
LIntExport void WriteClassMlp(const HTuple& MLPHandle, const HTuple& FileName);

// Read the training data of a multilayer perceptron from a file.
LIntExport void ReadSamplesClassMlp(const HTuple& MLPHandle, const HTuple& FileName);

// Write the training data of a multilayer perceptron to a file.
LIntExport void WriteSamplesClassMlp(const HTuple& MLPHandle, const HTuple& FileName);

// Calculate the class of a feature vector by a multilayer perceptron.
LIntExport void ClassifyClassMlp(const HTuple& MLPHandle, const HTuple& Features, const HTuple& Num, HTuple* Class, HTuple* Confidence);

// Calculate the evaluation of a feature vector by a multilayer perceptron.
LIntExport void EvaluateClassMlp(const HTuple& MLPHandle, const HTuple& Features, HTuple* Result);

// Train a multilayer perceptron.
LIntExport void TrainClassMlp(const HTuple& MLPHandle, const HTuple& MaxIterations, const HTuple& WeightTolerance, const HTuple& ErrorTolerance, HTuple* Error, HTuple* ErrorLog);

// Compute the information content of the preprocessed feature vectors of a multilayer perceptron.
LIntExport void GetPrepInfoClassMlp(const HTuple& MLPHandle, const HTuple& Preprocessing, HTuple* InformationCont, HTuple* CumInformationCont);

// Return the number of training samples stored in the training data of a multilayer perceptron.
LIntExport void GetSampleNumClassMlp(const HTuple& MLPHandle, HTuple* NumSamples);

// Return a training sample from the training data of a multilayer perceptron.
LIntExport void GetSampleClassMlp(const HTuple& MLPHandle, const HTuple& IndexSample, HTuple* Features, HTuple* Target);

// Get the parameters of a rejection class.
LIntExport void GetRejectionParamsClassMlp(const HTuple& MLPHandle, const HTuple& GenParamName, HTuple* GenParamValue);

// Set the parameters of a rejection class.
LIntExport void SetRejectionParamsClassMlp(const HTuple& MLPHandle, const HTuple& GenParamName, const HTuple& GenParamValue);

// Add a training sample to the training data of a multilayer perceptron.
LIntExport void AddSampleClassMlp(const HTuple& MLPHandle, const HTuple& Features, const HTuple& Target);

// Return the regularization parameters of a multilayer perceptron.
LIntExport void GetRegularizationParamsClassMlp(const HTuple& MLPHandle, const HTuple& GenParamName, HTuple* GenParamValue);

// Set the regularization parameters of a multilayer perceptron.
LIntExport void SetRegularizationParamsClassMlp(const HTuple& MLPHandle, const HTuple& GenParamName, const HTuple& GenParamValue);

// Return the parameters of a multilayer perceptron.
LIntExport void GetParamsClassMlp(const HTuple& MLPHandle, HTuple* NumInput, HTuple* NumHidden, HTuple* NumOutput, HTuple* OutputFunction, HTuple* Preprocessing, HTuple* NumComponents);

// Create a multilayer perceptron for classification or regression.
LIntExport void CreateClassMlp(const HTuple& NumInput, const HTuple& NumHidden, const HTuple& NumOutput, const HTuple& OutputFunction, const HTuple& Preprocessing, const HTuple& NumComponents, const HTuple& RandSeed, HTuple* MLPHandle);

// Deserialize a serialized classifier.
LIntExport void DeserializeClassBox(const HTuple& ClassifHandle, const HTuple& SerializedItemHandle);

// Serialize a classifier.
LIntExport void SerializeClassBox(const HTuple& ClassifHandle, HTuple* SerializedItemHandle);

// Save a classifier in a file.
LIntExport void WriteClassBox(const HTuple& ClassifHandle, const HTuple& FileName);

// Set system parameters for classification.
LIntExport void SetClassBoxParam(const HTuple& ClassifHandle, const HTuple& Flag, const HTuple& Value);

// Read a training data set from a file.
LIntExport void ReadSampset(const HTuple& FileName, HTuple* SampKey);

// Read a classifier from a file.
LIntExport void ReadClassBox(const HTuple& ClassifHandle, const HTuple& FileName);

// Train the classifier with one data set.
LIntExport void LearnSampsetBox(const HTuple& ClassifHandle, const HTuple& SampKey, const HTuple& Outfile, const HTuple& NSamples, const HTuple& StopError, const HTuple& ErrorN);

// Train the classifier.
LIntExport void LearnClassBox(const HTuple& ClassifHandle, const HTuple& Features, const HTuple& Class);

// Get information about the current parameter.
LIntExport void GetClassBoxParam(const HTuple& ClassifHandle, const HTuple& Flag, HTuple* Value);

// Free memory of a data set.
LIntExport void ClearSampset(const HTuple& SampKey);

// Destroy the classifier.
LIntExport void CloseClassBox(const HTuple& ClassifHandle);

// Create a new classifier.
LIntExport void CreateClassBox(HTuple* ClassifHandle);

// Describe the classes of a box classifier.
LIntExport void DescriptClassBox(const HTuple& ClassifHandle, const HTuple& Dimensions, HTuple* ClassIdx, HTuple* BoxIdx, HTuple* BoxLowerBound, HTuple* BoxHigherBound, HTuple* BoxNumSamplesTrain, HTuple* BoxNumSamplesWrong);

// Classify a set of arrays.
LIntExport void TestSampsetBox(const HTuple& ClassifHandle, const HTuple& SampKey, HTuple* Error);

// Classify a tuple of attributes with rejection class.
LIntExport void EnquireRejectClassBox(const HTuple& ClassifHandle, const HTuple& FeatureList, HTuple* Class);

// Classify a tuple of attributes.
LIntExport void EnquireClassBox(const HTuple& ClassifHandle, const HTuple& FeatureList, HTuple* Class);

// Destroy all classifiers.
LIntExport void CloseAllClassBox();

// Convert image maps into other map types.
LIntExport void ConvertMapType(const HObject& Map, HObject* MapConverted, const HTuple& NewType, const HTuple& ImageWidth);

// Compute an absolute pose out of point correspondences between world and image coordinates.
LIntExport void VectorToPose(const HTuple& WorldX, const HTuple& WorldY, const HTuple& WorldZ, const HTuple& ImageRow, const HTuple& ImageColumn, const HTuple& CameraParam, const HTuple& Method, const HTuple& QualityType, HTuple* Pose, HTuple* Quality);

// Compute a pose out of a homography describing the relation between world and image coordinates.
LIntExport void ProjHomMat2dToPose(const HTuple& Homography, const HTuple& CameraMatrix, const HTuple& Method, HTuple* Pose);

// Calibrate the radial distortion.
LIntExport void RadialDistortionSelfCalibration(const HObject& Contours, HObject* SelectedContours, const HTuple& Width, const HTuple& Height, const HTuple& InlierThreshold, const HTuple& RandSeed, const HTuple& DistortionModel, const HTuple& DistortionCenter, const HTuple& PrincipalPointVar, HTuple* CameraParam);

// Compute a camera matrix from internal camera parameters.
LIntExport void CamParToCamMat(const HTuple& CameraParam, HTuple* CameraMatrix, HTuple* ImageWidth, HTuple* ImageHeight);

// Compute the internal camera parameters from a camera matrix.
LIntExport void CamMatToCamPar(const HTuple& CameraMatrix, const HTuple& Kappa, const HTuple& ImageWidth, const HTuple& ImageHeight, HTuple* CameraParam);

// Perform a self-calibration of a stationary projective camera.
LIntExport void StationaryCameraSelfCalibration(const HTuple& NumImages, const HTuple& ImageWidth, const HTuple& ImageHeight, const HTuple& ReferenceImage, const HTuple& MappingSource, const HTuple& MappingDest, const HTuple& HomMatrices2D, const HTuple& Rows1, const HTuple& Cols1, const HTuple& Rows2, const HTuple& Cols2, const HTuple& NumCorrespondences, const HTuple& EstimationMethod, const HTuple& CameraModel, const HTuple& FixedCameraParams, HTuple* CameraMatrices, HTuple* Kappa, HTuple* RotationMatrices, HTuple* X, HTuple* Y, HTuple* Z, HTuple* Error);

// Determine the 3D pose of a rectangle from its perspective 2D projection
LIntExport void GetRectanglePose(const HObject& Contour, const HTuple& CameraParam, const HTuple& Width, const HTuple& Height, const HTuple& WeightingMode, const HTuple& ClippingFactor, HTuple* Pose, HTuple* CovPose, HTuple* Error);

// Determine the 3D pose of a circle from its perspective 2D projection. 
LIntExport void GetCirclePose(const HObject& Contour, const HTuple& CameraParam, const HTuple& Radius, const HTuple& OutputType, HTuple* Pose1, HTuple* Pose2);

// Perform a radiometric self-calibration of a camera.
LIntExport void RadiometricSelfCalibration(const HObject& Images, const HTuple& ExposureRatios, const HTuple& Features, const HTuple& FunctionType, const HTuple& Smoothness, const HTuple& PolynomialDegree, HTuple* InverseResponse);

// Apply a general transformation to an image.
LIntExport void MapImage(const HObject& Image, const HObject& Map, HObject* ImageMapped);

// Generate a projection map that describes the mapping of images corresponding to a changing radial distortion.
LIntExport void GenRadialDistortionMap(HObject* Map, const HTuple& CamParamIn, const HTuple& CamParamOut, const HTuple& MapType);

// Generate a projection map that describes the mapping between the image plane and a the plane z=0 of a world coordinate system.
LIntExport void GenImageToWorldPlaneMap(HObject* Map, const HTuple& CameraParam, const HTuple& WorldPose, const HTuple& WidthIn, const HTuple& HeightIn, const HTuple& WidthMapped, const HTuple& HeightMapped, const HTuple& Scale, const HTuple& MapType);

// Rectify an image by transforming it into the plane z=0 of a world  coordinate system.
LIntExport void ImageToWorldPlane(const HObject& Image, HObject* ImageWorld, const HTuple& CameraParam, const HTuple& WorldPose, const HTuple& Width, const HTuple& Height, const HTuple& Scale, const HTuple& Interpolation);

// Transform an XLD contour into the plane z=0 of a world coordinate system.
LIntExport void ContourToWorldPlaneXld(const HObject& Contours, HObject* ContoursTrans, const HTuple& CameraParam, const HTuple& WorldPose, const HTuple& Scale);

// Transform image points into the plane z=0 of a world coordinate system.
LIntExport void ImagePointsToWorldPlane(const HTuple& CameraParam, const HTuple& WorldPose, const HTuple& Rows, const HTuple& Cols, const HTuple& Scale, HTuple* X, HTuple* Y);

// Translate the origin of a 3D pose.
LIntExport void SetOriginPose(const HTuple& PoseIn, const HTuple& DX, const HTuple& DY, const HTuple& DZ, HTuple* PoseNewOrigin);

// Perform a hand-eye calibration.
LIntExport void HandEyeCalibration(const HTuple& X, const HTuple& Y, const HTuple& Z, const HTuple& Row, const HTuple& Col, const HTuple& NumPoints, const HTuple& RobotPoses, const HTuple& CameraParam, const HTuple& Method, const HTuple& QualityType, HTuple* CameraPose, HTuple* CalibrationPose, HTuple* Quality);

// Get the representation type of a 3D pose.
LIntExport void GetPoseType(const HTuple& Pose, HTuple* OrderOfTransform, HTuple* OrderOfRotation, HTuple* ViewOfTransform);

// Change the representation type of a 3D pose.
LIntExport void ConvertPoseType(const HTuple& PoseIn, const HTuple& OrderOfTransform, const HTuple& OrderOfRotation, const HTuple& ViewOfTransform, HTuple* PoseOut);

// Create a 3D pose.
LIntExport void CreatePose(const HTuple& TransX, const HTuple& TransY, const HTuple& TransZ, const HTuple& RotX, const HTuple& RotY, const HTuple& RotZ, const HTuple& OrderOfTransform, const HTuple& OrderOfRotation, const HTuple& ViewOfTransform, HTuple* Pose);

// Change the radial distortion of contours.
LIntExport void ChangeRadialDistortionContoursXld(const HObject& Contours, HObject* ContoursRectified, const HTuple& CamParamIn, const HTuple& CamParamOut);

// Change the radial distortion of pixel coordinates.
LIntExport void ChangeRadialDistortionPoints(const HTuple& Row, const HTuple& Col, const HTuple& CamParamIn, const HTuple& CamParamOut, HTuple* RowChanged, HTuple* ColChanged);

// Change the radial distortion of an image.
LIntExport void ChangeRadialDistortionImage(const HObject& Image, const HObject& Region, HObject* ImageRectified, const HTuple& CamParamIn, const HTuple& CamParamOut);

// Determine new camera parameters in accordance to the specified radial distortion.
LIntExport void ChangeRadialDistortionCamPar(const HTuple& Mode, const HTuple& CamParamIn, const HTuple& DistortionCoeffs, HTuple* CamParamOut);

// Generate a calibration plate description file and a corresponding PostScript file for a calibration plate with rectangularly arranged marks.
LIntExport void GenCaltab(const HTuple& XNum, const HTuple& YNum, const HTuple& MarkDist, const HTuple& DiameterRatio, const HTuple& CalPlateDescr, const HTuple& CalPlatePSFile);

// Generate a calibration plate description file and a corresponding PostScript file for a calibration plate with hexagonally arranged marks.
LIntExport void CreateCaltab(const HTuple& NumRows, const HTuple& MarksPerRow, const HTuple& Diameter, const HTuple& FinderRow, const HTuple& FinderColumn, const HTuple& Polarity, const HTuple& CalPlateDescr, const HTuple& CalPlatePSFile);

// Read the mark center points from the calibration plate description file.
LIntExport void CaltabPoints(const HTuple& CalPlateDescr, HTuple* X, HTuple* Y, HTuple* Z);

// Compute the line of sight corresponding to a point in the image.
LIntExport void GetLineOfSight(const HTuple& Row, const HTuple& Column, const HTuple& CameraParam, HTuple* PX, HTuple* PY, HTuple* PZ, HTuple* QX, HTuple* QY, HTuple* QZ);

// Project a homogeneous 3D point using a 3x4 projection matrix.
LIntExport void ProjectHomPointHomMat3d(const HTuple& HomMat3D, const HTuple& Px, const HTuple& Py, const HTuple& Pz, const HTuple& Pw, HTuple* Qx, HTuple* Qy, HTuple* Qw);

// Project a 3D point using a 3x4 projection matrix.
LIntExport void ProjectPointHomMat3d(const HTuple& HomMat3D, const HTuple& Px, const HTuple& Py, const HTuple& Pz, HTuple* Qx, HTuple* Qy);

// Project 3D points into (sub-)pixel image coordinates.
LIntExport void Project3dPoint(const HTuple& X, const HTuple& Y, const HTuple& Z, const HTuple& CameraParam, HTuple* Row, HTuple* Column);

// Convert internal camera parameters and a 3D pose into a 3x4 projection matrix.
LIntExport void CamParPoseToHomMat3d(const HTuple& CameraParam, const HTuple& Pose, HTuple* HomMat3D);

// Convert a homogeneous transformation matrix into a 3D pose.
LIntExport void HomMat3dToPose(const HTuple& HomMat3D, HTuple* Pose);

// Convert a 3D pose into a homogeneous transformation matrix.
LIntExport void PoseToHomMat3d(const HTuple& Pose, HTuple* HomMat3D);

// Deserialize the serialized internal camera parameters.
LIntExport void DeserializeCamPar(const HTuple& SerializedItemHandle, HTuple* CameraParam);

// Serialize the internal camera parameters.
LIntExport void SerializeCamPar(const HTuple& CameraParam, HTuple* SerializedItemHandle);

// Deserialize a serialized pose.
LIntExport void DeserializePose(const HTuple& SerializedItemHandle, HTuple* Pose);

// Serialize a pose.
LIntExport void SerializePose(const HTuple& Pose, HTuple* SerializedItemHandle);

// Read a 3D pose from a text file.
LIntExport void ReadPose(const HTuple& PoseFile, HTuple* Pose);

// Write a 3D pose to a text file.
LIntExport void WritePose(const HTuple& Pose, const HTuple& PoseFile);

// Read the internal camera parameters from a text file.
LIntExport void ReadCamPar(const HTuple& CamParFile, HTuple* CameraParam);

// Write the internal camera parameters to a text file.
LIntExport void WriteCamPar(const HTuple& CameraParam, const HTuple& CamParFile);

// Simulate an image with calibration plate.
LIntExport void SimCaltab(HObject* SimImage, const HTuple& CalPlateDescr, const HTuple& CameraParam, const HTuple& CalPlatePose, const HTuple& GrayBackground, const HTuple& GrayPlate, const HTuple& GrayMarks, const HTuple& ScaleFac);

// Project and visualize the 3D model of the calibration plate in the image.
LIntExport void DispCaltab(const HTuple& WindowHandle, const HTuple& CalPlateDescr, const HTuple& CameraParam, const HTuple& CalPlatePose, const HTuple& ScaleFac);

// Determine all camera parameters by a simultaneous minimization process.
LIntExport void CameraCalibration(const HTuple& NX, const HTuple& NY, const HTuple& NZ, const HTuple& NRow, const HTuple& NCol, const HTuple& StartCamParam, const HTuple& NStartPose, const HTuple& EstimateParams, HTuple* CameraParam, HTuple* NFinalPose, HTuple* Errors);

// Extract rectangularly arranged 2D calibration marks from the image and calculate initial values for the external camera parameters.
LIntExport void FindMarksAndPose(const HObject& Image, const HObject& CalPlateRegion, const HTuple& CalPlateDescr, const HTuple& StartCamParam, const HTuple& StartThresh, const HTuple& DeltaThresh, const HTuple& MinThresh, const HTuple& Alpha, const HTuple& MinContLength, const HTuple& MaxDiamMarks, HTuple* RCoord, HTuple* CCoord, HTuple* StartPose);

// Segment the region of a standard calibration plate with rectangularly arranged marks in the image.
LIntExport void FindCaltab(const HObject& Image, HObject* CalPlate, const HTuple& CalPlateDescr, const HTuple& SizeGauss, const HTuple& MarkThresh, const HTuple& MinDiamMarks);

// Free the memory of all camera setup models.
LIntExport void ClearAllCameraSetupModels();

// Free the memory of a calibration setup model.
LIntExport void ClearCameraSetupModel(const HTuple& CameraSetupModelID);

// Serialize a camera setup model.
LIntExport void SerializeCameraSetupModel(const HTuple& CameraSetupModelID, HTuple* SerializedItemHandle);

// Deserialize a serialized camera setup model.
LIntExport void DeserializeCameraSetupModel(const HTuple& SerializedItemHandle, HTuple* CameraSetupModelID);

// Store a camera setup model into a file.
LIntExport void WriteCameraSetupModel(const HTuple& CameraSetupModelID, const HTuple& FileName);

// Restore a camera setup model from a file.
LIntExport void ReadCameraSetupModel(const HTuple& FileName, HTuple* CameraSetupModelID);

// Get generic camera setup model parameters.
LIntExport void GetCameraSetupParam(const HTuple& CameraSetupModelID, const HTuple& CameraIdx, const HTuple& ParamName, HTuple* ParamValue);

// Set generic camera setup model parameters.
LIntExport void SetCameraSetupParam(const HTuple& CameraSetupModelID, const HTuple& CameraIdx, const HTuple& ParamName, const HTuple& ParamValue);

// Define type, parameters, and relative pose of a camera in a camera setup model.
LIntExport void SetCameraSetupCamParam(const HTuple& CameraSetupModelID, const HTuple& CameraIdx, const HTuple& CameraType, const HTuple& CameraParam, const HTuple& CameraPose);

// Create a model for a setup of calibrated cameras.
LIntExport void CreateCameraSetupModel(const HTuple& NumCameras, HTuple* CameraSetupModelID);

// Free the memory of all calibration data models.
LIntExport void ClearAllCalibData();

// Free the memory of a calibration data model.
LIntExport void ClearCalibData(const HTuple& CalibDataID);

// Deserialize a serialized calibration data model.
LIntExport void DeserializeCalibData(const HTuple& SerializedItemHandle, HTuple* CalibDataID);

// Serialize a calibration data model.
LIntExport void SerializeCalibData(const HTuple& CalibDataID, HTuple* SerializedItemHandle);

// Restore a calibration data model from a file.
LIntExport void ReadCalibData(const HTuple& FileName, HTuple* CalibDataID);

// Store a calibration data model into a file.
LIntExport void WriteCalibData(const HTuple& CalibDataID, const HTuple& FileName);

// Perform a hand-eye calibration.
LIntExport void CalibrateHandEye(const HTuple& CalibDataID, HTuple* Errors);

// Determine all camera parameters by a simultaneous minimization process.
LIntExport void CalibrateCameras(const HTuple& CalibDataID, HTuple* Error);

// Remove a data set from a calibration data model.
LIntExport void RemoveCalibData(const HTuple& CalibDataID, const HTuple& ItemType, const HTuple& ItemIdx);

// Set data in a calibration data model.
LIntExport void SetCalibData(const HTuple& CalibDataID, const HTuple& ItemType, const HTuple& ItemIdx, const HTuple& DataName, const HTuple& DataValue);

// Find the HALCON calibration plate and set the extracted points and contours in a calibration data model.
LIntExport void FindCalibObject(const HObject& Image, const HTuple& CalibDataID, const HTuple& CameraIdx, const HTuple& CalibObjIdx, const HTuple& CalibObjPoseIdx, const HTuple& GenParamName, const HTuple& GenParamValue);

// Remove observation data from a calibration data model.
LIntExport void RemoveCalibDataObserv(const HTuple& CalibDataID, const HTuple& CameraIdx, const HTuple& CalibObjIdx, const HTuple& CalibObjPoseIdx);

// Get contour-based observation data from a calibration data model.
LIntExport void GetCalibDataObservContours(HObject* Contours, const HTuple& CalibDataID, const HTuple& ContourName, const HTuple& CameraIdx, const HTuple& CalibObjIdx, const HTuple& CalibObjPoseIdx);

// Get observed calibration object poses from a calibration data model.
LIntExport void GetCalibDataObservPose(const HTuple& CalibDataID, const HTuple& CameraIdx, const HTuple& CalibObjIdx, const HTuple& CalibObjPoseIdx, HTuple* ObjInCameraPose);

// Set observed calibration object poses in a calibration data model.
LIntExport void SetCalibDataObservPose(const HTuple& CalibDataID, const HTuple& CameraIdx, const HTuple& CalibObjIdx, const HTuple& CalibObjPoseIdx, const HTuple& ObjInCameraPose);

// Get point-based observation data from a calibration data model.
LIntExport void GetCalibDataObservPoints(const HTuple& CalibDataID, const HTuple& CameraIdx, const HTuple& CalibObjIdx, const HTuple& CalibObjPoseIdx, HTuple* Row, HTuple* Column, HTuple* Index, HTuple* Pose);

// Set point-based observation data in a calibration data model.
LIntExport void SetCalibDataObservPoints(const HTuple& CalibDataID, const HTuple& CameraIdx, const HTuple& CalibObjIdx, const HTuple& CalibObjPoseIdx, const HTuple& Row, const HTuple& Column, const HTuple& Index, const HTuple& Pose);

// Query information about the relations between cameras, calibration objects, and calibration object poses.
LIntExport void QueryCalibDataObservIndices(const HTuple& CalibDataID, const HTuple& ItemType, const HTuple& ItemIdx, HTuple* Index1, HTuple* Index2);

// Query data stored or computed in a calibration data model.
LIntExport void GetCalibData(const HTuple& CalibDataID, const HTuple& ItemType, const HTuple& ItemIdx, const HTuple& DataName, HTuple* DataValue);

// Define a calibration object in a calibration model.
LIntExport void SetCalibDataCalibObject(const HTuple& CalibDataID, const HTuple& CalibObjIdx, const HTuple& CalibObjDescr);

// Set type and initial parameters of a camera in a calibration data model.
LIntExport void SetCalibDataCamParam(const HTuple& CalibDataID, const HTuple& CameraIdx, const HTuple& CameraType, const HTuple& CameraParam);

// Create a HALCON calibration data model.
LIntExport void CreateCalibData(const HTuple& CalibSetup, const HTuple& NumCameras, const HTuple& NumCalibObjects, HTuple* CalibDataID);

// Get the value of a parameter in a specific bead inspection model.
LIntExport void GetBeadInspectionParam(const HTuple& BeadInspectionModel, const HTuple& ParamName, HTuple* ParamValue);

// Set parameters of the bead inspection model.
LIntExport void SetBeadInspectionParam(const HTuple& BeadInspectionModel, const HTuple& ParamName, const HTuple& ParamValue);

// Inspect beads in an image, as defined by the bead inspection model.
LIntExport void ApplyBeadInspectionModel(const HObject& Image, HObject* LeftContour, HObject* RightContour, HObject* ErrorSegment, const HTuple& BeadInspectionModel, HTuple* ErrorType);

// Delete the bead inspection model and free the allocated memory.
LIntExport void ClearBeadInspectionModel(const HTuple& BeadInspectionModel);

// Create a model to inspect beads or adhesive in images.
LIntExport void CreateBeadInspectionModel(const HObject& BeadContour, const HTuple& TargetThickness, const HTuple& ThicknessTolerance, const HTuple& PositionTolerance, const HTuple& Polarity, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* BeadInspectionModel);

// Deserialize a bar code model.
LIntExport void DeserializeBarCodeModel(const HTuple& SerializedItemHandle, HTuple* BarCodeHandle);

// Serialize a bar code model.
LIntExport void SerializeBarCodeModel(const HTuple& BarCodeHandle, HTuple* SerializedItemHandle);

// Read a bar code model from a file and create a new model.
LIntExport void ReadBarCodeModel(const HTuple& FileName, HTuple* BarCodeHandle);

// Write a bar code model to a file.
LIntExport void WriteBarCodeModel(const HTuple& BarCodeHandle, const HTuple& FileName);

// Access iconic objects that were created during the search or decoding of bar code symbols.
LIntExport void GetBarCodeObject(HObject* BarCodeObjects, const HTuple& BarCodeHandle, const HTuple& CandidateHandle, const HTuple& ObjectName);

// Get the alphanumerical results that were accumulated during the decoding of bar code symbols.
LIntExport void GetBarCodeResult(const HTuple& BarCodeHandle, const HTuple& CandidateHandle, const HTuple& ResultName, HTuple* BarCodeResults);

// Decode bar code symbols within a rectangle.
LIntExport void DecodeBarCodeRectangle2(const HObject& Image, const HTuple& BarCodeHandle, const HTuple& CodeType, const HTuple& Row, const HTuple& Column, const HTuple& Phi, const HTuple& Length1, const HTuple& Length2, HTuple* DecodedDataStrings);

// Detect and read bar code symbols in an image.
LIntExport void FindBarCode(const HObject& Image, HObject* SymbolRegions, const HTuple& BarCodeHandle, const HTuple& CodeType, HTuple* DecodedDataStrings);

// Get the names of the parameters that can be used in set_bar_code* and get_bar_code* operators for a given bar code model
LIntExport void QueryBarCodeParams(const HTuple& BarCodeHandle, const HTuple& Properties, HTuple* GenParamNames);

// Get parameters that are used by the bar code reader when processing a specific bar code type. 
LIntExport void GetBarCodeParamSpecific(const HTuple& BarCodeHandle, const HTuple& CodeTypes, const HTuple& GenParamNames, HTuple* GenParamValues);

// Get one or several parameters that describe the bar code model.
LIntExport void GetBarCodeParam(const HTuple& BarCodeHandle, const HTuple& GenParamNames, HTuple* GenParamValues);

// Set selected parameters of the bar code model for selected bar code types
LIntExport void SetBarCodeParamSpecific(const HTuple& BarCodeHandle, const HTuple& CodeTypes, const HTuple& GenParamNames, const HTuple& GenParamValues);

// Set selected parameters of the bar code model.
LIntExport void SetBarCodeParam(const HTuple& BarCodeHandle, const HTuple& GenParamNames, const HTuple& GenParamValues);

// Delete all bar code models and free the allocated memory
LIntExport void ClearAllBarCodeModels();

// Delete a bar code model and free the allocated memory
LIntExport void ClearBarCodeModel(const HTuple& BarCodeHandle);

// Create a model of a bar code reader.
LIntExport void CreateBarCodeModel(const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* BarCodeHandle);

// Decode 2D bar code data.
LIntExport void Decode2dBarCode(const HTuple& BarCodeDescr, const HTuple& BarCodeDimension, const HTuple& BarCodeData, HTuple* SymbolCharacters, HTuple* CorrSymbolData, HTuple* DecodedData, HTuple* DecodingError, HTuple* StructuredAppend);

// Extract the data values of the elements (in ECC 200: "modules") inside a bar code region ("Data Matrix symbol") and their positions in the image.
LIntExport void Get2dBarCodePos(const HObject& BarCodeRegion, const HObject& Image, const HTuple& BarCodeDescr, const HTuple& CodeRegDescr, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* BarCodeDimension, HTuple* BarCodeData, HTuple* DataElementRow, HTuple* DataElementCol);

// Extract the values of the data elements (in ECC 200: "modules") inside a bar code region ("Data Matrix symbol").
LIntExport void Get2dBarCode(const HObject& BarCodeRegion, const HObject& Image, const HTuple& BarCodeDescr, const HTuple& CodeRegDescr, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* BarCodeDimension, HTuple* BarCodeData);

// Find regions that might contain a 2D bar code.
LIntExport void Find2dBarCode(const HObject& Image, HObject* CodeRegion, const HTuple& BarCodeDescr, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* CodeRegDescr);

// Generate a generic description of a 2D bar code class.
LIntExport void Gen2dBarCodeDescr(const HTuple& CodeType, const HTuple& GenParamNames, const HTuple& GenParamValues, HTuple* BarCodeDescr);

// Generate a discrete bar code from the elements widths.
LIntExport void Discrete1dBarCode(const HTuple& Elements, const HTuple& BarCodeDescr, HTuple* DiscreteBarCode);

// Decoding of a sequence of elements of a bar code.
LIntExport void Decode1dBarCode(const HTuple& BarCodeElements, const HTuple& BarCodeDescr, HTuple* Characters, HTuple* Reference, HTuple* IsCorrect);

// Extract the widths of the elements inside a bar code region.
LIntExport void Get1dBarCodeScanline(const HObject& BarCodeRegion, const HTuple& BarCodeDescr, const HTuple& GenericName, const HTuple& GenericValue, const HTuple& Orientation, const HTuple& StopIfFound, HTuple* BarCodeElements, HTuple* ScanlineNumPoints, HTuple* ScanlineDecoded, HTuple* ScanlinePointsRow, HTuple* ScanlinePointsColumn);

// Extract the widths of the elements inside a bar code region.
LIntExport void Get1dBarCode(const HObject& BarCodeRegion, const HTuple& BarCodeDescr, const HTuple& GenericName, const HTuple& GenericValue, const HTuple& Orientation, HTuple* BarCodeElements);

// Look for multiple bar code regions in an image.
LIntExport void Find1dBarCodeRegion(const HObject& Image, HObject* CodeRegion, const HTuple& BarCodeDescr, const HTuple& GenericName, const HTuple& GenericValue, HTuple* Orientation);

// Look for one bar code in an image.
LIntExport void Find1dBarCodeScanline(const HObject& Image, HObject* CodeRegion, const HTuple& BarCodeDescr, const HTuple& GenericName, const HTuple& GenericValue, const HTuple& StopIfFound, HTuple* BarcodeFound, HTuple* BarCodeElements, HTuple* Orientation, HTuple* ScanlineNumPoints, HTuple* ScanlineDecoded, HTuple* ScanlinePointsRow, HTuple* ScanlinePointsColumn);

// Look for one bar code in an image.
LIntExport void Find1dBarCode(const HObject& Image, HObject* CodeRegion, const HTuple& BarCodeDescr, const HTuple& GenericName, const HTuple& GenericValue, HTuple* BarcodeFound, HTuple* BarCodeElements, HTuple* Orientation);

// Generate a description of a 1D bar code.
LIntExport void Gen1dBarCodeDescr(const HTuple& CodeName, const HTuple& MinCharacters, const HTuple& MaxCharacters, HTuple* BarCodeDescr);

// Generate a generic description of a 1D bar code.
LIntExport void Gen1dBarCodeDescrGen(const HTuple& MinCodeLength, const HTuple& MaxCodeLength, const HTuple& ElementSizes, const HTuple& StartElement, const HTuple& StopElement, const HTuple& MaxSizeRatio, const HTuple& DiscreteCode, HTuple* BarCodeDescr);

// Delete the background estimation data set.
LIntExport void CloseBgEsti(const HTuple& BgEstiHandle);

// Return the estimated background image.
LIntExport void GiveBgEsti(HObject* BackgroundImage, const HTuple& BgEstiHandle);

// Change the estimated background image.
LIntExport void UpdateBgEsti(const HObject& PresentImage, const HObject& UpDateRegion, const HTuple& BgEstiHandle);

// Estimate the background and return the foreground region.
LIntExport void RunBgEsti(const HObject& PresentImage, HObject* ForegroundRegion, const HTuple& BgEstiHandle);

// Return the parameters of the data set.
LIntExport void GetBgEstiParams(const HTuple& BgEstiHandle, HTuple* Syspar1, HTuple* Syspar2, HTuple* GainMode, HTuple* Gain1, HTuple* Gain2, HTuple* AdaptMode, HTuple* MinDiff, HTuple* StatNum, HTuple* ConfidenceC, HTuple* TimeC);

// Change the parameters of the data set.
LIntExport void SetBgEstiParams(const HTuple& BgEstiHandle, const HTuple& Syspar1, const HTuple& Syspar2, const HTuple& GainMode, const HTuple& Gain1, const HTuple& Gain2, const HTuple& AdaptMode, const HTuple& MinDiff, const HTuple& StatNum, const HTuple& ConfidenceC, const HTuple& TimeC);

// Generate and initialize a data set for the background estimation.
LIntExport void CreateBgEsti(const HObject& InitializeImage, const HTuple& Syspar1, const HTuple& Syspar2, const HTuple& GainMode, const HTuple& Gain1, const HTuple& Gain2, const HTuple& AdaptMode, const HTuple& MinDiff, const HTuple& StatNum, const HTuple& ConfidenceC, const HTuple& TimeC, HTuple* BgEstiHandle);

// Delete all background estimation data sets.
LIntExport void CloseAllBgEsti();

// Perform an action on I/O channels.
LIntExport void ControlIoChannel(const HTuple& IOChannelHandle, const HTuple& ParamAction, const HTuple& ParamArgument, HTuple* ParamValue);

// Write a value to the specified I/O channels.
LIntExport void WriteIoChannel(const HTuple& IOChannelHandle, const HTuple& Value, HTuple* Status);

// Read a value from the specified I/O channels.
LIntExport void ReadIoChannel(const HTuple& IOChannelHandle, HTuple* Value, HTuple* Status);

// Set specific parameters of I/O channels.
LIntExport void SetIoChannelParam(const HTuple& IOChannelHandle, const HTuple& ParamName, const HTuple& ParamValue);

// Query specific parameters of I/O channels.
LIntExport void GetIoChannelParam(const HTuple& IOChannelHandle, const HTuple& ParamName, HTuple* ParamValue);

// Close I/O channels.
LIntExport void CloseIoChannel(const HTuple& IOChannelHandle);

// Open and configure I/O channels.
LIntExport void OpenIoChannel(const HTuple& IODeviceHandle, const HTuple& IOChannelName, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* IOChannelHandle);

// Query information about channels of the specified I/O device. 
LIntExport void QueryIoDevice(const HTuple& IODeviceHandle, const HTuple& IOChannelName, const HTuple& Query, HTuple* Result);

// Perform an action on the I/O device.
LIntExport void ControlIoDevice(const HTuple& IODeviceHandle, const HTuple& Action, const HTuple& Argument, HTuple* Result);

// Configure a specific I/O device instance.
LIntExport void SetIoDeviceParam(const HTuple& IODeviceHandle, const HTuple& ParamName, const HTuple& ParamValue);

// Query settings of an I/O device instance. 
LIntExport void GetIoDeviceParam(const HTuple& IODeviceHandle, const HTuple& ParamName, HTuple* ParamValue);

// Close the specified I/O device. 
LIntExport void CloseIoDevice(const HTuple& IODeviceHandle);

// Open and configure an I/O device. 
LIntExport void OpenIoDevice(const HTuple& IOInterfaceName, const HTuple& IODeviceName, const HTuple& GenParamName, const HTuple& GenParamValue, HTuple* IODeviceHandle);

// Perform an action on the I/O interface.
LIntExport void ControlIoInterface(const HTuple& IOInterfaceName, const HTuple& Action, const HTuple& Argument, HTuple* Result);

// Query information about the specified I/O device interface.
LIntExport void QueryIoInterface(const HTuple& IOInterfaceName, const HTuple& Query, HTuple* Result);

// Query specific parameters of an image acquisition device.
LIntExport void GetFramegrabberParam(const HTuple& AcqHandle, const HTuple& Param, HTuple* Value);

// Set specific parameters of an image acquistion device.
LIntExport void SetFramegrabberParam(const HTuple& AcqHandle, const HTuple& Param, const HTuple& Value);

// Query callback function of an image acquisition device.
LIntExport void GetFramegrabberCallback(const HTuple& AcqHandle, const HTuple& CallbackType, HTuple* CallbackFunction, HTuple* UserContext);

// Register a callback function for an image acquisition device.
LIntExport void SetFramegrabberCallback(const HTuple& AcqHandle, const HTuple& CallbackType, const HTuple& CallbackFunction, const HTuple& UserContext);

// Asynchronous grab of images and preprocessed image data from the specified image acquisition device.
LIntExport void GrabDataAsync(HObject* Image, HObject* Region, HObject* Contours, const HTuple& AcqHandle, const HTuple& MaxDelay, HTuple* Data);

// Synchronous grab of images and preprocessed image data from the specified image acquisition device.
LIntExport void GrabData(HObject* Image, HObject* Region, HObject* Contours, const HTuple& AcqHandle, HTuple* Data);

// Asynchronous grab of an image from the specified image acquisition device.
LIntExport void GrabImageAsync(HObject* Image, const HTuple& AcqHandle, const HTuple& MaxDelay);

// Start an asynchronous grab from the specified image acquisition device.
LIntExport void GrabImageStart(const HTuple& AcqHandle, const HTuple& MaxDelay);

// Synchronous grab of an image from the specified image acquisition device.
LIntExport void GrabImage(HObject* Image, const HTuple& AcqHandle);

// Query information about the specified image acquisition interface.
LIntExport void InfoFramegrabber(const HTuple& Name, const HTuple& Query, HTuple* Information, HTuple* ValueList);

// Close all image acquisition devices.
LIntExport void CloseAllFramegrabbers();

// Close specified image acquisition device.
LIntExport void CloseFramegrabber(const HTuple& AcqHandle);

// Open and configure an image acquisition device.
LIntExport void OpenFramegrabber(const HTuple& Name, const HTuple& HorizontalResolution, const HTuple& VerticalResolution, const HTuple& ImageWidth, const HTuple& ImageHeight, const HTuple& StartRow, const HTuple& StartColumn, const HTuple& Field, const HTuple& BitsPerChannel, const HTuple& ColorSpace, const HTuple& Generic, const HTuple& ExternalTrigger, const HTuple& CameraType, const HTuple& Device, const HTuple& Port, const HTuple& LineIn, HTuple* AcqHandle);

// Query look-up table of the image acquisition device.
LIntExport void GetFramegrabberLut(const HTuple& AcqHandle, HTuple* ImageRed, HTuple* ImageGreen, HTuple* ImageBlue);

// Set look-up table of the image acquisition device.
LIntExport void SetFramegrabberLut(const HTuple& AcqHandle, const HTuple& ImageRed, const HTuple& ImageGreen, const HTuple& ImageBlue);

}

#endif
